/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};

// ../pk-lib/node_modules/universalify/index.js
var require_universalify = __commonJS({
  "../pk-lib/node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            fn.call(this, ...args, (err, res) => err != null ? reject(err) : resolve(res));
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else
          fn.apply(this, args.slice(0, -1)).then((r) => cb(null, r), cb);
      }, "name", { value: fn.name });
    };
  }
});

// ../pk-lib/node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "../pk-lib/node_modules/graceful-fs/polyfills.js"(exports, module2) {
    var constants = require("constants");
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module2.exports = patch;
    function patch(fs) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs);
      }
      if (!fs.lutimes) {
        patchLutimes(fs);
      }
      fs.chown = chownFix(fs.chown);
      fs.fchown = chownFix(fs.fchown);
      fs.lchown = chownFix(fs.lchown);
      fs.chmod = chmodFix(fs.chmod);
      fs.fchmod = chmodFix(fs.fchmod);
      fs.lchmod = chmodFix(fs.lchmod);
      fs.chownSync = chownFixSync(fs.chownSync);
      fs.fchownSync = chownFixSync(fs.fchownSync);
      fs.lchownSync = chownFixSync(fs.lchownSync);
      fs.chmodSync = chmodFixSync(fs.chmodSync);
      fs.fchmodSync = chmodFixSync(fs.fchmodSync);
      fs.lchmodSync = chmodFixSync(fs.lchmodSync);
      fs.stat = statFix(fs.stat);
      fs.fstat = statFix(fs.fstat);
      fs.lstat = statFix(fs.lstat);
      fs.statSync = statFixSync(fs.statSync);
      fs.fstatSync = statFixSync(fs.fstatSync);
      fs.lstatSync = statFixSync(fs.lstatSync);
      if (fs.chmod && !fs.lchmod) {
        fs.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchmodSync = function() {
        };
      }
      if (fs.chown && !fs.lchown) {
        fs.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs.rename = typeof fs.rename !== "function" ? fs.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs.rename);
      }
      fs.read = typeof fs.read !== "function" ? fs.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs.read);
      fs.readSync = typeof fs.readSync !== "function" ? fs.readSync : function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs.readSync);
      function patchLchmod(fs2) {
        fs2.lchmod = function(path, mode, callback) {
          fs2.open(path, constants.O_WRONLY | constants.O_SYMLINK, mode, function(err, fd) {
            if (err) {
              if (callback)
                callback(err);
              return;
            }
            fs2.fchmod(fd, mode, function(err2) {
              fs2.close(fd, function(err22) {
                if (callback)
                  callback(err2 || err22);
              });
            });
          });
        };
        fs2.lchmodSync = function(path, mode) {
          var fd = fs2.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs2.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs2.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs2.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs2) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs2.futimes) {
          fs2.lutimes = function(path, at, mt, cb) {
            fs2.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs2.futimes(fd, at, mt, function(er2) {
                fs2.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs2.lutimesSync = function(path, at, mt) {
            var fd = fs2.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs2.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs2.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs2.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs2.futimes) {
          fs2.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs2.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs, target, options, callback) : orig.call(fs, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs, target, options) : orig.call(fs, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// ../pk-lib/node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "../pk-lib/node_modules/graceful-fs/legacy-streams.js"(exports, module2) {
    var Stream = require("stream").Stream;
    module2.exports = legacy;
    function legacy(fs) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if (typeof this.end !== "number") {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if (typeof this.start !== "number") {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// ../pk-lib/node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "../pk-lib/node_modules/graceful-fs/clone.js"(exports, module2) {
    "use strict";
    module2.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// ../pk-lib/node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "../pk-lib/node_modules/graceful-fs/graceful-fs.js"(exports, module2) {
    var fs = require("fs");
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require("util");
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs, queue);
      fs.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs.close);
      fs.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs[gracefulQueue]);
          require("assert").equal(fs[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs[gracefulQueue]);
    }
    module2.exports = patch(clone(fs));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
      module2.exports = patch(fs);
      fs.__patched = true;
    }
    function patch(fs2) {
      polyfills(fs2);
      fs2.gracefulify = patch;
      fs2.createReadStream = createReadStream;
      fs2.createWriteStream = createWriteStream;
      var fs$readFile = fs2.readFile;
      fs2.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs2.writeFile;
      fs2.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs2.appendFile;
      if (fs$appendFile)
        fs2.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs2.copyFile;
      if (fs$copyFile)
        fs2.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs2.readdir;
      fs2.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(path2, options2, cb2, startTime));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(path2, options2, cb2, startTime));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs2);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs2.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs2.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs2, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs2, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs2, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs2, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs2.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs2.WriteStream(path, options);
      }
      var fs$open = fs2.open;
      fs2.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs2;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs[gracefulQueue].length; ++i) {
        if (fs[gracefulQueue][i].length > 2) {
          fs[gracefulQueue][i][3] = now;
          fs[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs[gracefulQueue].length === 0)
        return;
      var elem = fs[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// ../pk-lib/node_modules/fs-extra/lib/fs/index.js
var require_fs = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs[key] === "function";
    });
    Object.assign(exports, fs);
    api.forEach((method) => {
      exports[method] = u(fs[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs.realpath.native === "function") {
      exports.realpath.native = u(fs.realpath.native);
    } else {
      process.emitWarning("fs.realpath.native is not a function. Is fs being monkey-patched?", "Warning", "fs-extra-WARN0003");
    }
  }
});

// ../pk-lib/node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module2) {
    "use strict";
    var path = require("path");
    module2.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module2) {
    "use strict";
    var fs = require_fs();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults, ...options }.mode;
    };
    module2.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module2.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/mkdirs/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module2.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/path-exists/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    function pathExists(path) {
      return fs.access(path).then(() => true).catch(() => false);
    }
    module2.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs.existsSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/util/utimes.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function utimesMillis(path, atime, mtime, callback) {
      fs.open(path, "r+", (err, fd) => {
        if (err)
          return callback(err);
        fs.futimes(fd, atime, mtime, (futimesErr) => {
          fs.close(fd, (closeErr) => {
            if (callback)
              callback(futimesErr || closeErr);
          });
        });
      });
    }
    function utimesMillisSync(path, atime, mtime) {
      const fd = fs.openSync(path, "r+");
      fs.futimesSync(fd, atime, mtime);
      return fs.closeSync(fd);
    }
    module2.exports = {
      utimesMillis,
      utimesMillisSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/util/stat.js"(exports, module2) {
    "use strict";
    var fs = require_fs();
    var path = require("path");
    var util = require("util");
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs.stat(file, { bigint: true }) : (file) => fs.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs.statSync(file, { bigint: true }) : (file) => fs.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    function checkPaths(src, dest, funcName, opts, cb) {
      util.callbackify(getStats)(src, dest, opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        if (destStat) {
          if (areIdentical(srcStat, destStat)) {
            const srcBaseName = path.basename(src);
            const destBaseName = path.basename(dest);
            if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
              return cb(null, { srcStat, destStat, isChangingCase: true });
            }
            return cb(new Error("Source and destination must not be the same."));
          }
          if (srcStat.isDirectory() && !destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`));
          }
          if (!srcStat.isDirectory() && destStat.isDirectory()) {
            return cb(new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`));
          }
        }
        if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return cb(null, { srcStat, destStat });
      });
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkParentPaths(src, srcStat, dest, funcName, cb) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return cb();
      fs.stat(destParent, { bigint: true }, (err, destStat) => {
        if (err) {
          if (err.code === "ENOENT")
            return cb();
          return cb(err);
        }
        if (areIdentical(srcStat, destStat)) {
          return cb(new Error(errMsg(src, dest, funcName)));
        }
        return checkParentPaths(src, srcStat, destParent, funcName, cb);
      });
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
      const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
      return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module2.exports = {
      checkPaths,
      checkPathsSync,
      checkParentPaths,
      checkParentPathsSync,
      isSrcSubdir,
      areIdentical
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/copy/copy.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdirs = require_mkdirs().mkdirs;
    var pathExists = require_path_exists().pathExists;
    var utimesMillis = require_utimes().utimesMillis;
    var stat = require_stat();
    function copy(src, dest, opts, cb) {
      if (typeof opts === "function" && !cb) {
        cb = opts;
        opts = {};
      } else if (typeof opts === "function") {
        opts = { filter: opts };
      }
      cb = cb || function() {
      };
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0001");
      }
      stat.checkPaths(src, dest, "copy", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, destStat } = stats;
        stat.checkParentPaths(src, srcStat, dest, "copy", (err2) => {
          if (err2)
            return cb(err2);
          runFilter(src, dest, opts, (err3, include) => {
            if (err3)
              return cb(err3);
            if (!include)
              return cb();
            checkParentDir(destStat, src, dest, opts, cb);
          });
        });
      });
    }
    function checkParentDir(destStat, src, dest, opts, cb) {
      const destParent = path.dirname(dest);
      pathExists(destParent, (err, dirExists) => {
        if (err)
          return cb(err);
        if (dirExists)
          return getStats(destStat, src, dest, opts, cb);
        mkdirs(destParent, (err2) => {
          if (err2)
            return cb(err2);
          return getStats(destStat, src, dest, opts, cb);
        });
      });
    }
    function runFilter(src, dest, opts, cb) {
      if (!opts.filter)
        return cb(null, true);
      Promise.resolve(opts.filter(src, dest)).then((include) => cb(null, include), (error) => cb(error));
    }
    function getStats(destStat, src, dest, opts, cb) {
      const stat2 = opts.dereference ? fs.stat : fs.lstat;
      stat2(src, (err, srcStat) => {
        if (err)
          return cb(err);
        if (srcStat.isDirectory())
          return onDir(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
          return onFile(srcStat, destStat, src, dest, opts, cb);
        else if (srcStat.isSymbolicLink())
          return onLink(destStat, src, dest, opts, cb);
        else if (srcStat.isSocket())
          return cb(new Error(`Cannot copy a socket file: ${src}`));
        else if (srcStat.isFIFO())
          return cb(new Error(`Cannot copy a FIFO pipe: ${src}`));
        return cb(new Error(`Unknown file: ${src}`));
      });
    }
    function onFile(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts, cb);
      return mayCopyFile(srcStat, src, dest, opts, cb);
    }
    function mayCopyFile(srcStat, src, dest, opts, cb) {
      if (opts.overwrite) {
        fs.unlink(dest, (err) => {
          if (err)
            return cb(err);
          return copyFile(srcStat, src, dest, opts, cb);
        });
      } else if (opts.errorOnExist) {
        return cb(new Error(`'${dest}' already exists`));
      } else
        return cb();
    }
    function copyFile(srcStat, src, dest, opts, cb) {
      fs.copyFile(src, dest, (err) => {
        if (err)
          return cb(err);
        if (opts.preserveTimestamps)
          return handleTimestampsAndMode(srcStat.mode, src, dest, cb);
        return setDestMode(dest, srcStat.mode, cb);
      });
    }
    function handleTimestampsAndMode(srcMode, src, dest, cb) {
      if (fileIsNotWritable(srcMode)) {
        return makeFileWritable(dest, srcMode, (err) => {
          if (err)
            return cb(err);
          return setDestTimestampsAndMode(srcMode, src, dest, cb);
        });
      }
      return setDestTimestampsAndMode(srcMode, src, dest, cb);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode, cb) {
      return setDestMode(dest, srcMode | 128, cb);
    }
    function setDestTimestampsAndMode(srcMode, src, dest, cb) {
      setDestTimestamps(src, dest, (err) => {
        if (err)
          return cb(err);
        return setDestMode(dest, srcMode, cb);
      });
    }
    function setDestMode(dest, srcMode, cb) {
      return fs.chmod(dest, srcMode, cb);
    }
    function setDestTimestamps(src, dest, cb) {
      fs.stat(src, (err, updatedSrcStat) => {
        if (err)
          return cb(err);
        return utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime, cb);
      });
    }
    function onDir(srcStat, destStat, src, dest, opts, cb) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts, cb);
      return copyDir(src, dest, opts, cb);
    }
    function mkDirAndCopy(srcMode, src, dest, opts, cb) {
      fs.mkdir(dest, (err) => {
        if (err)
          return cb(err);
        copyDir(src, dest, opts, (err2) => {
          if (err2)
            return cb(err2);
          return setDestMode(dest, srcMode, cb);
        });
      });
    }
    function copyDir(src, dest, opts, cb) {
      fs.readdir(src, (err, items) => {
        if (err)
          return cb(err);
        return copyDirItems(items, src, dest, opts, cb);
      });
    }
    function copyDirItems(items, src, dest, opts, cb) {
      const item = items.pop();
      if (!item)
        return cb();
      return copyDirItem(items, item, src, dest, opts, cb);
    }
    function copyDirItem(items, item, src, dest, opts, cb) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      runFilter(srcItem, destItem, opts, (err, include) => {
        if (err)
          return cb(err);
        if (!include)
          return copyDirItems(items, src, dest, opts, cb);
        stat.checkPaths(srcItem, destItem, "copy", opts, (err2, stats) => {
          if (err2)
            return cb(err2);
          const { destStat } = stats;
          getStats(destStat, srcItem, destItem, opts, (err3) => {
            if (err3)
              return cb(err3);
            return copyDirItems(items, src, dest, opts, cb);
          });
        });
      });
    }
    function onLink(destStat, src, dest, opts, cb) {
      fs.readlink(src, (err, resolvedSrc) => {
        if (err)
          return cb(err);
        if (opts.dereference) {
          resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
        }
        if (!destStat) {
          return fs.symlink(resolvedSrc, dest, cb);
        } else {
          fs.readlink(dest, (err2, resolvedDest) => {
            if (err2) {
              if (err2.code === "EINVAL" || err2.code === "UNKNOWN")
                return fs.symlink(resolvedSrc, dest, cb);
              return cb(err2);
            }
            if (opts.dereference) {
              resolvedDest = path.resolve(process.cwd(), resolvedDest);
            }
            if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
              return cb(new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`));
            }
            if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
              return cb(new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`));
            }
            return copyLink(resolvedSrc, dest, cb);
          });
        }
      });
    }
    function copyLink(resolvedSrc, dest, cb) {
      fs.unlink(dest, (err) => {
        if (err)
          return cb(err);
        return fs.symlink(resolvedSrc, dest, cb);
      });
    }
    module2.exports = copy;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning("Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269", "Warning", "fs-extra-WARN0002");
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path.dirname(dest);
      if (!fs.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs.statSync : fs.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs.unlinkSync(dest);
      return fs.symlinkSync(resolvedSrc, dest);
    }
    module2.exports = copySync;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/copy/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/remove/index.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path, callback) {
      fs.rm(path, { recursive: true, force: true }, callback);
    }
    function removeSync(path) {
      fs.rmSync(path, { recursive: true, force: true });
    }
    module2.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/empty/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs = require_fs();
    var path = require("path");
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs.readdir(dir);
      } catch (e) {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs.readdirSync(dir);
      } catch (e) {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }
    module2.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/file.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_graceful_fs();
    var mkdir = require_mkdirs();
    function createFile(file, callback) {
      function makeFile() {
        fs.writeFile(file, "", (err) => {
          if (err)
            return callback(err);
          callback();
        });
      }
      fs.stat(file, (err, stats) => {
        if (!err && stats.isFile())
          return callback();
        const dir = path.dirname(file);
        fs.stat(dir, (err2, stats2) => {
          if (err2) {
            if (err2.code === "ENOENT") {
              return mkdir.mkdirs(dir, (err3) => {
                if (err3)
                  return callback(err3);
                makeFile();
              });
            }
            return callback(err2);
          }
          if (stats2.isDirectory())
            makeFile();
          else {
            fs.readdir(dir, (err3) => {
              if (err3)
                return callback(err3);
            });
          }
        });
      });
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs.statSync(file);
      } catch (e) {
      }
      if (stats && stats.isFile())
        return;
      const dir = path.dirname(file);
      try {
        if (!fs.statSync(dir).isDirectory()) {
          fs.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs.writeFileSync(file, "");
    }
    module2.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/link.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_graceful_fs();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createLink(srcpath, dstpath, callback) {
      function makeLink(srcpath2, dstpath2) {
        fs.link(srcpath2, dstpath2, (err) => {
          if (err)
            return callback(err);
          callback(null);
        });
      }
      fs.lstat(dstpath, (_, dstStat) => {
        fs.lstat(srcpath, (err, srcStat) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureLink");
            return callback(err);
          }
          if (dstStat && areIdentical(srcStat, dstStat))
            return callback(null);
          const dir = path.dirname(dstpath);
          pathExists(dir, (err2, dirExists) => {
            if (err2)
              return callback(err2);
            if (dirExists)
              return makeLink(srcpath, dstpath);
            mkdir.mkdirs(dir, (err3) => {
              if (err3)
                return callback(err3);
              makeLink(srcpath, dstpath);
            });
          });
        });
      });
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs.lstatSync(dstpath);
      } catch (e) {
      }
      try {
        const srcStat = fs.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path.dirname(dstpath);
      const dirExists = fs.existsSync(dir);
      if (dirExists)
        return fs.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs.linkSync(srcpath, dstpath);
    }
    module2.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module2) {
    "use strict";
    var path = require("path");
    var fs = require_graceful_fs();
    var pathExists = require_path_exists().pathExists;
    function symlinkPaths(srcpath, dstpath, callback) {
      if (path.isAbsolute(srcpath)) {
        return fs.lstat(srcpath, (err) => {
          if (err) {
            err.message = err.message.replace("lstat", "ensureSymlink");
            return callback(err);
          }
          return callback(null, {
            toCwd: srcpath,
            toDst: srcpath
          });
        });
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        return pathExists(relativeToDst, (err, exists) => {
          if (err)
            return callback(err);
          if (exists) {
            return callback(null, {
              toCwd: relativeToDst,
              toDst: srcpath
            });
          } else {
            return fs.lstat(srcpath, (err2) => {
              if (err2) {
                err2.message = err2.message.replace("lstat", "ensureSymlink");
                return callback(err2);
              }
              return callback(null, {
                toCwd: srcpath,
                toDst: path.relative(dstdir, srcpath)
              });
            });
          }
        });
      }
    }
    function symlinkPathsSync(srcpath, dstpath) {
      let exists;
      if (path.isAbsolute(srcpath)) {
        exists = fs.existsSync(srcpath);
        if (!exists)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      } else {
        const dstdir = path.dirname(dstpath);
        const relativeToDst = path.join(dstdir, srcpath);
        exists = fs.existsSync(relativeToDst);
        if (exists) {
          return {
            toCwd: relativeToDst,
            toDst: srcpath
          };
        } else {
          exists = fs.existsSync(srcpath);
          if (!exists)
            throw new Error("relative srcpath does not exist");
          return {
            toCwd: srcpath,
            toDst: path.relative(dstdir, srcpath)
          };
        }
      }
    }
    module2.exports = {
      symlinkPaths,
      symlinkPathsSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    function symlinkType(srcpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      if (type)
        return callback(null, type);
      fs.lstat(srcpath, (err, stats) => {
        if (err)
          return callback(null, "file");
        type = stats && stats.isDirectory() ? "dir" : "file";
        callback(null, type);
      });
    }
    function symlinkTypeSync(srcpath, type) {
      let stats;
      if (type)
        return type;
      try {
        stats = fs.lstatSync(srcpath);
      } catch (e) {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module2.exports = {
      symlinkType,
      symlinkTypeSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/symlink.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var path = require("path");
    var fs = require_fs();
    var _mkdirs = require_mkdirs();
    var mkdirs = _mkdirs.mkdirs;
    var mkdirsSync = _mkdirs.mkdirsSync;
    var _symlinkPaths = require_symlink_paths();
    var symlinkPaths = _symlinkPaths.symlinkPaths;
    var symlinkPathsSync = _symlinkPaths.symlinkPathsSync;
    var _symlinkType = require_symlink_type();
    var symlinkType = _symlinkType.symlinkType;
    var symlinkTypeSync = _symlinkType.symlinkTypeSync;
    var pathExists = require_path_exists().pathExists;
    var { areIdentical } = require_stat();
    function createSymlink(srcpath, dstpath, type, callback) {
      callback = typeof type === "function" ? type : callback;
      type = typeof type === "function" ? false : type;
      fs.lstat(dstpath, (err, stats) => {
        if (!err && stats.isSymbolicLink()) {
          Promise.all([
            fs.stat(srcpath),
            fs.stat(dstpath)
          ]).then(([srcStat, dstStat]) => {
            if (areIdentical(srcStat, dstStat))
              return callback(null);
            _createSymlink(srcpath, dstpath, type, callback);
          });
        } else
          _createSymlink(srcpath, dstpath, type, callback);
      });
    }
    function _createSymlink(srcpath, dstpath, type, callback) {
      symlinkPaths(srcpath, dstpath, (err, relative) => {
        if (err)
          return callback(err);
        srcpath = relative.toDst;
        symlinkType(relative.toCwd, type, (err2, type2) => {
          if (err2)
            return callback(err2);
          const dir = path.dirname(dstpath);
          pathExists(dir, (err3, dirExists) => {
            if (err3)
              return callback(err3);
            if (dirExists)
              return fs.symlink(srcpath, dstpath, type2, callback);
            mkdirs(dir, (err4) => {
              if (err4)
                return callback(err4);
              fs.symlink(srcpath, dstpath, type2, callback);
            });
          });
        });
      });
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs.lstatSync(dstpath);
      } catch (e) {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs.statSync(srcpath);
        const dstStat = fs.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs.existsSync(dir);
      if (exists)
        return fs.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs.symlinkSync(srcpath, dstpath, type);
    }
    module2.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/ensure/index.js"(exports, module2) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module2.exports = {
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// ../pk-lib/node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "../pk-lib/node_modules/jsonfile/utils.js"(exports, module2) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module2.exports = { stringify, stripBom };
  }
});

// ../pk-lib/node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "../pk-lib/node_modules/jsonfile/index.js"(exports, module2) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require("fs");
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs = options.fs || _fs;
      const str = stringify(obj, options);
      return fs.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module2.exports = jsonfile;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/json/jsonfile.js"(exports, module2) {
    "use strict";
    var jsonFile = require_jsonfile();
    module2.exports = {
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/output-file/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs = require_graceful_fs();
    var path = require("path");
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    function outputFile(file, data, encoding, callback) {
      if (typeof encoding === "function") {
        callback = encoding;
        encoding = "utf8";
      }
      const dir = path.dirname(file);
      pathExists(dir, (err, itDoes) => {
        if (err)
          return callback(err);
        if (itDoes)
          return fs.writeFile(file, data, encoding, callback);
        mkdir.mkdirs(dir, (err2) => {
          if (err2)
            return callback(err2);
          fs.writeFile(file, data, encoding, callback);
        });
      });
    }
    function outputFileSync(file, ...args) {
      const dir = path.dirname(file);
      if (fs.existsSync(dir)) {
        return fs.writeFileSync(file, ...args);
      }
      mkdir.mkdirsSync(dir);
      fs.writeFileSync(file, ...args);
    }
    module2.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/json/output-json.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module2.exports = outputJson;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module2) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module2.exports = outputJsonSync;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/json/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module2.exports = jsonFile;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/move/move.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var copy = require_copy2().copy;
    var remove = require_remove().remove;
    var mkdirp = require_mkdirs().mkdirp;
    var pathExists = require_path_exists().pathExists;
    var stat = require_stat();
    function move(src, dest, opts, cb) {
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      stat.checkPaths(src, dest, "move", opts, (err, stats) => {
        if (err)
          return cb(err);
        const { srcStat, isChangingCase = false } = stats;
        stat.checkParentPaths(src, srcStat, dest, "move", (err2) => {
          if (err2)
            return cb(err2);
          if (isParentRoot(dest))
            return doRename(src, dest, overwrite, isChangingCase, cb);
          mkdirp(path.dirname(dest), (err3) => {
            if (err3)
              return cb(err3);
            return doRename(src, dest, overwrite, isChangingCase, cb);
          });
        });
      });
    }
    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase, cb) {
      if (isChangingCase)
        return rename(src, dest, overwrite, cb);
      if (overwrite) {
        return remove(dest, (err) => {
          if (err)
            return cb(err);
          return rename(src, dest, overwrite, cb);
        });
      }
      pathExists(dest, (err, destExists) => {
        if (err)
          return cb(err);
        if (destExists)
          return cb(new Error("dest already exists."));
        return rename(src, dest, overwrite, cb);
      });
    }
    function rename(src, dest, overwrite, cb) {
      fs.rename(src, dest, (err) => {
        if (!err)
          return cb();
        if (err.code !== "EXDEV")
          return cb(err);
        return moveAcrossDevice(src, dest, overwrite, cb);
      });
    }
    function moveAcrossDevice(src, dest, overwrite, cb) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copy(src, dest, opts, (err) => {
        if (err)
          return cb(err);
        return remove(src, cb);
      });
    }
    module2.exports = move;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/move/move-sync.js"(exports, module2) {
    "use strict";
    var fs = require_graceful_fs();
    var path = require("path");
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module2.exports = moveSync;
  }
});

// ../pk-lib/node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/move/index.js"(exports, module2) {
    "use strict";
    var u = require_universalify().fromCallback;
    module2.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// ../pk-lib/node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "../pk-lib/node_modules/fs-extra/lib/index.js"(exports, module2) {
    "use strict";
    module2.exports = {
      ...require_fs(),
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// ../pk-lib/node_modules/filesize/dist/filesize.cjs
var require_filesize = __commonJS({
  "../pk-lib/node_modules/filesize/dist/filesize.cjs"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ARRAY = "array";
    var BIT = "bit";
    var BITS = "bits";
    var BYTE = "byte";
    var BYTES = "bytes";
    var EMPTY = "";
    var EXPONENT = "exponent";
    var FUNCTION = "function";
    var IEC = "iec";
    var INVALID_NUMBER = "Invalid number";
    var INVALID_ROUND = "Invalid rounding method";
    var JEDEC = "jedec";
    var OBJECT = "object";
    var PERIOD = ".";
    var ROUND = "round";
    var S = "s";
    var SI_KBIT = "kbit";
    var SI_KBYTE = "kB";
    var SPACE = " ";
    var STRING = "string";
    var ZERO = "0";
    var STRINGS = {
      symbol: {
        iec: {
          bits: ["bit", "Kibit", "Mibit", "Gibit", "Tibit", "Pibit", "Eibit", "Zibit", "Yibit"],
          bytes: ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"]
        },
        jedec: {
          bits: ["bit", "Kbit", "Mbit", "Gbit", "Tbit", "Pbit", "Ebit", "Zbit", "Ybit"],
          bytes: ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
        }
      },
      fullform: {
        iec: ["", "kibi", "mebi", "gibi", "tebi", "pebi", "exbi", "zebi", "yobi"],
        jedec: ["", "kilo", "mega", "giga", "tera", "peta", "exa", "zetta", "yotta"]
      }
    };
    function filesize(arg, {
      bits = false,
      pad = false,
      base = -1,
      round = 2,
      locale = EMPTY,
      localeOptions = {},
      separator = EMPTY,
      spacer = SPACE,
      symbols = {},
      standard = EMPTY,
      output = STRING,
      fullform = false,
      fullforms = [],
      exponent = -1,
      roundingMethod = ROUND,
      precision = 0
    } = {}) {
      let e = exponent, num = Number(arg), result = [], val = 0, u = EMPTY;
      if (base === -1 && standard.length === 0) {
        base = 10;
        standard = JEDEC;
      } else if (base === -1 && standard.length > 0) {
        standard = standard === IEC ? IEC : JEDEC;
        base = standard === IEC ? 2 : 10;
      } else {
        base = base === 2 ? 2 : 10;
        standard = base === 10 ? JEDEC : standard === JEDEC ? JEDEC : IEC;
      }
      const ceil = base === 10 ? 1e3 : 1024, full = fullform === true, neg = num < 0, roundingFunc = Math[roundingMethod];
      if (typeof arg !== "bigint" && isNaN(arg)) {
        throw new TypeError(INVALID_NUMBER);
      }
      if (typeof roundingFunc !== FUNCTION) {
        throw new TypeError(INVALID_ROUND);
      }
      if (neg) {
        num = -num;
      }
      if (e === -1 || isNaN(e)) {
        e = Math.floor(Math.log(num) / Math.log(ceil));
        if (e < 0) {
          e = 0;
        }
      }
      if (e > 8) {
        if (precision > 0) {
          precision += 8 - e;
        }
        e = 8;
      }
      if (output === EXPONENT) {
        return e;
      }
      if (num === 0) {
        result[0] = 0;
        u = result[1] = STRINGS.symbol[standard][bits ? BITS : BYTES][e];
      } else {
        val = num / (base === 2 ? Math.pow(2, e * 10) : Math.pow(1e3, e));
        if (bits) {
          val = val * 8;
          if (val >= ceil && e < 8) {
            val = val / ceil;
            e++;
          }
        }
        const p = Math.pow(10, e > 0 ? round : 0);
        result[0] = roundingFunc(val * p) / p;
        if (result[0] === ceil && e < 8 && exponent === -1) {
          result[0] = 1;
          e++;
        }
        u = result[1] = base === 10 && e === 1 ? bits ? SI_KBIT : SI_KBYTE : STRINGS.symbol[standard][bits ? BITS : BYTES][e];
      }
      if (neg) {
        result[0] = -result[0];
      }
      if (precision > 0) {
        result[0] = result[0].toPrecision(precision);
      }
      result[1] = symbols[result[1]] || result[1];
      if (locale === true) {
        result[0] = result[0].toLocaleString();
      } else if (locale.length > 0) {
        result[0] = result[0].toLocaleString(locale, localeOptions);
      } else if (separator.length > 0) {
        result[0] = result[0].toString().replace(PERIOD, separator);
      }
      if (pad && Number.isInteger(result[0]) === false && round > 0) {
        const x = separator || PERIOD, tmp = result[0].toString().split(x), s = tmp[1] || EMPTY, l = s.length, n = round - l;
        result[0] = `${tmp[0]}${x}${s.padEnd(l + n, ZERO)}`;
      }
      if (full) {
        result[1] = fullforms[e] ? fullforms[e] : STRINGS.fullform[standard][e] + (bits ? BIT : BYTE) + (result[0] === 1 ? EMPTY : S);
      }
      return output === ARRAY ? result : output === OBJECT ? {
        value: result[0],
        symbol: result[1],
        exponent: e,
        unit: u
      } : result.join(spacer);
    }
    function partial({
      bits = false,
      pad = false,
      base = -1,
      round = 2,
      locale = EMPTY,
      localeOptions = {},
      separator = EMPTY,
      spacer = SPACE,
      symbols = {},
      standard = EMPTY,
      output = STRING,
      fullform = false,
      fullforms = [],
      exponent = -1,
      roundingMethod = ROUND,
      precision = 0
    } = {}) {
      return (arg) => filesize(arg, {
        bits,
        pad,
        base,
        round,
        locale,
        localeOptions,
        separator,
        spacer,
        symbols,
        standard,
        output,
        fullform,
        fullforms,
        exponent,
        roundingMethod,
        precision
      });
    }
    exports.filesize = filesize;
    exports.partial = partial;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/common.js"(exports, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence))
        return sequence;
      else if (isNothing(sequence))
        return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/exception.js"(exports, module2) {
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/mark.js"(exports, module2) {
    "use strict";
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer)
        return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types
      });
    };
    module2.exports = Schema;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null)
        return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null)
        return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null)
        return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max)
        return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max)
          return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (ch !== "0" && ch !== "1")
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_")
              continue;
            if (!isHexCode(data.charCodeAt(index)))
              return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isOctCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_")
        return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch === ":")
          break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_")
        return false;
      if (ch !== ":")
        return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-")
          sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0")
        return 0;
      if (ch === "0") {
        if (value[1] === "b")
          return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x")
          return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
    function resolveYamlFloat(data) {
      if (data === null)
        return false;
      if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json2 = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json2()
      ]
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
    var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
    function resolveYamlTimestamp(data) {
      if (data === null)
        return false;
      if (YAML_DATE_REGEXP.exec(data) !== null)
        return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
        return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null)
        match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null)
        throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-")
          delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta)
        date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require = require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null)
        return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64)
          continue;
        if (code < 0)
          return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null)
        return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]")
          return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey)
              pairHasKey = true;
            else
              return false;
          }
        }
        if (!pairHasKey)
          return false;
        if (objectKeys.indexOf(pairKey) === -1)
          objectKeys.push(pairKey);
        else
          return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null)
        return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]")
          return false;
        keys = Object.keys(pair);
        if (keys.length !== 1)
          return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null)
        return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null)
        return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null)
            return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null)
        return false;
      if (data.length === 0)
        return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        if (modifiers.length > 3)
          return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/")
          return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail)
          modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global)
        result += "g";
      if (object.multiline)
        result += "m";
      if (object.ignoreCase)
        result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports, module2) {
    "use strict";
    var esprima;
    try {
      _require = require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined")
        esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null)
        return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/loader.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33)
        return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38)
        return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42)
        return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch))
            break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0)
          readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options) {
      if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    function safeLoad(input, options) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null)
        return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n")
          result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ")
        return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0)
            _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (index !== 0)
          pairBuffer += ", ";
        if (state.condenseFlow)
          pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024)
          pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid)
            return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs)
        getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true))
        return state.dump + "\n";
      return "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// ../pk-lib/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "../pk-lib/node_modules/js-yaml/lib/js-yaml.js"(exports, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json2();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// ../pk-lib/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "../pk-lib/node_modules/js-yaml/index.js"(exports, module2) {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  }
});

// ../pk-lib/node_modules/front-matter/index.js
var require_front_matter = __commonJS({
  "../pk-lib/node_modules/front-matter/index.js"(exports, module2) {
    var parser = require_js_yaml2();
    var optionalByteOrderMark = "\\ufeff?";
    var platform = typeof process !== "undefined" ? process.platform : "";
    var pattern = "^(" + optionalByteOrderMark + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (platform === "win32" ? "\\r?" : "") + "(?:\\n)?)";
    var regex = new RegExp(pattern, "m");
    module2.exports = extractor;
    module2.exports.test = test;
    function extractor(string, options) {
      string = string || "";
      var defaultOptions = { allowUnsafe: false };
      options = options instanceof Object ? { ...defaultOptions, ...options } : defaultOptions;
      options.allowUnsafe = Boolean(options.allowUnsafe);
      var lines = string.split(/(\r?\n)/);
      if (lines[0] && /= yaml =|---/.test(lines[0])) {
        return parse(string, options.allowUnsafe);
      } else {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
    }
    function computeLocation(match, body) {
      var line = 1;
      var pos = body.indexOf("\n");
      var offset = match.index + match[0].length;
      while (pos !== -1) {
        if (pos >= offset) {
          return line;
        }
        line++;
        pos = body.indexOf("\n", pos + 1);
      }
      return line;
    }
    function parse(string, allowUnsafe) {
      var match = regex.exec(string);
      if (!match) {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
      var loader = allowUnsafe ? parser.load : parser.safeLoad;
      var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, "");
      var attributes = loader(yaml) || {};
      var body = string.replace(match[0], "");
      var line = computeLocation(match, string);
      return {
        attributes,
        body,
        bodyBegin: line,
        frontmatter: yaml
      };
    }
    function test(string) {
      string = string || "";
      return regex.test(string);
    }
  }
});

// ../pk-lib/node_modules/jquery/dist/jquery.js
var require_jquery = __commonJS({
  "../pk-lib/node_modules/jquery/dist/jquery.js"(exports, module2) {
    (function(global2, factory) {
      "use strict";
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        module2.exports = global2.document ? factory(global2, true) : function(w) {
          if (!w.document) {
            throw new Error("jQuery requires a window with a document");
          }
          return factory(w);
        };
      } else {
        factory(global2);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, noGlobal) {
      "use strict";
      var arr = [];
      var getProto = Object.getPrototypeOf;
      var slice = arr.slice;
      var flat = arr.flat ? function(array) {
        return arr.flat.call(array);
      } : function(array) {
        return arr.concat.apply([], array);
      };
      var push = arr.push;
      var indexOf = arr.indexOf;
      var class2type = {};
      var toString = class2type.toString;
      var hasOwn = class2type.hasOwnProperty;
      var fnToString = hasOwn.toString;
      var ObjectFunctionString = fnToString.call(Object);
      var support = {};
      var isFunction = function isFunction2(obj) {
        return typeof obj === "function" && typeof obj.nodeType !== "number" && typeof obj.item !== "function";
      };
      var isWindow = function isWindow2(obj) {
        return obj != null && obj === obj.window;
      };
      var document2 = window2.document;
      var preservedScriptAttributes = {
        type: true,
        src: true,
        nonce: true,
        noModule: true
      };
      function DOMEval(code, node, doc) {
        doc = doc || document2;
        var i, val, script = doc.createElement("script");
        script.text = code;
        if (node) {
          for (i in preservedScriptAttributes) {
            val = node[i] || node.getAttribute && node.getAttribute(i);
            if (val) {
              script.setAttribute(i, val);
            }
          }
        }
        doc.head.appendChild(script).parentNode.removeChild(script);
      }
      function toType(obj) {
        if (obj == null) {
          return obj + "";
        }
        return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
      }
      var version = "3.6.3", jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      };
      jQuery.fn = jQuery.prototype = {
        jquery: version,
        constructor: jQuery,
        length: 0,
        toArray: function() {
          return slice.call(this);
        },
        get: function(num) {
          if (num == null) {
            return slice.call(this);
          }
          return num < 0 ? this[num + this.length] : this[num];
        },
        pushStack: function(elems) {
          var ret = jQuery.merge(this.constructor(), elems);
          ret.prevObject = this;
          return ret;
        },
        each: function(callback) {
          return jQuery.each(this, callback);
        },
        map: function(callback) {
          return this.pushStack(jQuery.map(this, function(elem, i) {
            return callback.call(elem, i, elem);
          }));
        },
        slice: function() {
          return this.pushStack(slice.apply(this, arguments));
        },
        first: function() {
          return this.eq(0);
        },
        last: function() {
          return this.eq(-1);
        },
        even: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i) {
            return (i + 1) % 2;
          }));
        },
        odd: function() {
          return this.pushStack(jQuery.grep(this, function(_elem, i) {
            return i % 2;
          }));
        },
        eq: function(i) {
          var len = this.length, j = +i + (i < 0 ? len : 0);
          return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },
        end: function() {
          return this.prevObject || this.constructor();
        },
        push,
        sort: arr.sort,
        splice: arr.splice
      };
      jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
        if (typeof target === "boolean") {
          deep = target;
          target = arguments[i] || {};
          i++;
        }
        if (typeof target !== "object" && !isFunction(target)) {
          target = {};
        }
        if (i === length) {
          target = this;
          i--;
        }
        for (; i < length; i++) {
          if ((options = arguments[i]) != null) {
            for (name in options) {
              copy = options[name];
              if (name === "__proto__" || target === copy) {
                continue;
              }
              if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
                src = target[name];
                if (copyIsArray && !Array.isArray(src)) {
                  clone = [];
                } else if (!copyIsArray && !jQuery.isPlainObject(src)) {
                  clone = {};
                } else {
                  clone = src;
                }
                copyIsArray = false;
                target[name] = jQuery.extend(deep, clone, copy);
              } else if (copy !== void 0) {
                target[name] = copy;
              }
            }
          }
        }
        return target;
      };
      jQuery.extend({
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
        isReady: true,
        error: function(msg) {
          throw new Error(msg);
        },
        noop: function() {
        },
        isPlainObject: function(obj) {
          var proto, Ctor;
          if (!obj || toString.call(obj) !== "[object Object]") {
            return false;
          }
          proto = getProto(obj);
          if (!proto) {
            return true;
          }
          Ctor = hasOwn.call(proto, "constructor") && proto.constructor;
          return typeof Ctor === "function" && fnToString.call(Ctor) === ObjectFunctionString;
        },
        isEmptyObject: function(obj) {
          var name;
          for (name in obj) {
            return false;
          }
          return true;
        },
        globalEval: function(code, options, doc) {
          DOMEval(code, { nonce: options && options.nonce }, doc);
        },
        each: function(obj, callback) {
          var length, i = 0;
          if (isArrayLike(obj)) {
            length = obj.length;
            for (; i < length; i++) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          } else {
            for (i in obj) {
              if (callback.call(obj[i], i, obj[i]) === false) {
                break;
              }
            }
          }
          return obj;
        },
        makeArray: function(arr2, results) {
          var ret = results || [];
          if (arr2 != null) {
            if (isArrayLike(Object(arr2))) {
              jQuery.merge(ret, typeof arr2 === "string" ? [arr2] : arr2);
            } else {
              push.call(ret, arr2);
            }
          }
          return ret;
        },
        inArray: function(elem, arr2, i) {
          return arr2 == null ? -1 : indexOf.call(arr2, elem, i);
        },
        merge: function(first, second) {
          var len = +second.length, j = 0, i = first.length;
          for (; j < len; j++) {
            first[i++] = second[j];
          }
          first.length = i;
          return first;
        },
        grep: function(elems, callback, invert) {
          var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
          for (; i < length; i++) {
            callbackInverse = !callback(elems[i], i);
            if (callbackInverse !== callbackExpect) {
              matches.push(elems[i]);
            }
          }
          return matches;
        },
        map: function(elems, callback, arg) {
          var length, value, i = 0, ret = [];
          if (isArrayLike(elems)) {
            length = elems.length;
            for (; i < length; i++) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          } else {
            for (i in elems) {
              value = callback(elems[i], i, arg);
              if (value != null) {
                ret.push(value);
              }
            }
          }
          return flat(ret);
        },
        guid: 1,
        support
      });
      if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
      }
      jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(_i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
      });
      function isArrayLike(obj) {
        var length = !!obj && "length" in obj && obj.length, type = toType(obj);
        if (isFunction(obj) || isWindow(obj)) {
          return false;
        }
        return type === "array" || length === 0 || typeof length === "number" && length > 0 && length - 1 in obj;
      }
      var Sizzle = function(window3) {
        var i, support2, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document3, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date(), preferredDoc = window3.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), nonnativeSelectorCache = createCache(), sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        }, hasOwn2 = {}.hasOwnProperty, arr2 = [], pop = arr2.pop, pushNative = arr2.push, push2 = arr2.push, slice2 = arr2.slice, indexOf2 = function(list, elem) {
          var i2 = 0, len = list.length;
          for (; i2 < len; i2++) {
            if (list[i2] === elem) {
              return i2;
            }
          }
          return -1;
        }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace2 = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+", attributes = "\\[" + whitespace2 + "*(" + identifier + ")(?:" + whitespace2 + "*([*^$|!~]?=)" + whitespace2 + `*(?:'((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)"|(` + identifier + "))|)" + whitespace2 + "*\\]", pseudos = ":(" + identifier + `)(?:\\((('((?:\\\\.|[^\\\\'])*)'|"((?:\\\\.|[^\\\\"])*)")|((?:\\\\.|[^\\\\()[\\]]|` + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace2 + "+", "g"), rtrim2 = new RegExp("^" + whitespace2 + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace2 + "+$", "g"), rcomma = new RegExp("^" + whitespace2 + "*," + whitespace2 + "*"), rcombinators = new RegExp("^" + whitespace2 + "*([>+~]|" + whitespace2 + ")" + whitespace2 + "*"), rdescend = new RegExp(whitespace2 + "|>"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace2 + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace2 + "*(?:([+-]|)" + whitespace2 + "*(\\d+)|))" + whitespace2 + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace2 + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace2 + "*((?:-\\d)?\\d*)" + whitespace2 + "*\\)|)(?=[^-]|$)", "i")
        }, rhtml2 = /HTML$/i, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr2 = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\[\\da-fA-F]{1,6}" + whitespace2 + "?|\\\\([^\\r\\n\\f])", "g"), funescape = function(escape, nonHex) {
          var high = "0x" + escape.slice(1) - 65536;
          return nonHex ? nonHex : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
        }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, fcssescape = function(ch, asCodePoint) {
          if (asCodePoint) {
            if (ch === "\0") {
              return "\uFFFD";
            }
            return ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " ";
          }
          return "\\" + ch;
        }, unloadHandler = function() {
          setDocument();
        }, inDisabledFieldset = addCombinator(function(elem) {
          return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
        }, { dir: "parentNode", next: "legend" });
        try {
          push2.apply(arr2 = slice2.call(preferredDoc.childNodes), preferredDoc.childNodes);
          arr2[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
          push2 = {
            apply: arr2.length ? function(target, els) {
              pushNative.apply(target, slice2.call(els));
            } : function(target, els) {
              var j = target.length, i2 = 0;
              while (target[j++] = els[i2++]) {
              }
              target.length = j - 1;
            }
          };
        }
        function Sizzle2(selector, context, results, seed) {
          var m, i2, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
          results = results || [];
          if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
            return results;
          }
          if (!seed) {
            setDocument(context);
            context = context || document3;
            if (documentIsHTML) {
              if (nodeType !== 11 && (match = rquickExpr2.exec(selector))) {
                if (m = match[1]) {
                  if (nodeType === 9) {
                    if (elem = context.getElementById(m)) {
                      if (elem.id === m) {
                        results.push(elem);
                        return results;
                      }
                    } else {
                      return results;
                    }
                  } else {
                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                      results.push(elem);
                      return results;
                    }
                  }
                } else if (match[2]) {
                  push2.apply(results, context.getElementsByTagName(selector));
                  return results;
                } else if ((m = match[3]) && support2.getElementsByClassName && context.getElementsByClassName) {
                  push2.apply(results, context.getElementsByClassName(m));
                  return results;
                }
              }
              if (support2.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (nodeType !== 1 || context.nodeName.toLowerCase() !== "object")) {
                newSelector = selector;
                newContext = context;
                if (nodeType === 1 && (rdescend.test(selector) || rcombinators.test(selector))) {
                  newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                  if (newContext !== context || !support2.scope) {
                    if (nid = context.getAttribute("id")) {
                      nid = nid.replace(rcssescape, fcssescape);
                    } else {
                      context.setAttribute("id", nid = expando);
                    }
                  }
                  groups = tokenize(selector);
                  i2 = groups.length;
                  while (i2--) {
                    groups[i2] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i2]);
                  }
                  newSelector = groups.join(",");
                }
                try {
                  if (support2.cssSupportsSelector && !CSS.supports("selector(:is(" + newSelector + "))")) {
                    throw new Error();
                  }
                  push2.apply(results, newContext.querySelectorAll(newSelector));
                  return results;
                } catch (qsaError) {
                  nonnativeSelectorCache(selector, true);
                } finally {
                  if (nid === expando) {
                    context.removeAttribute("id");
                  }
                }
              }
            }
          }
          return select(selector.replace(rtrim2, "$1"), context, results, seed);
        }
        function createCache() {
          var keys = [];
          function cache(key, value) {
            if (keys.push(key + " ") > Expr.cacheLength) {
              delete cache[keys.shift()];
            }
            return cache[key + " "] = value;
          }
          return cache;
        }
        function markFunction(fn) {
          fn[expando] = true;
          return fn;
        }
        function assert(fn) {
          var el = document3.createElement("fieldset");
          try {
            return !!fn(el);
          } catch (e) {
            return false;
          } finally {
            if (el.parentNode) {
              el.parentNode.removeChild(el);
            }
            el = null;
          }
        }
        function addHandle(attrs, handler) {
          var arr3 = attrs.split("|"), i2 = arr3.length;
          while (i2--) {
            Expr.attrHandle[arr3[i2]] = handler;
          }
        }
        function siblingCheck(a, b) {
          var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && a.sourceIndex - b.sourceIndex;
          if (diff) {
            return diff;
          }
          if (cur) {
            while (cur = cur.nextSibling) {
              if (cur === b) {
                return -1;
              }
            }
          }
          return a ? 1 : -1;
        }
        function createInputPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return name === "input" && elem.type === type;
          };
        }
        function createButtonPseudo(type) {
          return function(elem) {
            var name = elem.nodeName.toLowerCase();
            return (name === "input" || name === "button") && elem.type === type;
          };
        }
        function createDisabledPseudo(disabled) {
          return function(elem) {
            if ("form" in elem) {
              if (elem.parentNode && elem.disabled === false) {
                if ("label" in elem) {
                  if ("label" in elem.parentNode) {
                    return elem.parentNode.disabled === disabled;
                  } else {
                    return elem.disabled === disabled;
                  }
                }
                return elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled;
              }
              return elem.disabled === disabled;
            } else if ("label" in elem) {
              return elem.disabled === disabled;
            }
            return false;
          };
        }
        function createPositionalPseudo(fn) {
          return markFunction(function(argument) {
            argument = +argument;
            return markFunction(function(seed, matches2) {
              var j, matchIndexes = fn([], seed.length, argument), i2 = matchIndexes.length;
              while (i2--) {
                if (seed[j = matchIndexes[i2]]) {
                  seed[j] = !(matches2[j] = seed[j]);
                }
              }
            });
          });
        }
        function testContext(context) {
          return context && typeof context.getElementsByTagName !== "undefined" && context;
        }
        support2 = Sizzle2.support = {};
        isXML = Sizzle2.isXML = function(elem) {
          var namespace = elem && elem.namespaceURI, docElem2 = elem && (elem.ownerDocument || elem).documentElement;
          return !rhtml2.test(namespace || docElem2 && docElem2.nodeName || "HTML");
        };
        setDocument = Sizzle2.setDocument = function(node) {
          var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
          if (doc == document3 || doc.nodeType !== 9 || !doc.documentElement) {
            return document3;
          }
          document3 = doc;
          docElem = document3.documentElement;
          documentIsHTML = !isXML(document3);
          if (preferredDoc != document3 && (subWindow = document3.defaultView) && subWindow.top !== subWindow) {
            if (subWindow.addEventListener) {
              subWindow.addEventListener("unload", unloadHandler, false);
            } else if (subWindow.attachEvent) {
              subWindow.attachEvent("onunload", unloadHandler);
            }
          }
          support2.scope = assert(function(el) {
            docElem.appendChild(el).appendChild(document3.createElement("div"));
            return typeof el.querySelectorAll !== "undefined" && !el.querySelectorAll(":scope fieldset div").length;
          });
          support2.cssSupportsSelector = assert(function() {
            return CSS.supports("selector(*)") && document3.querySelectorAll(":is(:jqfake)") && !CSS.supports("selector(:is(*,:jqfake))");
          });
          support2.attributes = assert(function(el) {
            el.className = "i";
            return !el.getAttribute("className");
          });
          support2.getElementsByTagName = assert(function(el) {
            el.appendChild(document3.createComment(""));
            return !el.getElementsByTagName("*").length;
          });
          support2.getElementsByClassName = rnative.test(document3.getElementsByClassName);
          support2.getById = assert(function(el) {
            docElem.appendChild(el).id = expando;
            return !document3.getElementsByName || !document3.getElementsByName(expando).length;
          });
          if (support2.getById) {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                return elem.getAttribute("id") === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var elem = context.getElementById(id);
                return elem ? [elem] : [];
              }
            };
          } else {
            Expr.filter["ID"] = function(id) {
              var attrId = id.replace(runescape, funescape);
              return function(elem) {
                var node2 = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                return node2 && node2.value === attrId;
              };
            };
            Expr.find["ID"] = function(id, context) {
              if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                var node2, i2, elems, elem = context.getElementById(id);
                if (elem) {
                  node2 = elem.getAttributeNode("id");
                  if (node2 && node2.value === id) {
                    return [elem];
                  }
                  elems = context.getElementsByName(id);
                  i2 = 0;
                  while (elem = elems[i2++]) {
                    node2 = elem.getAttributeNode("id");
                    if (node2 && node2.value === id) {
                      return [elem];
                    }
                  }
                }
                return [];
              }
            };
          }
          Expr.find["TAG"] = support2.getElementsByTagName ? function(tag, context) {
            if (typeof context.getElementsByTagName !== "undefined") {
              return context.getElementsByTagName(tag);
            } else if (support2.qsa) {
              return context.querySelectorAll(tag);
            }
          } : function(tag, context) {
            var elem, tmp = [], i2 = 0, results = context.getElementsByTagName(tag);
            if (tag === "*") {
              while (elem = results[i2++]) {
                if (elem.nodeType === 1) {
                  tmp.push(elem);
                }
              }
              return tmp;
            }
            return results;
          };
          Expr.find["CLASS"] = support2.getElementsByClassName && function(className, context) {
            if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
              return context.getElementsByClassName(className);
            }
          };
          rbuggyMatches = [];
          rbuggyQSA = [];
          if (support2.qsa = rnative.test(document3.querySelectorAll)) {
            assert(function(el) {
              var input;
              docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>";
              if (el.querySelectorAll("[msallowcapture^='']").length) {
                rbuggyQSA.push("[*^$]=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll("[selected]").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*(?:value|" + booleans + ")");
              }
              if (!el.querySelectorAll("[id~=" + expando + "-]").length) {
                rbuggyQSA.push("~=");
              }
              input = document3.createElement("input");
              input.setAttribute("name", "");
              el.appendChild(input);
              if (!el.querySelectorAll("[name='']").length) {
                rbuggyQSA.push("\\[" + whitespace2 + "*name" + whitespace2 + "*=" + whitespace2 + `*(?:''|"")`);
              }
              if (!el.querySelectorAll(":checked").length) {
                rbuggyQSA.push(":checked");
              }
              if (!el.querySelectorAll("a#" + expando + "+*").length) {
                rbuggyQSA.push(".#.+[+~]");
              }
              el.querySelectorAll("\\\f");
              rbuggyQSA.push("[\\r\\n\\f]");
            });
            assert(function(el) {
              el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
              var input = document3.createElement("input");
              input.setAttribute("type", "hidden");
              el.appendChild(input).setAttribute("name", "D");
              if (el.querySelectorAll("[name=d]").length) {
                rbuggyQSA.push("name" + whitespace2 + "*[*^$|!~]?=");
              }
              if (el.querySelectorAll(":enabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              docElem.appendChild(el).disabled = true;
              if (el.querySelectorAll(":disabled").length !== 2) {
                rbuggyQSA.push(":enabled", ":disabled");
              }
              el.querySelectorAll("*,:x");
              rbuggyQSA.push(",.*:");
            });
          }
          if (support2.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
            assert(function(el) {
              support2.disconnectedMatch = matches.call(el, "*");
              matches.call(el, "[s!='']:x");
              rbuggyMatches.push("!=", pseudos);
            });
          }
          if (!support2.cssSupportsSelector) {
            rbuggyQSA.push(":has");
          }
          rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
          rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
          hasCompare = rnative.test(docElem.compareDocumentPosition);
          contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
            var adown = a.nodeType === 9 && a.documentElement || a, bup = b && b.parentNode;
            return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
          } : function(a, b) {
            if (b) {
              while (b = b.parentNode) {
                if (b === a) {
                  return true;
                }
              }
            }
            return false;
          };
          sortOrder = hasCompare ? function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
            if (compare) {
              return compare;
            }
            compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
            if (compare & 1 || !support2.sortDetached && b.compareDocumentPosition(a) === compare) {
              if (a == document3 || a.ownerDocument == preferredDoc && contains(preferredDoc, a)) {
                return -1;
              }
              if (b == document3 || b.ownerDocument == preferredDoc && contains(preferredDoc, b)) {
                return 1;
              }
              return sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
            }
            return compare & 4 ? -1 : 1;
          } : function(a, b) {
            if (a === b) {
              hasDuplicate = true;
              return 0;
            }
            var cur, i2 = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
            if (!aup || !bup) {
              return a == document3 ? -1 : b == document3 ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf2(sortInput, a) - indexOf2(sortInput, b) : 0;
            } else if (aup === bup) {
              return siblingCheck(a, b);
            }
            cur = a;
            while (cur = cur.parentNode) {
              ap.unshift(cur);
            }
            cur = b;
            while (cur = cur.parentNode) {
              bp.unshift(cur);
            }
            while (ap[i2] === bp[i2]) {
              i2++;
            }
            return i2 ? siblingCheck(ap[i2], bp[i2]) : ap[i2] == preferredDoc ? -1 : bp[i2] == preferredDoc ? 1 : 0;
          };
          return document3;
        };
        Sizzle2.matches = function(expr, elements) {
          return Sizzle2(expr, null, null, elements);
        };
        Sizzle2.matchesSelector = function(elem, expr) {
          setDocument(elem);
          if (support2.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
            try {
              var ret = matches.call(elem, expr);
              if (ret || support2.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                return ret;
              }
            } catch (e) {
              nonnativeSelectorCache(expr, true);
            }
          }
          return Sizzle2(expr, document3, null, [elem]).length > 0;
        };
        Sizzle2.contains = function(context, elem) {
          if ((context.ownerDocument || context) != document3) {
            setDocument(context);
          }
          return contains(context, elem);
        };
        Sizzle2.attr = function(elem, name) {
          if ((elem.ownerDocument || elem) != document3) {
            setDocument(elem);
          }
          var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn2.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
          return val !== void 0 ? val : support2.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        };
        Sizzle2.escape = function(sel) {
          return (sel + "").replace(rcssescape, fcssescape);
        };
        Sizzle2.error = function(msg) {
          throw new Error("Syntax error, unrecognized expression: " + msg);
        };
        Sizzle2.uniqueSort = function(results) {
          var elem, duplicates = [], j = 0, i2 = 0;
          hasDuplicate = !support2.detectDuplicates;
          sortInput = !support2.sortStable && results.slice(0);
          results.sort(sortOrder);
          if (hasDuplicate) {
            while (elem = results[i2++]) {
              if (elem === results[i2]) {
                j = duplicates.push(i2);
              }
            }
            while (j--) {
              results.splice(duplicates[j], 1);
            }
          }
          sortInput = null;
          return results;
        };
        getText = Sizzle2.getText = function(elem) {
          var node, ret = "", i2 = 0, nodeType = elem.nodeType;
          if (!nodeType) {
            while (node = elem[i2++]) {
              ret += getText(node);
            }
          } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
            if (typeof elem.textContent === "string") {
              return elem.textContent;
            } else {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                ret += getText(elem);
              }
            }
          } else if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
          return ret;
        };
        Expr = Sizzle2.selectors = {
          cacheLength: 50,
          createPseudo: markFunction,
          match: matchExpr,
          attrHandle: {},
          find: {},
          relative: {
            ">": { dir: "parentNode", first: true },
            " ": { dir: "parentNode" },
            "+": { dir: "previousSibling", first: true },
            "~": { dir: "previousSibling" }
          },
          preFilter: {
            "ATTR": function(match) {
              match[1] = match[1].replace(runescape, funescape);
              match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
              if (match[2] === "~=") {
                match[3] = " " + match[3] + " ";
              }
              return match.slice(0, 4);
            },
            "CHILD": function(match) {
              match[1] = match[1].toLowerCase();
              if (match[1].slice(0, 3) === "nth") {
                if (!match[3]) {
                  Sizzle2.error(match[0]);
                }
                match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                match[5] = +(match[7] + match[8] || match[3] === "odd");
              } else if (match[3]) {
                Sizzle2.error(match[0]);
              }
              return match;
            },
            "PSEUDO": function(match) {
              var excess, unquoted = !match[6] && match[2];
              if (matchExpr["CHILD"].test(match[0])) {
                return null;
              }
              if (match[3]) {
                match[2] = match[4] || match[5] || "";
              } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
                match[0] = match[0].slice(0, excess);
                match[2] = unquoted.slice(0, excess);
              }
              return match.slice(0, 3);
            }
          },
          filter: {
            "TAG": function(nodeNameSelector) {
              var nodeName2 = nodeNameSelector.replace(runescape, funescape).toLowerCase();
              return nodeNameSelector === "*" ? function() {
                return true;
              } : function(elem) {
                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName2;
              };
            },
            "CLASS": function(className) {
              var pattern = classCache[className + " "];
              return pattern || (pattern = new RegExp("(^|" + whitespace2 + ")" + className + "(" + whitespace2 + "|$)")) && classCache(className, function(elem) {
                return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
              });
            },
            "ATTR": function(name, operator, check) {
              return function(elem) {
                var result = Sizzle2.attr(elem, name);
                if (result == null) {
                  return operator === "!=";
                }
                if (!operator) {
                  return true;
                }
                result += "";
                return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
              };
            },
            "CHILD": function(type, what, _argument, first, last) {
              var simple = type.slice(0, 3) !== "nth", forward = type.slice(-4) !== "last", ofType = what === "of-type";
              return first === 1 && last === 0 ? function(elem) {
                return !!elem.parentNode;
              } : function(elem, _context, xml) {
                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir2 = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                if (parent) {
                  if (simple) {
                    while (dir2) {
                      node = elem;
                      while (node = node[dir2]) {
                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                          return false;
                        }
                      }
                      start = dir2 = type === "only" && !start && "nextSibling";
                    }
                    return true;
                  }
                  start = [forward ? parent.firstChild : parent.lastChild];
                  if (forward && useCache) {
                    node = parent;
                    outerCache = node[expando] || (node[expando] = {});
                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                    cache = uniqueCache[type] || [];
                    nodeIndex = cache[0] === dirruns && cache[1];
                    diff = nodeIndex && cache[2];
                    node = nodeIndex && parent.childNodes[nodeIndex];
                    while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                      if (node.nodeType === 1 && ++diff && node === elem) {
                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                        break;
                      }
                    }
                  } else {
                    if (useCache) {
                      node = elem;
                      outerCache = node[expando] || (node[expando] = {});
                      uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                      cache = uniqueCache[type] || [];
                      nodeIndex = cache[0] === dirruns && cache[1];
                      diff = nodeIndex;
                    }
                    if (diff === false) {
                      while (node = ++nodeIndex && node && node[dir2] || (diff = nodeIndex = 0) || start.pop()) {
                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                          if (useCache) {
                            outerCache = node[expando] || (node[expando] = {});
                            uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                            uniqueCache[type] = [dirruns, diff];
                          }
                          if (node === elem) {
                            break;
                          }
                        }
                      }
                    }
                  }
                  diff -= last;
                  return diff === first || diff % first === 0 && diff / first >= 0;
                }
              };
            },
            "PSEUDO": function(pseudo, argument) {
              var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle2.error("unsupported pseudo: " + pseudo);
              if (fn[expando]) {
                return fn(argument);
              }
              if (fn.length > 1) {
                args = [pseudo, pseudo, "", argument];
                return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches2) {
                  var idx, matched = fn(seed, argument), i2 = matched.length;
                  while (i2--) {
                    idx = indexOf2(seed, matched[i2]);
                    seed[idx] = !(matches2[idx] = matched[i2]);
                  }
                }) : function(elem) {
                  return fn(elem, 0, args);
                };
              }
              return fn;
            }
          },
          pseudos: {
            "not": markFunction(function(selector) {
              var input = [], results = [], matcher = compile(selector.replace(rtrim2, "$1"));
              return matcher[expando] ? markFunction(function(seed, matches2, _context, xml) {
                var elem, unmatched = matcher(seed, null, xml, []), i2 = seed.length;
                while (i2--) {
                  if (elem = unmatched[i2]) {
                    seed[i2] = !(matches2[i2] = elem);
                  }
                }
              }) : function(elem, _context, xml) {
                input[0] = elem;
                matcher(input, null, xml, results);
                input[0] = null;
                return !results.pop();
              };
            }),
            "has": markFunction(function(selector) {
              return function(elem) {
                return Sizzle2(selector, elem).length > 0;
              };
            }),
            "contains": markFunction(function(text) {
              text = text.replace(runescape, funescape);
              return function(elem) {
                return (elem.textContent || getText(elem)).indexOf(text) > -1;
              };
            }),
            "lang": markFunction(function(lang) {
              if (!ridentifier.test(lang || "")) {
                Sizzle2.error("unsupported lang: " + lang);
              }
              lang = lang.replace(runescape, funescape).toLowerCase();
              return function(elem) {
                var elemLang;
                do {
                  if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) {
                    elemLang = elemLang.toLowerCase();
                    return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                  }
                } while ((elem = elem.parentNode) && elem.nodeType === 1);
                return false;
              };
            }),
            "target": function(elem) {
              var hash = window3.location && window3.location.hash;
              return hash && hash.slice(1) === elem.id;
            },
            "root": function(elem) {
              return elem === docElem;
            },
            "focus": function(elem) {
              return elem === document3.activeElement && (!document3.hasFocus || document3.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
            },
            "enabled": createDisabledPseudo(false),
            "disabled": createDisabledPseudo(true),
            "checked": function(elem) {
              var nodeName2 = elem.nodeName.toLowerCase();
              return nodeName2 === "input" && !!elem.checked || nodeName2 === "option" && !!elem.selected;
            },
            "selected": function(elem) {
              if (elem.parentNode) {
                elem.parentNode.selectedIndex;
              }
              return elem.selected === true;
            },
            "empty": function(elem) {
              for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                if (elem.nodeType < 6) {
                  return false;
                }
              }
              return true;
            },
            "parent": function(elem) {
              return !Expr.pseudos["empty"](elem);
            },
            "header": function(elem) {
              return rheader.test(elem.nodeName);
            },
            "input": function(elem) {
              return rinputs.test(elem.nodeName);
            },
            "button": function(elem) {
              var name = elem.nodeName.toLowerCase();
              return name === "input" && elem.type === "button" || name === "button";
            },
            "text": function(elem) {
              var attr;
              return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
            },
            "first": createPositionalPseudo(function() {
              return [0];
            }),
            "last": createPositionalPseudo(function(_matchIndexes, length) {
              return [length - 1];
            }),
            "eq": createPositionalPseudo(function(_matchIndexes, length, argument) {
              return [argument < 0 ? argument + length : argument];
            }),
            "even": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 0;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "odd": createPositionalPseudo(function(matchIndexes, length) {
              var i2 = 1;
              for (; i2 < length; i2 += 2) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument > length ? length : argument;
              for (; --i2 >= 0; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            }),
            "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
              var i2 = argument < 0 ? argument + length : argument;
              for (; ++i2 < length; ) {
                matchIndexes.push(i2);
              }
              return matchIndexes;
            })
          }
        };
        Expr.pseudos["nth"] = Expr.pseudos["eq"];
        for (i in { radio: true, checkbox: true, file: true, password: true, image: true }) {
          Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in { submit: true, reset: true }) {
          Expr.pseudos[i] = createButtonPseudo(i);
        }
        function setFilters() {
        }
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();
        tokenize = Sizzle2.tokenize = function(selector, parseOnly) {
          var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
          if (cached) {
            return parseOnly ? 0 : cached.slice(0);
          }
          soFar = selector;
          groups = [];
          preFilters = Expr.preFilter;
          while (soFar) {
            if (!matched || (match = rcomma.exec(soFar))) {
              if (match) {
                soFar = soFar.slice(match[0].length) || soFar;
              }
              groups.push(tokens = []);
            }
            matched = false;
            if (match = rcombinators.exec(soFar)) {
              matched = match.shift();
              tokens.push({
                value: matched,
                type: match[0].replace(rtrim2, " ")
              });
              soFar = soFar.slice(matched.length);
            }
            for (type in Expr.filter) {
              if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                matched = match.shift();
                tokens.push({
                  value: matched,
                  type,
                  matches: match
                });
                soFar = soFar.slice(matched.length);
              }
            }
            if (!matched) {
              break;
            }
          }
          return parseOnly ? soFar.length : soFar ? Sizzle2.error(selector) : tokenCache(selector, groups).slice(0);
        };
        function toSelector(tokens) {
          var i2 = 0, len = tokens.length, selector = "";
          for (; i2 < len; i2++) {
            selector += tokens[i2].value;
          }
          return selector;
        }
        function addCombinator(matcher, combinator, base) {
          var dir2 = combinator.dir, skip = combinator.next, key = skip || dir2, checkNonElements = base && key === "parentNode", doneName = done++;
          return combinator.first ? function(elem, context, xml) {
            while (elem = elem[dir2]) {
              if (elem.nodeType === 1 || checkNonElements) {
                return matcher(elem, context, xml);
              }
            }
            return false;
          } : function(elem, context, xml) {
            var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
            if (xml) {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  if (matcher(elem, context, xml)) {
                    return true;
                  }
                }
              }
            } else {
              while (elem = elem[dir2]) {
                if (elem.nodeType === 1 || checkNonElements) {
                  outerCache = elem[expando] || (elem[expando] = {});
                  uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                  if (skip && skip === elem.nodeName.toLowerCase()) {
                    elem = elem[dir2] || elem;
                  } else if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                    return newCache[2] = oldCache[2];
                  } else {
                    uniqueCache[key] = newCache;
                    if (newCache[2] = matcher(elem, context, xml)) {
                      return true;
                    }
                  }
                }
              }
            }
            return false;
          };
        }
        function elementMatcher(matchers) {
          return matchers.length > 1 ? function(elem, context, xml) {
            var i2 = matchers.length;
            while (i2--) {
              if (!matchers[i2](elem, context, xml)) {
                return false;
              }
            }
            return true;
          } : matchers[0];
        }
        function multipleContexts(selector, contexts, results) {
          var i2 = 0, len = contexts.length;
          for (; i2 < len; i2++) {
            Sizzle2(selector, contexts[i2], results);
          }
          return results;
        }
        function condense(unmatched, map, filter, context, xml) {
          var elem, newUnmatched = [], i2 = 0, len = unmatched.length, mapped = map != null;
          for (; i2 < len; i2++) {
            if (elem = unmatched[i2]) {
              if (!filter || filter(elem, context, xml)) {
                newUnmatched.push(elem);
                if (mapped) {
                  map.push(i2);
                }
              }
            }
          }
          return newUnmatched;
        }
        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
          if (postFilter && !postFilter[expando]) {
            postFilter = setMatcher(postFilter);
          }
          if (postFinder && !postFinder[expando]) {
            postFinder = setMatcher(postFinder, postSelector);
          }
          return markFunction(function(seed, results, context, xml) {
            var temp, i2, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
            if (matcher) {
              matcher(matcherIn, matcherOut, context, xml);
            }
            if (postFilter) {
              temp = condense(matcherOut, postMap);
              postFilter(temp, [], context, xml);
              i2 = temp.length;
              while (i2--) {
                if (elem = temp[i2]) {
                  matcherOut[postMap[i2]] = !(matcherIn[postMap[i2]] = elem);
                }
              }
            }
            if (seed) {
              if (postFinder || preFilter) {
                if (postFinder) {
                  temp = [];
                  i2 = matcherOut.length;
                  while (i2--) {
                    if (elem = matcherOut[i2]) {
                      temp.push(matcherIn[i2] = elem);
                    }
                  }
                  postFinder(null, matcherOut = [], temp, xml);
                }
                i2 = matcherOut.length;
                while (i2--) {
                  if ((elem = matcherOut[i2]) && (temp = postFinder ? indexOf2(seed, elem) : preMap[i2]) > -1) {
                    seed[temp] = !(results[temp] = elem);
                  }
                }
              }
            } else {
              matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
              if (postFinder) {
                postFinder(null, results, matcherOut, xml);
              } else {
                push2.apply(results, matcherOut);
              }
            }
          });
        }
        function matcherFromTokens(tokens) {
          var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i2 = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
            return indexOf2(checkContext, elem) > -1;
          }, implicitRelative, true), matchers = [function(elem, context, xml) {
            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
          for (; i2 < len; i2++) {
            if (matcher = Expr.relative[tokens[i2].type]) {
              matchers = [addCombinator(elementMatcher(matchers), matcher)];
            } else {
              matcher = Expr.filter[tokens[i2].type].apply(null, tokens[i2].matches);
              if (matcher[expando]) {
                j = ++i2;
                for (; j < len; j++) {
                  if (Expr.relative[tokens[j].type]) {
                    break;
                  }
                }
                return setMatcher(i2 > 1 && elementMatcher(matchers), i2 > 1 && toSelector(tokens.slice(0, i2 - 1).concat({ value: tokens[i2 - 2].type === " " ? "*" : "" })).replace(rtrim2, "$1"), matcher, i2 < j && matcherFromTokens(tokens.slice(i2, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
              }
              matchers.push(matcher);
            }
          }
          return elementMatcher(matchers);
        }
        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
          var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
            var elem, j, matcher, matchedCount = 0, i2 = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find["TAG"]("*", outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
            if (outermost) {
              outermostContext = context == document3 || context || outermost;
            }
            for (; i2 !== len && (elem = elems[i2]) != null; i2++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument != document3) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while (matcher = elementMatchers[j++]) {
                  if (matcher(elem, context || document3, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if (elem = !matcher && elem) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i2;
            if (bySet && i2 !== matchedCount) {
              j = 0;
              while (matcher = setMatchers[j++]) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i2--) {
                    if (!(unmatched[i2] || setMatched[i2])) {
                      setMatched[i2] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push2.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                Sizzle2.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
          return bySet ? markFunction(superMatcher) : superMatcher;
        }
        compile = Sizzle2.compile = function(selector, match) {
          var i2, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
          if (!cached) {
            if (!match) {
              match = tokenize(selector);
            }
            i2 = match.length;
            while (i2--) {
              cached = matcherFromTokens(match[i2]);
              if (cached[expando]) {
                setMatchers.push(cached);
              } else {
                elementMatchers.push(cached);
              }
            }
            cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
            cached.selector = selector;
          }
          return cached;
        };
        select = Sizzle2.select = function(selector, context, results, seed) {
          var i2, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize(selector = compiled.selector || selector);
          results = results || [];
          if (match.length === 1) {
            tokens = match[0] = match[0].slice(0);
            if (tokens.length > 2 && (token = tokens[0]).type === "ID" && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
              context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
              if (!context) {
                return results;
              } else if (compiled) {
                context = context.parentNode;
              }
              selector = selector.slice(tokens.shift().value.length);
            }
            i2 = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
            while (i2--) {
              token = tokens[i2];
              if (Expr.relative[type = token.type]) {
                break;
              }
              if (find = Expr.find[type]) {
                if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                  tokens.splice(i2, 1);
                  selector = seed.length && toSelector(tokens);
                  if (!selector) {
                    push2.apply(results, seed);
                    return results;
                  }
                  break;
                }
              }
            }
          }
          (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
          return results;
        };
        support2.sortStable = expando.split("").sort(sortOrder).join("") === expando;
        support2.detectDuplicates = !!hasDuplicate;
        setDocument();
        support2.sortDetached = assert(function(el) {
          return el.compareDocumentPosition(document3.createElement("fieldset")) & 1;
        });
        if (!assert(function(el) {
          el.innerHTML = "<a href='#'></a>";
          return el.firstChild.getAttribute("href") === "#";
        })) {
          addHandle("type|href|height|width", function(elem, name, isXML2) {
            if (!isXML2) {
              return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
            }
          });
        }
        if (!support2.attributes || !assert(function(el) {
          el.innerHTML = "<input/>";
          el.firstChild.setAttribute("value", "");
          return el.firstChild.getAttribute("value") === "";
        })) {
          addHandle("value", function(elem, _name, isXML2) {
            if (!isXML2 && elem.nodeName.toLowerCase() === "input") {
              return elem.defaultValue;
            }
          });
        }
        if (!assert(function(el) {
          return el.getAttribute("disabled") == null;
        })) {
          addHandle(booleans, function(elem, name, isXML2) {
            var val;
            if (!isXML2) {
              return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            }
          });
        }
        return Sizzle2;
      }(window2);
      jQuery.find = Sizzle;
      jQuery.expr = Sizzle.selectors;
      jQuery.expr[":"] = jQuery.expr.pseudos;
      jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
      jQuery.text = Sizzle.getText;
      jQuery.isXMLDoc = Sizzle.isXML;
      jQuery.contains = Sizzle.contains;
      jQuery.escapeSelector = Sizzle.escape;
      var dir = function(elem, dir2, until) {
        var matched = [], truncate = until !== void 0;
        while ((elem = elem[dir2]) && elem.nodeType !== 9) {
          if (elem.nodeType === 1) {
            if (truncate && jQuery(elem).is(until)) {
              break;
            }
            matched.push(elem);
          }
        }
        return matched;
      };
      var siblings = function(n, elem) {
        var matched = [];
        for (; n; n = n.nextSibling) {
          if (n.nodeType === 1 && n !== elem) {
            matched.push(n);
          }
        }
        return matched;
      };
      var rneedsContext = jQuery.expr.match.needsContext;
      function nodeName(elem, name) {
        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
      }
      var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
      function winnow(elements, qualifier, not) {
        if (isFunction(qualifier)) {
          return jQuery.grep(elements, function(elem, i) {
            return !!qualifier.call(elem, i, elem) !== not;
          });
        }
        if (qualifier.nodeType) {
          return jQuery.grep(elements, function(elem) {
            return elem === qualifier !== not;
          });
        }
        if (typeof qualifier !== "string") {
          return jQuery.grep(elements, function(elem) {
            return indexOf.call(qualifier, elem) > -1 !== not;
          });
        }
        return jQuery.filter(qualifier, elements, not);
      }
      jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];
        if (not) {
          expr = ":not(" + expr + ")";
        }
        if (elems.length === 1 && elem.nodeType === 1) {
          return jQuery.find.matchesSelector(elem, expr) ? [elem] : [];
        }
        return jQuery.find.matches(expr, jQuery.grep(elems, function(elem2) {
          return elem2.nodeType === 1;
        }));
      };
      jQuery.fn.extend({
        find: function(selector) {
          var i, ret, len = this.length, self2 = this;
          if (typeof selector !== "string") {
            return this.pushStack(jQuery(selector).filter(function() {
              for (i = 0; i < len; i++) {
                if (jQuery.contains(self2[i], this)) {
                  return true;
                }
              }
            }));
          }
          ret = this.pushStack([]);
          for (i = 0; i < len; i++) {
            jQuery.find(selector, self2[i], ret);
          }
          return len > 1 ? jQuery.uniqueSort(ret) : ret;
        },
        filter: function(selector) {
          return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
          return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
          return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
      });
      var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document2, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document2.getElementById(match[2]);
              if (elem) {
                this[0] = elem;
                this.length = 1;
              }
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this[0] = selector;
          this.length = 1;
          return this;
        } else if (isFunction(selector)) {
          return root.ready !== void 0 ? root.ready(selector) : selector(jQuery);
        }
        return jQuery.makeArray(selector, this);
      };
      init.prototype = jQuery.fn;
      rootjQuery = jQuery(document2);
      var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
      jQuery.fn.extend({
        has: function(target) {
          var targets = jQuery(target, this), l = targets.length;
          return this.filter(function() {
            var i = 0;
            for (; i < l; i++) {
              if (jQuery.contains(this, targets[i])) {
                return true;
              }
            }
          });
        },
        closest: function(selectors, context) {
          var cur, i = 0, l = this.length, matched = [], targets = typeof selectors !== "string" && jQuery(selectors);
          if (!rneedsContext.test(selectors)) {
            for (; i < l; i++) {
              for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                  matched.push(cur);
                  break;
                }
              }
            }
          }
          return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },
        index: function(elem) {
          if (!elem) {
            return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
          }
          if (typeof elem === "string") {
            return indexOf.call(jQuery(elem), this[0]);
          }
          return indexOf.call(this, elem.jquery ? elem[0] : elem);
        },
        add: function(selector, context) {
          return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },
        addBack: function(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
      });
      function sibling(cur, dir2) {
        while ((cur = cur[dir2]) && cur.nodeType !== 1) {
        }
        return cur;
      }
      jQuery.each({
        parent: function(elem) {
          var parent = elem.parentNode;
          return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
          return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, _i, until) {
          return dir(elem, "parentNode", until);
        },
        next: function(elem) {
          return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
          return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
          return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
          return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, _i, until) {
          return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, _i, until) {
          return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
          return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
          return siblings(elem.firstChild);
        },
        contents: function(elem) {
          if (elem.contentDocument != null && getProto(elem.contentDocument)) {
            return elem.contentDocument;
          }
          if (nodeName(elem, "template")) {
            elem = elem.content || elem;
          }
          return jQuery.merge([], elem.childNodes);
        }
      }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
          var matched = jQuery.map(this, fn, until);
          if (name.slice(-5) !== "Until") {
            selector = until;
          }
          if (selector && typeof selector === "string") {
            matched = jQuery.filter(selector, matched);
          }
          if (this.length > 1) {
            if (!guaranteedUnique[name]) {
              jQuery.uniqueSort(matched);
            }
            if (rparentsprev.test(name)) {
              matched.reverse();
            }
          }
          return this.pushStack(matched);
        };
      });
      var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
      function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnothtmlwhite) || [], function(_, flag) {
          object[flag] = true;
        });
        return object;
      }
      jQuery.Callbacks = function(options) {
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
        var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function() {
          locked = locked || options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        }, self2 = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (isFunction(arg)) {
                    if (!options.unique || !self2.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && toType(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory && !firing) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self2.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
        return self2;
      };
      function Identity(v) {
        return v;
      }
      function Thrower(ex) {
        throw ex;
      }
      function adoptValue(value, resolve, reject, noValue) {
        var method;
        try {
          if (value && isFunction(method = value.promise)) {
            method.call(value).done(resolve).fail(reject);
          } else if (value && isFunction(method = value.then)) {
            method.call(value, resolve, reject);
          } else {
            resolve.apply(void 0, [value].slice(noValue));
          }
        } catch (value2) {
          reject.apply(void 0, [value2]);
        }
      }
      jQuery.extend({
        Deferred: function(func) {
          var tuples = [
            [
              "notify",
              "progress",
              jQuery.Callbacks("memory"),
              jQuery.Callbacks("memory"),
              2
            ],
            [
              "resolve",
              "done",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              0,
              "resolved"
            ],
            [
              "reject",
              "fail",
              jQuery.Callbacks("once memory"),
              jQuery.Callbacks("once memory"),
              1,
              "rejected"
            ]
          ], state = "pending", promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            "catch": function(fn) {
              return promise.then(null, fn);
            },
            pipe: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(_i, tuple) {
                  var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            then: function(onFulfilled, onRejected, onProgress) {
              var maxDepth = 0;
              function resolve(depth, deferred2, handler, special) {
                return function() {
                  var that = this, args = arguments, mightThrow = function() {
                    var returned, then;
                    if (depth < maxDepth) {
                      return;
                    }
                    returned = handler.apply(that, args);
                    if (returned === deferred2.promise()) {
                      throw new TypeError("Thenable self-resolution");
                    }
                    then = returned && (typeof returned === "object" || typeof returned === "function") && returned.then;
                    if (isFunction(then)) {
                      if (special) {
                        then.call(returned, resolve(maxDepth, deferred2, Identity, special), resolve(maxDepth, deferred2, Thrower, special));
                      } else {
                        maxDepth++;
                        then.call(returned, resolve(maxDepth, deferred2, Identity, special), resolve(maxDepth, deferred2, Thrower, special), resolve(maxDepth, deferred2, Identity, deferred2.notifyWith));
                      }
                    } else {
                      if (handler !== Identity) {
                        that = void 0;
                        args = [returned];
                      }
                      (special || deferred2.resolveWith)(that, args);
                    }
                  }, process2 = special ? mightThrow : function() {
                    try {
                      mightThrow();
                    } catch (e) {
                      if (jQuery.Deferred.exceptionHook) {
                        jQuery.Deferred.exceptionHook(e, process2.stackTrace);
                      }
                      if (depth + 1 >= maxDepth) {
                        if (handler !== Thrower) {
                          that = void 0;
                          args = [e];
                        }
                        deferred2.rejectWith(that, args);
                      }
                    }
                  };
                  if (depth) {
                    process2();
                  } else {
                    if (jQuery.Deferred.getStackHook) {
                      process2.stackTrace = jQuery.Deferred.getStackHook();
                    }
                    window2.setTimeout(process2);
                  }
                };
              }
              return jQuery.Deferred(function(newDefer) {
                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith));
                tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity));
                tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          }, deferred = {};
          jQuery.each(tuples, function(i, tuple) {
            var list = tuple[2], stateString = tuple[5];
            promise[tuple[1]] = list.add;
            if (stateString) {
              list.add(function() {
                state = stateString;
              }, tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock);
            }
            list.add(tuple[3].fire);
            deferred[tuple[0]] = function() {
              deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments);
              return this;
            };
            deferred[tuple[0] + "With"] = list.fireWith;
          });
          promise.promise(deferred);
          if (func) {
            func.call(deferred, deferred);
          }
          return deferred;
        },
        when: function(singleValue) {
          var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), primary = jQuery.Deferred(), updateFunc = function(i2) {
            return function(value) {
              resolveContexts[i2] = this;
              resolveValues[i2] = arguments.length > 1 ? slice.call(arguments) : value;
              if (!--remaining) {
                primary.resolveWith(resolveContexts, resolveValues);
              }
            };
          };
          if (remaining <= 1) {
            adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining);
            if (primary.state() === "pending" || isFunction(resolveValues[i] && resolveValues[i].then)) {
              return primary.then();
            }
          }
          while (i--) {
            adoptValue(resolveValues[i], updateFunc(i), primary.reject);
          }
          return primary.promise();
        }
      });
      var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
      jQuery.Deferred.exceptionHook = function(error, stack) {
        if (window2.console && window2.console.warn && error && rerrorNames.test(error.name)) {
          window2.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack);
        }
      };
      jQuery.readyException = function(error) {
        window2.setTimeout(function() {
          throw error;
        });
      };
      var readyList = jQuery.Deferred();
      jQuery.fn.ready = function(fn) {
        readyList.then(fn).catch(function(error) {
          jQuery.readyException(error);
        });
        return this;
      };
      jQuery.extend({
        isReady: false,
        readyWait: 1,
        ready: function(wait) {
          if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
            return;
          }
          jQuery.isReady = true;
          if (wait !== true && --jQuery.readyWait > 0) {
            return;
          }
          readyList.resolveWith(document2, [jQuery]);
        }
      });
      jQuery.ready.then = readyList.then;
      function completed() {
        document2.removeEventListener("DOMContentLoaded", completed);
        window2.removeEventListener("load", completed);
        jQuery.ready();
      }
      if (document2.readyState === "complete" || document2.readyState !== "loading" && !document2.documentElement.doScroll) {
        window2.setTimeout(jQuery.ready);
      } else {
        document2.addEventListener("DOMContentLoaded", completed);
        window2.addEventListener("load", completed);
      }
      var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0, len = elems.length, bulk = key == null;
        if (toType(key) === "object") {
          chainable = true;
          for (i in key) {
            access(elems, fn, i, key[i], true, emptyGet, raw);
          }
        } else if (value !== void 0) {
          chainable = true;
          if (!isFunction(value)) {
            raw = true;
          }
          if (bulk) {
            if (raw) {
              fn.call(elems, value);
              fn = null;
            } else {
              bulk = fn;
              fn = function(elem, _key, value2) {
                return bulk.call(jQuery(elem), value2);
              };
            }
          }
          if (fn) {
            for (; i < len; i++) {
              fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            }
          }
        }
        if (chainable) {
          return elems;
        }
        if (bulk) {
          return fn.call(elems);
        }
        return len ? fn(elems[0], key) : emptyGet;
      };
      var rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g;
      function fcamelCase(_all, letter) {
        return letter.toUpperCase();
      }
      function camelCase(string) {
        return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
      }
      var acceptData = function(owner) {
        return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
      };
      function Data() {
        this.expando = jQuery.expando + Data.uid++;
      }
      Data.uid = 1;
      Data.prototype = {
        cache: function(owner) {
          var value = owner[this.expando];
          if (!value) {
            value = {};
            if (acceptData(owner)) {
              if (owner.nodeType) {
                owner[this.expando] = value;
              } else {
                Object.defineProperty(owner, this.expando, {
                  value,
                  configurable: true
                });
              }
            }
          }
          return value;
        },
        set: function(owner, data, value) {
          var prop, cache = this.cache(owner);
          if (typeof data === "string") {
            cache[camelCase(data)] = value;
          } else {
            for (prop in data) {
              cache[camelCase(prop)] = data[prop];
            }
          }
          return cache;
        },
        get: function(owner, key) {
          return key === void 0 ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)];
        },
        access: function(owner, key, value) {
          if (key === void 0 || key && typeof key === "string" && value === void 0) {
            return this.get(owner, key);
          }
          this.set(owner, key, value);
          return value !== void 0 ? value : key;
        },
        remove: function(owner, key) {
          var i, cache = owner[this.expando];
          if (cache === void 0) {
            return;
          }
          if (key !== void 0) {
            if (Array.isArray(key)) {
              key = key.map(camelCase);
            } else {
              key = camelCase(key);
              key = key in cache ? [key] : key.match(rnothtmlwhite) || [];
            }
            i = key.length;
            while (i--) {
              delete cache[key[i]];
            }
          }
          if (key === void 0 || jQuery.isEmptyObject(cache)) {
            if (owner.nodeType) {
              owner[this.expando] = void 0;
            } else {
              delete owner[this.expando];
            }
          }
        },
        hasData: function(owner) {
          var cache = owner[this.expando];
          return cache !== void 0 && !jQuery.isEmptyObject(cache);
        }
      };
      var dataPriv = new Data();
      var dataUser = new Data();
      var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
      function getData(data) {
        if (data === "true") {
          return true;
        }
        if (data === "false") {
          return false;
        }
        if (data === "null") {
          return null;
        }
        if (data === +data + "") {
          return +data;
        }
        if (rbrace.test(data)) {
          return JSON.parse(data);
        }
        return data;
      }
      function dataAttr(elem, key, data) {
        var name;
        if (data === void 0 && elem.nodeType === 1) {
          name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
          data = elem.getAttribute(name);
          if (typeof data === "string") {
            try {
              data = getData(data);
            } catch (e) {
            }
            dataUser.set(elem, key, data);
          } else {
            data = void 0;
          }
        }
        return data;
      }
      jQuery.extend({
        hasData: function(elem) {
          return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },
        data: function(elem, name, data) {
          return dataUser.access(elem, name, data);
        },
        removeData: function(elem, name) {
          dataUser.remove(elem, name);
        },
        _data: function(elem, name, data) {
          return dataPriv.access(elem, name, data);
        },
        _removeData: function(elem, name) {
          dataPriv.remove(elem, name);
        }
      });
      jQuery.fn.extend({
        data: function(key, value) {
          var i, name, data, elem = this[0], attrs = elem && elem.attributes;
          if (key === void 0) {
            if (this.length) {
              data = dataUser.get(elem);
              if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                i = attrs.length;
                while (i--) {
                  if (attrs[i]) {
                    name = attrs[i].name;
                    if (name.indexOf("data-") === 0) {
                      name = camelCase(name.slice(5));
                      dataAttr(elem, name, data[name]);
                    }
                  }
                }
                dataPriv.set(elem, "hasDataAttrs", true);
              }
            }
            return data;
          }
          if (typeof key === "object") {
            return this.each(function() {
              dataUser.set(this, key);
            });
          }
          return access(this, function(value2) {
            var data2;
            if (elem && value2 === void 0) {
              data2 = dataUser.get(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              data2 = dataAttr(elem, key);
              if (data2 !== void 0) {
                return data2;
              }
              return;
            }
            this.each(function() {
              dataUser.set(this, key, value2);
            });
          }, null, value, arguments.length > 1, null, true);
        },
        removeData: function(key) {
          return this.each(function() {
            dataUser.remove(this, key);
          });
        }
      });
      jQuery.extend({
        queue: function(elem, type, data) {
          var queue;
          if (elem) {
            type = (type || "fx") + "queue";
            queue = dataPriv.get(elem, type);
            if (data) {
              if (!queue || Array.isArray(data)) {
                queue = dataPriv.access(elem, type, jQuery.makeArray(data));
              } else {
                queue.push(data);
              }
            }
            return queue || [];
          }
        },
        dequeue: function(elem, type) {
          type = type || "fx";
          var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
            jQuery.dequeue(elem, type);
          };
          if (fn === "inprogress") {
            fn = queue.shift();
            startLength--;
          }
          if (fn) {
            if (type === "fx") {
              queue.unshift("inprogress");
            }
            delete hooks.stop;
            fn.call(elem, next, hooks);
          }
          if (!startLength && hooks) {
            hooks.empty.fire();
          }
        },
        _queueHooks: function(elem, type) {
          var key = type + "queueHooks";
          return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
            empty: jQuery.Callbacks("once memory").add(function() {
              dataPriv.remove(elem, [type + "queue", key]);
            })
          });
        }
      });
      jQuery.fn.extend({
        queue: function(type, data) {
          var setter = 2;
          if (typeof type !== "string") {
            data = type;
            type = "fx";
            setter--;
          }
          if (arguments.length < setter) {
            return jQuery.queue(this[0], type);
          }
          return data === void 0 ? this : this.each(function() {
            var queue = jQuery.queue(this, type, data);
            jQuery._queueHooks(this, type);
            if (type === "fx" && queue[0] !== "inprogress") {
              jQuery.dequeue(this, type);
            }
          });
        },
        dequeue: function(type) {
          return this.each(function() {
            jQuery.dequeue(this, type);
          });
        },
        clearQueue: function(type) {
          return this.queue(type || "fx", []);
        },
        promise: function(type, obj) {
          var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
            if (!--count) {
              defer.resolveWith(elements, [elements]);
            }
          };
          if (typeof type !== "string") {
            obj = type;
            type = void 0;
          }
          type = type || "fx";
          while (i--) {
            tmp = dataPriv.get(elements[i], type + "queueHooks");
            if (tmp && tmp.empty) {
              count++;
              tmp.empty.add(resolve);
            }
          }
          resolve();
          return defer.promise(obj);
        }
      });
      var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
      var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
      var cssExpand = ["Top", "Right", "Bottom", "Left"];
      var documentElement = document2.documentElement;
      var isAttached = function(elem) {
        return jQuery.contains(elem.ownerDocument, elem);
      }, composed = { composed: true };
      if (documentElement.getRootNode) {
        isAttached = function(elem) {
          return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument;
        };
      }
      var isHiddenWithinTree = function(elem, el) {
        elem = el || elem;
        return elem.style.display === "none" || elem.style.display === "" && isAttached(elem) && jQuery.css(elem, "display") === "none";
      };
      function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale, maxIterations = 20, currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
        if (initialInUnit && initialInUnit[3] !== unit) {
          initial = initial / 2;
          unit = unit || initialInUnit[3];
          initialInUnit = +initial || 1;
          while (maxIterations--) {
            jQuery.style(elem, prop, initialInUnit + unit);
            if ((1 - scale) * (1 - (scale = currentValue() / initial || 0.5)) <= 0) {
              maxIterations = 0;
            }
            initialInUnit = initialInUnit / scale;
          }
          initialInUnit = initialInUnit * 2;
          jQuery.style(elem, prop, initialInUnit + unit);
          valueParts = valueParts || [];
        }
        if (valueParts) {
          initialInUnit = +initialInUnit || +initial || 0;
          adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
          if (tween) {
            tween.unit = unit;
            tween.start = initialInUnit;
            tween.end = adjusted;
          }
        }
        return adjusted;
      }
      var defaultDisplayMap = {};
      function getDefaultDisplay(elem) {
        var temp, doc = elem.ownerDocument, nodeName2 = elem.nodeName, display = defaultDisplayMap[nodeName2];
        if (display) {
          return display;
        }
        temp = doc.body.appendChild(doc.createElement(nodeName2));
        display = jQuery.css(temp, "display");
        temp.parentNode.removeChild(temp);
        if (display === "none") {
          display = "block";
        }
        defaultDisplayMap[nodeName2] = display;
        return display;
      }
      function showHide(elements, show) {
        var display, elem, values = [], index = 0, length = elements.length;
        for (; index < length; index++) {
          elem = elements[index];
          if (!elem.style) {
            continue;
          }
          display = elem.style.display;
          if (show) {
            if (display === "none") {
              values[index] = dataPriv.get(elem, "display") || null;
              if (!values[index]) {
                elem.style.display = "";
              }
            }
            if (elem.style.display === "" && isHiddenWithinTree(elem)) {
              values[index] = getDefaultDisplay(elem);
            }
          } else {
            if (display !== "none") {
              values[index] = "none";
              dataPriv.set(elem, "display", display);
            }
          }
        }
        for (index = 0; index < length; index++) {
          if (values[index] != null) {
            elements[index].style.display = values[index];
          }
        }
        return elements;
      }
      jQuery.fn.extend({
        show: function() {
          return showHide(this, true);
        },
        hide: function() {
          return showHide(this);
        },
        toggle: function(state) {
          if (typeof state === "boolean") {
            return state ? this.show() : this.hide();
          }
          return this.each(function() {
            if (isHiddenWithinTree(this)) {
              jQuery(this).show();
            } else {
              jQuery(this).hide();
            }
          });
        }
      });
      var rcheckableType = /^(?:checkbox|radio)$/i;
      var rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
      (function() {
        var fragment = document2.createDocumentFragment(), div = fragment.appendChild(document2.createElement("div")), input = document2.createElement("input");
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");
        div.appendChild(input);
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        div.innerHTML = "<option></option>";
        support.option = !!div.lastChild;
      })();
      var wrapMap = {
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
      };
      wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
      wrapMap.th = wrapMap.td;
      if (!support.option) {
        wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"];
      }
      function getAll(context, tag) {
        var ret;
        if (typeof context.getElementsByTagName !== "undefined") {
          ret = context.getElementsByTagName(tag || "*");
        } else if (typeof context.querySelectorAll !== "undefined") {
          ret = context.querySelectorAll(tag || "*");
        } else {
          ret = [];
        }
        if (tag === void 0 || tag && nodeName(context, tag)) {
          return jQuery.merge([context], ret);
        }
        return ret;
      }
      function setGlobalEval(elems, refElements) {
        var i = 0, l = elems.length;
        for (; i < l; i++) {
          dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
      }
      var rhtml = /<|&#?\w+;/;
      function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
        for (; i < l; i++) {
          elem = elems[i];
          if (elem || elem === 0) {
            if (toType(elem) === "object") {
              jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
            } else if (!rhtml.test(elem)) {
              nodes.push(context.createTextNode(elem));
            } else {
              tmp = tmp || fragment.appendChild(context.createElement("div"));
              tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
              wrap = wrapMap[tag] || wrapMap._default;
              tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
              j = wrap[0];
              while (j--) {
                tmp = tmp.lastChild;
              }
              jQuery.merge(nodes, tmp.childNodes);
              tmp = fragment.firstChild;
              tmp.textContent = "";
            }
          }
        }
        fragment.textContent = "";
        i = 0;
        while (elem = nodes[i++]) {
          if (selection && jQuery.inArray(elem, selection) > -1) {
            if (ignored) {
              ignored.push(elem);
            }
            continue;
          }
          attached = isAttached(elem);
          tmp = getAll(fragment.appendChild(elem), "script");
          if (attached) {
            setGlobalEval(tmp);
          }
          if (scripts) {
            j = 0;
            while (elem = tmp[j++]) {
              if (rscriptType.test(elem.type || "")) {
                scripts.push(elem);
              }
            }
          }
        }
        return fragment;
      }
      var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
      function returnTrue() {
        return true;
      }
      function returnFalse() {
        return false;
      }
      function expectSync(elem, type) {
        return elem === safeActiveElement() === (type === "focus");
      }
      function safeActiveElement() {
        try {
          return document2.activeElement;
        } catch (err) {
        }
      }
      function on(elem, types, selector, data, fn, one) {
        var origFn, type;
        if (typeof types === "object") {
          if (typeof selector !== "string") {
            data = data || selector;
            selector = void 0;
          }
          for (type in types) {
            on(elem, type, selector, data, types[type], one);
          }
          return elem;
        }
        if (data == null && fn == null) {
          fn = selector;
          data = selector = void 0;
        } else if (fn == null) {
          if (typeof selector === "string") {
            fn = data;
            data = void 0;
          } else {
            fn = data;
            data = selector;
            selector = void 0;
          }
        }
        if (fn === false) {
          fn = returnFalse;
        } else if (!fn) {
          return elem;
        }
        if (one === 1) {
          origFn = fn;
          fn = function(event) {
            jQuery().off(event);
            return origFn.apply(this, arguments);
          };
          fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
          jQuery.event.add(this, types, fn, data, selector);
        });
      }
      jQuery.event = {
        global: {},
        add: function(elem, types, handler, data, selector) {
          var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
          if (!acceptData(elem)) {
            return;
          }
          if (handler.handler) {
            handleObjIn = handler;
            handler = handleObjIn.handler;
            selector = handleObjIn.selector;
          }
          if (selector) {
            jQuery.find.matchesSelector(documentElement, selector);
          }
          if (!handler.guid) {
            handler.guid = jQuery.guid++;
          }
          if (!(events = elemData.events)) {
            events = elemData.events = /* @__PURE__ */ Object.create(null);
          }
          if (!(eventHandle = elemData.handle)) {
            eventHandle = elemData.handle = function(e) {
              return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0;
            };
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            special = jQuery.event.special[type] || {};
            handleObj = jQuery.extend({
              type,
              origType,
              data,
              handler,
              guid: handler.guid,
              selector,
              needsContext: selector && jQuery.expr.match.needsContext.test(selector),
              namespace: namespaces.join(".")
            }, handleObjIn);
            if (!(handlers = events[type])) {
              handlers = events[type] = [];
              handlers.delegateCount = 0;
              if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                if (elem.addEventListener) {
                  elem.addEventListener(type, eventHandle);
                }
              }
            }
            if (special.add) {
              special.add.call(elem, handleObj);
              if (!handleObj.handler.guid) {
                handleObj.handler.guid = handler.guid;
              }
            }
            if (selector) {
              handlers.splice(handlers.delegateCount++, 0, handleObj);
            } else {
              handlers.push(handleObj);
            }
            jQuery.event.global[type] = true;
          }
        },
        remove: function(elem, types, handler, selector, mappedTypes) {
          var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
          if (!elemData || !(events = elemData.events)) {
            return;
          }
          types = (types || "").match(rnothtmlwhite) || [""];
          t = types.length;
          while (t--) {
            tmp = rtypenamespace.exec(types[t]) || [];
            type = origType = tmp[1];
            namespaces = (tmp[2] || "").split(".").sort();
            if (!type) {
              for (type in events) {
                jQuery.event.remove(elem, type + types[t], handler, selector, true);
              }
              continue;
            }
            special = jQuery.event.special[type] || {};
            type = (selector ? special.delegateType : special.bindType) || type;
            handlers = events[type] || [];
            tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
            origCount = j = handlers.length;
            while (j--) {
              handleObj = handlers[j];
              if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                handlers.splice(j, 1);
                if (handleObj.selector) {
                  handlers.delegateCount--;
                }
                if (special.remove) {
                  special.remove.call(elem, handleObj);
                }
              }
            }
            if (origCount && !handlers.length) {
              if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                jQuery.removeEvent(elem, type, elemData.handle);
              }
              delete events[type];
            }
          }
          if (jQuery.isEmptyObject(events)) {
            dataPriv.remove(elem, "handle events");
          }
        },
        dispatch: function(nativeEvent) {
          var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length), event = jQuery.event.fix(nativeEvent), handlers = (dataPriv.get(this, "events") || /* @__PURE__ */ Object.create(null))[event.type] || [], special = jQuery.event.special[event.type] || {};
          args[0] = event;
          for (i = 1; i < arguments.length; i++) {
            args[i] = arguments[i];
          }
          event.delegateTarget = this;
          if (special.preDispatch && special.preDispatch.call(this, event) === false) {
            return;
          }
          handlerQueue = jQuery.event.handlers.call(this, event, handlers);
          i = 0;
          while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
            event.currentTarget = matched.elem;
            j = 0;
            while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
              if (!event.rnamespace || handleObj.namespace === false || event.rnamespace.test(handleObj.namespace)) {
                event.handleObj = handleObj;
                event.data = handleObj.data;
                ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                if (ret !== void 0) {
                  if ((event.result = ret) === false) {
                    event.preventDefault();
                    event.stopPropagation();
                  }
                }
              }
            }
          }
          if (special.postDispatch) {
            special.postDispatch.call(this, event);
          }
          return event.result;
        },
        handlers: function(event, handlers) {
          var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
          if (delegateCount && cur.nodeType && !(event.type === "click" && event.button >= 1)) {
            for (; cur !== this; cur = cur.parentNode || this) {
              if (cur.nodeType === 1 && !(event.type === "click" && cur.disabled === true)) {
                matchedHandlers = [];
                matchedSelectors = {};
                for (i = 0; i < delegateCount; i++) {
                  handleObj = handlers[i];
                  sel = handleObj.selector + " ";
                  if (matchedSelectors[sel] === void 0) {
                    matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                  }
                  if (matchedSelectors[sel]) {
                    matchedHandlers.push(handleObj);
                  }
                }
                if (matchedHandlers.length) {
                  handlerQueue.push({ elem: cur, handlers: matchedHandlers });
                }
              }
            }
          }
          cur = this;
          if (delegateCount < handlers.length) {
            handlerQueue.push({ elem: cur, handlers: handlers.slice(delegateCount) });
          }
          return handlerQueue;
        },
        addProp: function(name, hook) {
          Object.defineProperty(jQuery.Event.prototype, name, {
            enumerable: true,
            configurable: true,
            get: isFunction(hook) ? function() {
              if (this.originalEvent) {
                return hook(this.originalEvent);
              }
            } : function() {
              if (this.originalEvent) {
                return this.originalEvent[name];
              }
            },
            set: function(value) {
              Object.defineProperty(this, name, {
                enumerable: true,
                configurable: true,
                writable: true,
                value
              });
            }
          });
        },
        fix: function(originalEvent) {
          return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent);
        },
        special: {
          load: {
            noBubble: true
          },
          click: {
            setup: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click", returnTrue);
              }
              return false;
            },
            trigger: function(data) {
              var el = this || data;
              if (rcheckableType.test(el.type) && el.click && nodeName(el, "input")) {
                leverageNative(el, "click");
              }
              return true;
            },
            _default: function(event) {
              var target = event.target;
              return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a");
            }
          },
          beforeunload: {
            postDispatch: function(event) {
              if (event.result !== void 0 && event.originalEvent) {
                event.originalEvent.returnValue = event.result;
              }
            }
          }
        }
      };
      function leverageNative(el, type, expectSync2) {
        if (!expectSync2) {
          if (dataPriv.get(el, type) === void 0) {
            jQuery.event.add(el, type, returnTrue);
          }
          return;
        }
        dataPriv.set(el, type, false);
        jQuery.event.add(el, type, {
          namespace: false,
          handler: function(event) {
            var notAsync, result, saved = dataPriv.get(this, type);
            if (event.isTrigger & 1 && this[type]) {
              if (!saved.length) {
                saved = slice.call(arguments);
                dataPriv.set(this, type, saved);
                notAsync = expectSync2(this, type);
                this[type]();
                result = dataPriv.get(this, type);
                if (saved !== result || notAsync) {
                  dataPriv.set(this, type, false);
                } else {
                  result = {};
                }
                if (saved !== result) {
                  event.stopImmediatePropagation();
                  event.preventDefault();
                  return result && result.value;
                }
              } else if ((jQuery.event.special[type] || {}).delegateType) {
                event.stopPropagation();
              }
            } else if (saved.length) {
              dataPriv.set(this, type, {
                value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
              });
              event.stopImmediatePropagation();
            }
          }
        });
      }
      jQuery.removeEvent = function(elem, type, handle) {
        if (elem.removeEventListener) {
          elem.removeEventListener(type, handle);
        }
      };
      jQuery.Event = function(src, props) {
        if (!(this instanceof jQuery.Event)) {
          return new jQuery.Event(src, props);
        }
        if (src && src.type) {
          this.originalEvent = src;
          this.type = src.type;
          this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === void 0 && src.returnValue === false ? returnTrue : returnFalse;
          this.target = src.target && src.target.nodeType === 3 ? src.target.parentNode : src.target;
          this.currentTarget = src.currentTarget;
          this.relatedTarget = src.relatedTarget;
        } else {
          this.type = src;
        }
        if (props) {
          jQuery.extend(this, props);
        }
        this.timeStamp = src && src.timeStamp || Date.now();
        this[jQuery.expando] = true;
      };
      jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,
        preventDefault: function() {
          var e = this.originalEvent;
          this.isDefaultPrevented = returnTrue;
          if (e && !this.isSimulated) {
            e.preventDefault();
          }
        },
        stopPropagation: function() {
          var e = this.originalEvent;
          this.isPropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopPropagation();
          }
        },
        stopImmediatePropagation: function() {
          var e = this.originalEvent;
          this.isImmediatePropagationStopped = returnTrue;
          if (e && !this.isSimulated) {
            e.stopImmediatePropagation();
          }
          this.stopPropagation();
        }
      };
      jQuery.each({
        altKey: true,
        bubbles: true,
        cancelable: true,
        changedTouches: true,
        ctrlKey: true,
        detail: true,
        eventPhase: true,
        metaKey: true,
        pageX: true,
        pageY: true,
        shiftKey: true,
        view: true,
        "char": true,
        code: true,
        charCode: true,
        key: true,
        keyCode: true,
        button: true,
        buttons: true,
        clientX: true,
        clientY: true,
        offsetX: true,
        offsetY: true,
        pointerId: true,
        pointerType: true,
        screenX: true,
        screenY: true,
        targetTouches: true,
        toElement: true,
        touches: true,
        which: true
      }, jQuery.event.addProp);
      jQuery.each({ focus: "focusin", blur: "focusout" }, function(type, delegateType) {
        jQuery.event.special[type] = {
          setup: function() {
            leverageNative(this, type, expectSync);
            return false;
          },
          trigger: function() {
            leverageNative(this, type);
            return true;
          },
          _default: function(event) {
            return dataPriv.get(event.target, type);
          },
          delegateType
        };
      });
      jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
      }, function(orig, fix) {
        jQuery.event.special[orig] = {
          delegateType: fix,
          bindType: fix,
          handle: function(event) {
            var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
            if (!related || related !== target && !jQuery.contains(target, related)) {
              event.type = handleObj.origType;
              ret = handleObj.handler.apply(this, arguments);
              event.type = fix;
            }
            return ret;
          }
        };
      });
      jQuery.fn.extend({
        on: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
          return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
          var handleObj, type;
          if (types && types.preventDefault && types.handleObj) {
            handleObj = types.handleObj;
            jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
            return this;
          }
          if (typeof types === "object") {
            for (type in types) {
              this.off(type, selector, types[type]);
            }
            return this;
          }
          if (selector === false || typeof selector === "function") {
            fn = selector;
            selector = void 0;
          }
          if (fn === false) {
            fn = returnFalse;
          }
          return this.each(function() {
            jQuery.event.remove(this, types, fn, selector);
          });
        }
      });
      var rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rcleanScript = /^\s*<!\[CDATA\[|\]\]>\s*$/g;
      function manipulationTarget(elem, content) {
        if (nodeName(elem, "table") && nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr")) {
          return jQuery(elem).children("tbody")[0] || elem;
        }
        return elem;
      }
      function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
      }
      function restoreScript(elem) {
        if ((elem.type || "").slice(0, 5) === "true/") {
          elem.type = elem.type.slice(5);
        } else {
          elem.removeAttribute("type");
        }
        return elem;
      }
      function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, udataOld, udataCur, events;
        if (dest.nodeType !== 1) {
          return;
        }
        if (dataPriv.hasData(src)) {
          pdataOld = dataPriv.get(src);
          events = pdataOld.events;
          if (events) {
            dataPriv.remove(dest, "handle events");
            for (type in events) {
              for (i = 0, l = events[type].length; i < l; i++) {
                jQuery.event.add(dest, type, events[type][i]);
              }
            }
          }
        }
        if (dataUser.hasData(src)) {
          udataOld = dataUser.access(src);
          udataCur = jQuery.extend({}, udataOld);
          dataUser.set(dest, udataCur);
        }
      }
      function fixInput(src, dest) {
        var nodeName2 = dest.nodeName.toLowerCase();
        if (nodeName2 === "input" && rcheckableType.test(src.type)) {
          dest.checked = src.checked;
        } else if (nodeName2 === "input" || nodeName2 === "textarea") {
          dest.defaultValue = src.defaultValue;
        }
      }
      function domManip(collection, args, callback, ignored) {
        args = flat(args);
        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], valueIsFunction = isFunction(value);
        if (valueIsFunction || l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value)) {
          return collection.each(function(index) {
            var self2 = collection.eq(index);
            if (valueIsFunction) {
              args[0] = value.call(this, index, self2.html());
            }
            domManip(self2, args, callback, ignored);
          });
        }
        if (l) {
          fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
          first = fragment.firstChild;
          if (fragment.childNodes.length === 1) {
            fragment = first;
          }
          if (first || ignored) {
            scripts = jQuery.map(getAll(fragment, "script"), disableScript);
            hasScripts = scripts.length;
            for (; i < l; i++) {
              node = fragment;
              if (i !== iNoClone) {
                node = jQuery.clone(node, true, true);
                if (hasScripts) {
                  jQuery.merge(scripts, getAll(node, "script"));
                }
              }
              callback.call(collection[i], node, i);
            }
            if (hasScripts) {
              doc = scripts[scripts.length - 1].ownerDocument;
              jQuery.map(scripts, restoreScript);
              for (i = 0; i < hasScripts; i++) {
                node = scripts[i];
                if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
                  if (node.src && (node.type || "").toLowerCase() !== "module") {
                    if (jQuery._evalUrl && !node.noModule) {
                      jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                      }, doc);
                    }
                  } else {
                    DOMEval(node.textContent.replace(rcleanScript, ""), node, doc);
                  }
                }
              }
            }
          }
        }
        return collection;
      }
      function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
        for (; (node = nodes[i]) != null; i++) {
          if (!keepData && node.nodeType === 1) {
            jQuery.cleanData(getAll(node));
          }
          if (node.parentNode) {
            if (keepData && isAttached(node)) {
              setGlobalEval(getAll(node, "script"));
            }
            node.parentNode.removeChild(node);
          }
        }
        return elem;
      }
      jQuery.extend({
        htmlPrefilter: function(html) {
          return html;
        },
        clone: function(elem, dataAndEvents, deepDataAndEvents) {
          var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = isAttached(elem);
          if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
            destElements = getAll(clone);
            srcElements = getAll(elem);
            for (i = 0, l = srcElements.length; i < l; i++) {
              fixInput(srcElements[i], destElements[i]);
            }
          }
          if (dataAndEvents) {
            if (deepDataAndEvents) {
              srcElements = srcElements || getAll(elem);
              destElements = destElements || getAll(clone);
              for (i = 0, l = srcElements.length; i < l; i++) {
                cloneCopyEvent(srcElements[i], destElements[i]);
              }
            } else {
              cloneCopyEvent(elem, clone);
            }
          }
          destElements = getAll(clone, "script");
          if (destElements.length > 0) {
            setGlobalEval(destElements, !inPage && getAll(elem, "script"));
          }
          return clone;
        },
        cleanData: function(elems) {
          var data, elem, type, special = jQuery.event.special, i = 0;
          for (; (elem = elems[i]) !== void 0; i++) {
            if (acceptData(elem)) {
              if (data = elem[dataPriv.expando]) {
                if (data.events) {
                  for (type in data.events) {
                    if (special[type]) {
                      jQuery.event.remove(elem, type);
                    } else {
                      jQuery.removeEvent(elem, type, data.handle);
                    }
                  }
                }
                elem[dataPriv.expando] = void 0;
              }
              if (elem[dataUser.expando]) {
                elem[dataUser.expando] = void 0;
              }
            }
          }
        }
      });
      jQuery.fn.extend({
        detach: function(selector) {
          return remove(this, selector, true);
        },
        remove: function(selector) {
          return remove(this, selector);
        },
        text: function(value) {
          return access(this, function(value2) {
            return value2 === void 0 ? jQuery.text(this) : this.empty().each(function() {
              if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                this.textContent = value2;
              }
            });
          }, null, value, arguments.length);
        },
        append: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.appendChild(elem);
            }
          });
        },
        prepend: function() {
          return domManip(this, arguments, function(elem) {
            if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
              var target = manipulationTarget(this, elem);
              target.insertBefore(elem, target.firstChild);
            }
          });
        },
        before: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this);
            }
          });
        },
        after: function() {
          return domManip(this, arguments, function(elem) {
            if (this.parentNode) {
              this.parentNode.insertBefore(elem, this.nextSibling);
            }
          });
        },
        empty: function() {
          var elem, i = 0;
          for (; (elem = this[i]) != null; i++) {
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.textContent = "";
            }
          }
          return this;
        },
        clone: function(dataAndEvents, deepDataAndEvents) {
          dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
          deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
          return this.map(function() {
            return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
          });
        },
        html: function(value) {
          return access(this, function(value2) {
            var elem = this[0] || {}, i = 0, l = this.length;
            if (value2 === void 0 && elem.nodeType === 1) {
              return elem.innerHTML;
            }
            if (typeof value2 === "string" && !rnoInnerhtml.test(value2) && !wrapMap[(rtagName.exec(value2) || ["", ""])[1].toLowerCase()]) {
              value2 = jQuery.htmlPrefilter(value2);
              try {
                for (; i < l; i++) {
                  elem = this[i] || {};
                  if (elem.nodeType === 1) {
                    jQuery.cleanData(getAll(elem, false));
                    elem.innerHTML = value2;
                  }
                }
                elem = 0;
              } catch (e) {
              }
            }
            if (elem) {
              this.empty().append(value2);
            }
          }, null, value, arguments.length);
        },
        replaceWith: function() {
          var ignored = [];
          return domManip(this, arguments, function(elem) {
            var parent = this.parentNode;
            if (jQuery.inArray(this, ignored) < 0) {
              jQuery.cleanData(getAll(this));
              if (parent) {
                parent.replaceChild(elem, this);
              }
            }
          }, ignored);
        }
      });
      jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
      }, function(name, original) {
        jQuery.fn[name] = function(selector) {
          var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
          for (; i <= last; i++) {
            elems = i === last ? this : this.clone(true);
            jQuery(insert[i])[original](elems);
            push.apply(ret, elems.get());
          }
          return this.pushStack(ret);
        };
      });
      var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
      var rcustomProp = /^--/;
      var getStyles = function(elem) {
        var view = elem.ownerDocument.defaultView;
        if (!view || !view.opener) {
          view = window2;
        }
        return view.getComputedStyle(elem);
      };
      var swap = function(elem, options, callback) {
        var ret, name, old = {};
        for (name in options) {
          old[name] = elem.style[name];
          elem.style[name] = options[name];
        }
        ret = callback.call(elem);
        for (name in options) {
          elem.style[name] = old[name];
        }
        return ret;
      };
      var rboxStyle = new RegExp(cssExpand.join("|"), "i");
      var whitespace = "[\\x20\\t\\r\\n\\f]";
      var rtrimCSS = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g");
      (function() {
        function computeStyleTests() {
          if (!div) {
            return;
          }
          container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0";
          div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%";
          documentElement.appendChild(container).appendChild(div);
          var divStyle = window2.getComputedStyle(div);
          pixelPositionVal = divStyle.top !== "1%";
          reliableMarginLeftVal = roundPixelMeasures(divStyle.marginLeft) === 12;
          div.style.right = "60%";
          pixelBoxStylesVal = roundPixelMeasures(divStyle.right) === 36;
          boxSizingReliableVal = roundPixelMeasures(divStyle.width) === 36;
          div.style.position = "absolute";
          scrollboxSizeVal = roundPixelMeasures(div.offsetWidth / 3) === 12;
          documentElement.removeChild(container);
          div = null;
        }
        function roundPixelMeasures(measure) {
          return Math.round(parseFloat(measure));
        }
        var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document2.createElement("div"), div = document2.createElement("div");
        if (!div.style) {
          return;
        }
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";
        jQuery.extend(support, {
          boxSizingReliable: function() {
            computeStyleTests();
            return boxSizingReliableVal;
          },
          pixelBoxStyles: function() {
            computeStyleTests();
            return pixelBoxStylesVal;
          },
          pixelPosition: function() {
            computeStyleTests();
            return pixelPositionVal;
          },
          reliableMarginLeft: function() {
            computeStyleTests();
            return reliableMarginLeftVal;
          },
          scrollboxSize: function() {
            computeStyleTests();
            return scrollboxSizeVal;
          },
          reliableTrDimensions: function() {
            var table, tr, trChild, trStyle;
            if (reliableTrDimensionsVal == null) {
              table = document2.createElement("table");
              tr = document2.createElement("tr");
              trChild = document2.createElement("div");
              table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
              tr.style.cssText = "border:1px solid";
              tr.style.height = "1px";
              trChild.style.height = "9px";
              trChild.style.display = "block";
              documentElement.appendChild(table).appendChild(tr).appendChild(trChild);
              trStyle = window2.getComputedStyle(tr);
              reliableTrDimensionsVal = parseInt(trStyle.height, 10) + parseInt(trStyle.borderTopWidth, 10) + parseInt(trStyle.borderBottomWidth, 10) === tr.offsetHeight;
              documentElement.removeChild(table);
            }
            return reliableTrDimensionsVal;
          }
        });
      })();
      function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, isCustomProp = rcustomProp.test(name), style = elem.style;
        computed = computed || getStyles(elem);
        if (computed) {
          ret = computed.getPropertyValue(name) || computed[name];
          if (isCustomProp && ret) {
            ret = ret.replace(rtrimCSS, "$1") || void 0;
          }
          if (ret === "" && !isAttached(elem)) {
            ret = jQuery.style(elem, name);
          }
          if (!support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name)) {
            width = style.width;
            minWidth = style.minWidth;
            maxWidth = style.maxWidth;
            style.minWidth = style.maxWidth = style.width = ret;
            ret = computed.width;
            style.width = width;
            style.minWidth = minWidth;
            style.maxWidth = maxWidth;
          }
        }
        return ret !== void 0 ? ret + "" : ret;
      }
      function addGetHookIf(conditionFn, hookFn) {
        return {
          get: function() {
            if (conditionFn()) {
              delete this.get;
              return;
            }
            return (this.get = hookFn).apply(this, arguments);
          }
        };
      }
      var cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document2.createElement("div").style, vendorProps = {};
      function vendorPropName(name) {
        var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
        while (i--) {
          name = cssPrefixes[i] + capName;
          if (name in emptyStyle) {
            return name;
          }
        }
      }
      function finalPropName(name) {
        var final = jQuery.cssProps[name] || vendorProps[name];
        if (final) {
          return final;
        }
        if (name in emptyStyle) {
          return name;
        }
        return vendorProps[name] = vendorPropName(name) || name;
      }
      var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = { position: "absolute", visibility: "hidden", display: "block" }, cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      };
      function setPositiveNumber(_elem, value, subtract) {
        var matches = rcssNum.exec(value);
        return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
      }
      function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
        var i = dimension === "width" ? 1 : 0, extra = 0, delta = 0;
        if (box === (isBorderBox ? "border" : "content")) {
          return 0;
        }
        for (; i < 4; i += 2) {
          if (box === "margin") {
            delta += jQuery.css(elem, box + cssExpand[i], true, styles);
          }
          if (!isBorderBox) {
            delta += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            if (box !== "padding") {
              delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            } else {
              extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          } else {
            if (box === "content") {
              delta -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
            }
            if (box !== "margin") {
              delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
            }
          }
        }
        if (!isBorderBox && computedVal >= 0) {
          delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - 0.5)) || 0;
        }
        return delta;
      }
      function getWidthOrHeight(elem, dimension, extra) {
        var styles = getStyles(elem), boxSizingNeeded = !support.boxSizingReliable() || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", valueIsBorderBox = isBorderBox, val = curCSS(elem, dimension, styles), offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
        if (rnumnonpx.test(val)) {
          if (!extra) {
            return val;
          }
          val = "auto";
        }
        if ((!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || val === "auto" || !parseFloat(val) && jQuery.css(elem, "display", false, styles) === "inline") && elem.getClientRects().length) {
          isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
          valueIsBorderBox = offsetProp in elem;
          if (valueIsBorderBox) {
            val = elem[offsetProp];
          }
        }
        val = parseFloat(val) || 0;
        return val + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px";
      }
      jQuery.extend({
        cssHooks: {
          opacity: {
            get: function(elem, computed) {
              if (computed) {
                var ret = curCSS(elem, "opacity");
                return ret === "" ? "1" : ret;
              }
            }
          }
        },
        cssNumber: {
          "animationIterationCount": true,
          "columnCount": true,
          "fillOpacity": true,
          "flexGrow": true,
          "flexShrink": true,
          "fontWeight": true,
          "gridArea": true,
          "gridColumn": true,
          "gridColumnEnd": true,
          "gridColumnStart": true,
          "gridRow": true,
          "gridRowEnd": true,
          "gridRowStart": true,
          "lineHeight": true,
          "opacity": true,
          "order": true,
          "orphans": true,
          "widows": true,
          "zIndex": true,
          "zoom": true
        },
        cssProps: {},
        style: function(elem, name, value, extra) {
          if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
            return;
          }
          var ret, type, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name), style = elem.style;
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (value !== void 0) {
            type = typeof value;
            if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
              value = adjustCSS(elem, name, ret);
              type = "number";
            }
            if (value == null || value !== value) {
              return;
            }
            if (type === "number" && !isCustomProp) {
              value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
            }
            if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
              style[name] = "inherit";
            }
            if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== void 0) {
              if (isCustomProp) {
                style.setProperty(name, value);
              } else {
                style[name] = value;
              }
            }
          } else {
            if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== void 0) {
              return ret;
            }
            return style[name];
          }
        },
        css: function(elem, name, extra, styles) {
          var val, num, hooks, origName = camelCase(name), isCustomProp = rcustomProp.test(name);
          if (!isCustomProp) {
            name = finalPropName(origName);
          }
          hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
          if (hooks && "get" in hooks) {
            val = hooks.get(elem, true, extra);
          }
          if (val === void 0) {
            val = curCSS(elem, name, styles);
          }
          if (val === "normal" && name in cssNormalTransform) {
            val = cssNormalTransform[name];
          }
          if (extra === "" || extra) {
            num = parseFloat(val);
            return extra === true || isFinite(num) ? num || 0 : val;
          }
          return val;
        }
      });
      jQuery.each(["height", "width"], function(_i, dimension) {
        jQuery.cssHooks[dimension] = {
          get: function(elem, computed, extra) {
            if (computed) {
              return rdisplayswap.test(jQuery.css(elem, "display")) && (!elem.getClientRects().length || !elem.getBoundingClientRect().width) ? swap(elem, cssShow, function() {
                return getWidthOrHeight(elem, dimension, extra);
              }) : getWidthOrHeight(elem, dimension, extra);
            }
          },
          set: function(elem, value, extra) {
            var matches, styles = getStyles(elem), scrollboxSizeBuggy = !support.scrollboxSize() && styles.position === "absolute", boxSizingNeeded = scrollboxSizeBuggy || extra, isBorderBox = boxSizingNeeded && jQuery.css(elem, "boxSizing", false, styles) === "border-box", subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
            if (isBorderBox && scrollboxSizeBuggy) {
              subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", false, styles) - 0.5);
            }
            if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
              elem.style[dimension] = value;
              value = jQuery.css(elem, dimension);
            }
            return setPositiveNumber(elem, value, subtract);
          }
        };
      });
      jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
          return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function() {
            return elem.getBoundingClientRect().left;
          })) + "px";
        }
      });
      jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
      }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
          expand: function(value) {
            var i = 0, expanded = {}, parts = typeof value === "string" ? value.split(" ") : [value];
            for (; i < 4; i++) {
              expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
            }
            return expanded;
          }
        };
        if (prefix !== "margin") {
          jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
      });
      jQuery.fn.extend({
        css: function(name, value) {
          return access(this, function(elem, name2, value2) {
            var styles, len, map = {}, i = 0;
            if (Array.isArray(name2)) {
              styles = getStyles(elem);
              len = name2.length;
              for (; i < len; i++) {
                map[name2[i]] = jQuery.css(elem, name2[i], false, styles);
              }
              return map;
            }
            return value2 !== void 0 ? jQuery.style(elem, name2, value2) : jQuery.css(elem, name2);
          }, name, value, arguments.length > 1);
        }
      });
      function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem, options, prop, end, easing);
      }
      jQuery.Tween = Tween;
      Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
          this.elem = elem;
          this.prop = prop;
          this.easing = easing || jQuery.easing._default;
          this.options = options;
          this.start = this.now = this.cur();
          this.end = end;
          this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
          var hooks = Tween.propHooks[this.prop];
          return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
          var eased, hooks = Tween.propHooks[this.prop];
          if (this.options.duration) {
            this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
          } else {
            this.pos = eased = percent;
          }
          this.now = (this.end - this.start) * eased + this.start;
          if (this.options.step) {
            this.options.step.call(this.elem, this.now, this);
          }
          if (hooks && hooks.set) {
            hooks.set(this);
          } else {
            Tween.propHooks._default.set(this);
          }
          return this;
        }
      };
      Tween.prototype.init.prototype = Tween.prototype;
      Tween.propHooks = {
        _default: {
          get: function(tween) {
            var result;
            if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
              return tween.elem[tween.prop];
            }
            result = jQuery.css(tween.elem, tween.prop, "");
            return !result || result === "auto" ? 0 : result;
          },
          set: function(tween) {
            if (jQuery.fx.step[tween.prop]) {
              jQuery.fx.step[tween.prop](tween);
            } else if (tween.elem.nodeType === 1 && (jQuery.cssHooks[tween.prop] || tween.elem.style[finalPropName(tween.prop)] != null)) {
              jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
            } else {
              tween.elem[tween.prop] = tween.now;
            }
          }
        }
      };
      Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
          if (tween.elem.nodeType && tween.elem.parentNode) {
            tween.elem[tween.prop] = tween.now;
          }
        }
      };
      jQuery.easing = {
        linear: function(p) {
          return p;
        },
        swing: function(p) {
          return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
      };
      jQuery.fx = Tween.prototype.init;
      jQuery.fx.step = {};
      var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
      function schedule() {
        if (inProgress) {
          if (document2.hidden === false && window2.requestAnimationFrame) {
            window2.requestAnimationFrame(schedule);
          } else {
            window2.setTimeout(schedule, jQuery.fx.interval);
          }
          jQuery.fx.tick();
        }
      }
      function createFxNow() {
        window2.setTimeout(function() {
          fxNow = void 0;
        });
        return fxNow = Date.now();
      }
      function genFx(type, includeWidth) {
        var which, i = 0, attrs = { height: type };
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
          which = cssExpand[i];
          attrs["margin" + which] = attrs["padding" + which] = type;
        }
        if (includeWidth) {
          attrs.opacity = attrs.width = type;
        }
        return attrs;
      }
      function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (; index < length; index++) {
          if (tween = collection[index].call(animation, prop, value)) {
            return tween;
          }
        }
      }
      function defaultPrefilter(elem, props, opts) {
        var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
        if (!opts.queue) {
          hooks = jQuery._queueHooks(elem, "fx");
          if (hooks.unqueued == null) {
            hooks.unqueued = 0;
            oldfire = hooks.empty.fire;
            hooks.empty.fire = function() {
              if (!hooks.unqueued) {
                oldfire();
              }
            };
          }
          hooks.unqueued++;
          anim.always(function() {
            anim.always(function() {
              hooks.unqueued--;
              if (!jQuery.queue(elem, "fx").length) {
                hooks.empty.fire();
              }
            });
          });
        }
        for (prop in props) {
          value = props[prop];
          if (rfxtypes.test(value)) {
            delete props[prop];
            toggle = toggle || value === "toggle";
            if (value === (hidden ? "hide" : "show")) {
              if (value === "show" && dataShow && dataShow[prop] !== void 0) {
                hidden = true;
              } else {
                continue;
              }
            }
            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
          }
        }
        propTween = !jQuery.isEmptyObject(props);
        if (!propTween && jQuery.isEmptyObject(orig)) {
          return;
        }
        if (isBox && elem.nodeType === 1) {
          opts.overflow = [style.overflow, style.overflowX, style.overflowY];
          restoreDisplay = dataShow && dataShow.display;
          if (restoreDisplay == null) {
            restoreDisplay = dataPriv.get(elem, "display");
          }
          display = jQuery.css(elem, "display");
          if (display === "none") {
            if (restoreDisplay) {
              display = restoreDisplay;
            } else {
              showHide([elem], true);
              restoreDisplay = elem.style.display || restoreDisplay;
              display = jQuery.css(elem, "display");
              showHide([elem]);
            }
          }
          if (display === "inline" || display === "inline-block" && restoreDisplay != null) {
            if (jQuery.css(elem, "float") === "none") {
              if (!propTween) {
                anim.done(function() {
                  style.display = restoreDisplay;
                });
                if (restoreDisplay == null) {
                  display = style.display;
                  restoreDisplay = display === "none" ? "" : display;
                }
              }
              style.display = "inline-block";
            }
          }
        }
        if (opts.overflow) {
          style.overflow = "hidden";
          anim.always(function() {
            style.overflow = opts.overflow[0];
            style.overflowX = opts.overflow[1];
            style.overflowY = opts.overflow[2];
          });
        }
        propTween = false;
        for (prop in orig) {
          if (!propTween) {
            if (dataShow) {
              if ("hidden" in dataShow) {
                hidden = dataShow.hidden;
              }
            } else {
              dataShow = dataPriv.access(elem, "fxshow", { display: restoreDisplay });
            }
            if (toggle) {
              dataShow.hidden = !hidden;
            }
            if (hidden) {
              showHide([elem], true);
            }
            anim.done(function() {
              if (!hidden) {
                showHide([elem]);
              }
              dataPriv.remove(elem, "fxshow");
              for (prop in orig) {
                jQuery.style(elem, prop, orig[prop]);
              }
            });
          }
          propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
          if (!(prop in dataShow)) {
            dataShow[prop] = propTween.start;
            if (hidden) {
              propTween.end = propTween.start;
              propTween.start = 0;
            }
          }
        }
      }
      function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;
        for (index in props) {
          name = camelCase(index);
          easing = specialEasing[name];
          value = props[index];
          if (Array.isArray(value)) {
            easing = value[1];
            value = props[index] = value[0];
          }
          if (index !== name) {
            props[name] = value;
            delete props[index];
          }
          hooks = jQuery.cssHooks[name];
          if (hooks && "expand" in hooks) {
            value = hooks.expand(value);
            delete props[name];
            for (index in value) {
              if (!(index in props)) {
                props[index] = value[index];
                specialEasing[index] = easing;
              }
            }
          } else {
            specialEasing[name] = easing;
          }
        }
      }
      function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }), tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index2 = 0, length2 = animation.tweens.length;
          for (; index2 < length2; index2++) {
            animation.tweens[index2].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length2) {
            return remaining;
          }
          if (!length2) {
            deferred.notifyWith(elem, [animation, 1, 0]);
          }
          deferred.resolveWith(elem, [animation]);
          return false;
        }, animation = deferred.promise({
          elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index2 = 0, length2 = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index2 < length2; index2++) {
              animation.tweens[index2].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }), props = animation.props;
        propFilter(props, animation.opts.specialEasing);
        for (; index < length; index++) {
          result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
          if (result) {
            if (isFunction(result.stop)) {
              jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result);
            }
            return result;
          }
        }
        jQuery.map(props, createTween, animation);
        if (isFunction(animation.opts.start)) {
          animation.opts.start.call(elem, animation);
        }
        animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        jQuery.fx.timer(jQuery.extend(tick, {
          elem,
          anim: animation,
          queue: animation.opts.queue
        }));
        return animation;
      }
      jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
          "*": [function(prop, value) {
            var tween = this.createTween(prop, value);
            adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
            return tween;
          }]
        },
        tweener: function(props, callback) {
          if (isFunction(props)) {
            callback = props;
            props = ["*"];
          } else {
            props = props.match(rnothtmlwhite);
          }
          var prop, index = 0, length = props.length;
          for (; index < length; index++) {
            prop = props[index];
            Animation.tweeners[prop] = Animation.tweeners[prop] || [];
            Animation.tweeners[prop].unshift(callback);
          }
        },
        prefilters: [defaultPrefilter],
        prefilter: function(callback, prepend) {
          if (prepend) {
            Animation.prefilters.unshift(callback);
          } else {
            Animation.prefilters.push(callback);
          }
        }
      });
      jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
          complete: fn || !fn && easing || isFunction(speed) && speed,
          duration: speed,
          easing: fn && easing || easing && !isFunction(easing) && easing
        };
        if (jQuery.fx.off) {
          opt.duration = 0;
        } else {
          if (typeof opt.duration !== "number") {
            if (opt.duration in jQuery.fx.speeds) {
              opt.duration = jQuery.fx.speeds[opt.duration];
            } else {
              opt.duration = jQuery.fx.speeds._default;
            }
          }
        }
        if (opt.queue == null || opt.queue === true) {
          opt.queue = "fx";
        }
        opt.old = opt.complete;
        opt.complete = function() {
          if (isFunction(opt.old)) {
            opt.old.call(this);
          }
          if (opt.queue) {
            jQuery.dequeue(this, opt.queue);
          }
        };
        return opt;
      };
      jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {
          return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({ opacity: to }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
          var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
          doAnimation.finish = doAnimation;
          return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
          var stopQueue = function(hooks) {
            var stop = hooks.stop;
            delete hooks.stop;
            stop(gotoEnd);
          };
          if (typeof type !== "string") {
            gotoEnd = clearQueue;
            clearQueue = type;
            type = void 0;
          }
          if (clearQueue) {
            this.queue(type || "fx", []);
          }
          return this.each(function() {
            var dequeue = true, index = type != null && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
            if (index) {
              if (data[index] && data[index].stop) {
                stopQueue(data[index]);
              }
            } else {
              for (index in data) {
                if (data[index] && data[index].stop && rrun.test(index)) {
                  stopQueue(data[index]);
                }
              }
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                timers[index].anim.stop(gotoEnd);
                dequeue = false;
                timers.splice(index, 1);
              }
            }
            if (dequeue || !gotoEnd) {
              jQuery.dequeue(this, type);
            }
          });
        },
        finish: function(type) {
          if (type !== false) {
            type = type || "fx";
          }
          return this.each(function() {
            var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
            data.finish = true;
            jQuery.queue(this, type, []);
            if (hooks && hooks.stop) {
              hooks.stop.call(this, true);
            }
            for (index = timers.length; index--; ) {
              if (timers[index].elem === this && timers[index].queue === type) {
                timers[index].anim.stop(true);
                timers.splice(index, 1);
              }
            }
            for (index = 0; index < length; index++) {
              if (queue[index] && queue[index].finish) {
                queue[index].finish.call(this);
              }
            }
            delete data.finish;
          });
        }
      });
      jQuery.each(["toggle", "show", "hide"], function(_i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
          return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        };
      });
      jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: { opacity: "show" },
        fadeOut: { opacity: "hide" },
        fadeToggle: { opacity: "toggle" }
      }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
          return this.animate(props, speed, easing, callback);
        };
      });
      jQuery.timers = [];
      jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;
        fxNow = Date.now();
        for (; i < timers.length; i++) {
          timer = timers[i];
          if (!timer() && timers[i] === timer) {
            timers.splice(i--, 1);
          }
        }
        if (!timers.length) {
          jQuery.fx.stop();
        }
        fxNow = void 0;
      };
      jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        jQuery.fx.start();
      };
      jQuery.fx.interval = 13;
      jQuery.fx.start = function() {
        if (inProgress) {
          return;
        }
        inProgress = true;
        schedule();
      };
      jQuery.fx.stop = function() {
        inProgress = null;
      };
      jQuery.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
      };
      jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";
        return this.queue(type, function(next, hooks) {
          var timeout = window2.setTimeout(next, time);
          hooks.stop = function() {
            window2.clearTimeout(timeout);
          };
        });
      };
      (function() {
        var input = document2.createElement("input"), select = document2.createElement("select"), opt = select.appendChild(document2.createElement("option"));
        input.type = "checkbox";
        support.checkOn = input.value !== "";
        support.optSelected = opt.selected;
        input = document2.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
      })();
      var boolHook, attrHandle = jQuery.expr.attrHandle;
      jQuery.fn.extend({
        attr: function(name, value) {
          return access(this, jQuery.attr, name, value, arguments.length > 1);
        },
        removeAttr: function(name) {
          return this.each(function() {
            jQuery.removeAttr(this, name);
          });
        }
      });
      jQuery.extend({
        attr: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (typeof elem.getAttribute === "undefined") {
            return jQuery.prop(elem, name, value);
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0);
          }
          if (value !== void 0) {
            if (value === null) {
              jQuery.removeAttr(elem, name);
              return;
            }
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            elem.setAttribute(name, value + "");
            return value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          ret = jQuery.find.attr(elem, name);
          return ret == null ? void 0 : ret;
        },
        attrHooks: {
          type: {
            set: function(elem, value) {
              if (!support.radioValue && value === "radio" && nodeName(elem, "input")) {
                var val = elem.value;
                elem.setAttribute("type", value);
                if (val) {
                  elem.value = val;
                }
                return value;
              }
            }
          }
        },
        removeAttr: function(elem, value) {
          var name, i = 0, attrNames = value && value.match(rnothtmlwhite);
          if (attrNames && elem.nodeType === 1) {
            while (name = attrNames[i++]) {
              elem.removeAttribute(name);
            }
          }
        }
      });
      boolHook = {
        set: function(elem, value, name) {
          if (value === false) {
            jQuery.removeAttr(elem, name);
          } else {
            elem.setAttribute(name, name);
          }
          return name;
        }
      };
      jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(_i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;
        attrHandle[name] = function(elem, name2, isXML) {
          var ret, handle, lowercaseName = name2.toLowerCase();
          if (!isXML) {
            handle = attrHandle[lowercaseName];
            attrHandle[lowercaseName] = ret;
            ret = getter(elem, name2, isXML) != null ? lowercaseName : null;
            attrHandle[lowercaseName] = handle;
          }
          return ret;
        };
      });
      var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
      jQuery.fn.extend({
        prop: function(name, value) {
          return access(this, jQuery.prop, name, value, arguments.length > 1);
        },
        removeProp: function(name) {
          return this.each(function() {
            delete this[jQuery.propFix[name] || name];
          });
        }
      });
      jQuery.extend({
        prop: function(elem, name, value) {
          var ret, hooks, nType = elem.nodeType;
          if (nType === 3 || nType === 8 || nType === 2) {
            return;
          }
          if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
            name = jQuery.propFix[name] || name;
            hooks = jQuery.propHooks[name];
          }
          if (value !== void 0) {
            if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== void 0) {
              return ret;
            }
            return elem[name] = value;
          }
          if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
            return ret;
          }
          return elem[name];
        },
        propHooks: {
          tabIndex: {
            get: function(elem) {
              var tabindex = jQuery.find.attr(elem, "tabindex");
              if (tabindex) {
                return parseInt(tabindex, 10);
              }
              if (rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href) {
                return 0;
              }
              return -1;
            }
          }
        },
        propFix: {
          "for": "htmlFor",
          "class": "className"
        }
      });
      if (!support.optSelected) {
        jQuery.propHooks.selected = {
          get: function(elem) {
            var parent = elem.parentNode;
            if (parent && parent.parentNode) {
              parent.parentNode.selectedIndex;
            }
            return null;
          },
          set: function(elem) {
            var parent = elem.parentNode;
            if (parent) {
              parent.selectedIndex;
              if (parent.parentNode) {
                parent.parentNode.selectedIndex;
              }
            }
          }
        };
      }
      jQuery.each([
        "tabIndex",
        "readOnly",
        "maxLength",
        "cellSpacing",
        "cellPadding",
        "rowSpan",
        "colSpan",
        "useMap",
        "frameBorder",
        "contentEditable"
      ], function() {
        jQuery.propFix[this.toLowerCase()] = this;
      });
      function stripAndCollapse(value) {
        var tokens = value.match(rnothtmlwhite) || [];
        return tokens.join(" ");
      }
      function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
      }
      function classesToArray(value) {
        if (Array.isArray(value)) {
          return value;
        }
        if (typeof value === "string") {
          return value.match(rnothtmlwhite) || [];
        }
        return [];
      }
      jQuery.fn.extend({
        addClass: function(value) {
          var classNames, cur, curValue, className, i, finalValue;
          if (isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).addClass(value.call(this, j, getClass(this)));
            });
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  if (cur.indexOf(" " + className + " ") < 0) {
                    cur += className + " ";
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        removeClass: function(value) {
          var classNames, cur, curValue, className, i, finalValue;
          if (isFunction(value)) {
            return this.each(function(j) {
              jQuery(this).removeClass(value.call(this, j, getClass(this)));
            });
          }
          if (!arguments.length) {
            return this.attr("class", "");
          }
          classNames = classesToArray(value);
          if (classNames.length) {
            return this.each(function() {
              curValue = getClass(this);
              cur = this.nodeType === 1 && " " + stripAndCollapse(curValue) + " ";
              if (cur) {
                for (i = 0; i < classNames.length; i++) {
                  className = classNames[i];
                  while (cur.indexOf(" " + className + " ") > -1) {
                    cur = cur.replace(" " + className + " ", " ");
                  }
                }
                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) {
                  this.setAttribute("class", finalValue);
                }
              }
            });
          }
          return this;
        },
        toggleClass: function(value, stateVal) {
          var classNames, className, i, self2, type = typeof value, isValidValue = type === "string" || Array.isArray(value);
          if (isFunction(value)) {
            return this.each(function(i2) {
              jQuery(this).toggleClass(value.call(this, i2, getClass(this), stateVal), stateVal);
            });
          }
          if (typeof stateVal === "boolean" && isValidValue) {
            return stateVal ? this.addClass(value) : this.removeClass(value);
          }
          classNames = classesToArray(value);
          return this.each(function() {
            if (isValidValue) {
              self2 = jQuery(this);
              for (i = 0; i < classNames.length; i++) {
                className = classNames[i];
                if (self2.hasClass(className)) {
                  self2.removeClass(className);
                } else {
                  self2.addClass(className);
                }
              }
            } else if (value === void 0 || type === "boolean") {
              className = getClass(this);
              if (className) {
                dataPriv.set(this, "__className__", className);
              }
              if (this.setAttribute) {
                this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
              }
            }
          });
        },
        hasClass: function(selector) {
          var className, elem, i = 0;
          className = " " + selector + " ";
          while (elem = this[i++]) {
            if (elem.nodeType === 1 && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) {
              return true;
            }
          }
          return false;
        }
      });
      var rreturn = /\r/g;
      jQuery.fn.extend({
        val: function(value) {
          var hooks, ret, valueIsFunction, elem = this[0];
          if (!arguments.length) {
            if (elem) {
              hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
              if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== void 0) {
                return ret;
              }
              ret = elem.value;
              if (typeof ret === "string") {
                return ret.replace(rreturn, "");
              }
              return ret == null ? "" : ret;
            }
            return;
          }
          valueIsFunction = isFunction(value);
          return this.each(function(i) {
            var val;
            if (this.nodeType !== 1) {
              return;
            }
            if (valueIsFunction) {
              val = value.call(this, i, jQuery(this).val());
            } else {
              val = value;
            }
            if (val == null) {
              val = "";
            } else if (typeof val === "number") {
              val += "";
            } else if (Array.isArray(val)) {
              val = jQuery.map(val, function(value2) {
                return value2 == null ? "" : value2 + "";
              });
            }
            hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
            if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === void 0) {
              this.value = val;
            }
          });
        }
      });
      jQuery.extend({
        valHooks: {
          option: {
            get: function(elem) {
              var val = jQuery.find.attr(elem, "value");
              return val != null ? val : stripAndCollapse(jQuery.text(elem));
            }
          },
          select: {
            get: function(elem) {
              var value, option, i, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one", values = one ? null : [], max = one ? index + 1 : options.length;
              if (index < 0) {
                i = max;
              } else {
                i = one ? index : 0;
              }
              for (; i < max; i++) {
                option = options[i];
                if ((option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                  value = jQuery(option).val();
                  if (one) {
                    return value;
                  }
                  values.push(value);
                }
              }
              return values;
            },
            set: function(elem, value) {
              var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
              while (i--) {
                option = options[i];
                if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                  optionSet = true;
                }
              }
              if (!optionSet) {
                elem.selectedIndex = -1;
              }
              return values;
            }
          }
        }
      });
      jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
          set: function(elem, value) {
            if (Array.isArray(value)) {
              return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
            }
          }
        };
        if (!support.checkOn) {
          jQuery.valHooks[this].get = function(elem) {
            return elem.getAttribute("value") === null ? "on" : elem.value;
          };
        }
      });
      support.focusin = "onfocusin" in window2;
      var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, stopPropagationCallback = function(e) {
        e.stopPropagation();
      };
      jQuery.extend(jQuery.event, {
        trigger: function(event, data, elem, onlyHandlers) {
          var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document2], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
          cur = lastElement = tmp = elem = elem || document2;
          if (elem.nodeType === 3 || elem.nodeType === 8) {
            return;
          }
          if (rfocusMorph.test(type + jQuery.event.triggered)) {
            return;
          }
          if (type.indexOf(".") > -1) {
            namespaces = type.split(".");
            type = namespaces.shift();
            namespaces.sort();
          }
          ontype = type.indexOf(":") < 0 && "on" + type;
          event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
          event.isTrigger = onlyHandlers ? 2 : 3;
          event.namespace = namespaces.join(".");
          event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
          event.result = void 0;
          if (!event.target) {
            event.target = elem;
          }
          data = data == null ? [event] : jQuery.makeArray(data, [event]);
          special = jQuery.event.special[type] || {};
          if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
            return;
          }
          if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
            bubbleType = special.delegateType || type;
            if (!rfocusMorph.test(bubbleType + type)) {
              cur = cur.parentNode;
            }
            for (; cur; cur = cur.parentNode) {
              eventPath.push(cur);
              tmp = cur;
            }
            if (tmp === (elem.ownerDocument || document2)) {
              eventPath.push(tmp.defaultView || tmp.parentWindow || window2);
            }
          }
          i = 0;
          while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
            lastElement = cur;
            event.type = i > 1 ? bubbleType : special.bindType || type;
            handle = (dataPriv.get(cur, "events") || /* @__PURE__ */ Object.create(null))[event.type] && dataPriv.get(cur, "handle");
            if (handle) {
              handle.apply(cur, data);
            }
            handle = ontype && cur[ontype];
            if (handle && handle.apply && acceptData(cur)) {
              event.result = handle.apply(cur, data);
              if (event.result === false) {
                event.preventDefault();
              }
            }
          }
          event.type = type;
          if (!onlyHandlers && !event.isDefaultPrevented()) {
            if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
              if (ontype && isFunction(elem[type]) && !isWindow(elem)) {
                tmp = elem[ontype];
                if (tmp) {
                  elem[ontype] = null;
                }
                jQuery.event.triggered = type;
                if (event.isPropagationStopped()) {
                  lastElement.addEventListener(type, stopPropagationCallback);
                }
                elem[type]();
                if (event.isPropagationStopped()) {
                  lastElement.removeEventListener(type, stopPropagationCallback);
                }
                jQuery.event.triggered = void 0;
                if (tmp) {
                  elem[ontype] = tmp;
                }
              }
            }
          }
          return event.result;
        },
        simulate: function(type, elem, event) {
          var e = jQuery.extend(new jQuery.Event(), event, {
            type,
            isSimulated: true
          });
          jQuery.event.trigger(e, null, elem);
        }
      });
      jQuery.fn.extend({
        trigger: function(type, data) {
          return this.each(function() {
            jQuery.event.trigger(type, data, this);
          });
        },
        triggerHandler: function(type, data) {
          var elem = this[0];
          if (elem) {
            return jQuery.event.trigger(type, data, elem, true);
          }
        }
      });
      if (!support.focusin) {
        jQuery.each({ focus: "focusin", blur: "focusout" }, function(orig, fix) {
          var handler = function(event) {
            jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
          };
          jQuery.event.special[fix] = {
            setup: function() {
              var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix);
              if (!attaches) {
                doc.addEventListener(orig, handler, true);
              }
              dataPriv.access(doc, fix, (attaches || 0) + 1);
            },
            teardown: function() {
              var doc = this.ownerDocument || this.document || this, attaches = dataPriv.access(doc, fix) - 1;
              if (!attaches) {
                doc.removeEventListener(orig, handler, true);
                dataPriv.remove(doc, fix);
              } else {
                dataPriv.access(doc, fix, attaches);
              }
            }
          };
        });
      }
      var location = window2.location;
      var nonce = { guid: Date.now() };
      var rquery = /\?/;
      jQuery.parseXML = function(data) {
        var xml, parserErrorElem;
        if (!data || typeof data !== "string") {
          return null;
        }
        try {
          xml = new window2.DOMParser().parseFromString(data, "text/xml");
        } catch (e) {
        }
        parserErrorElem = xml && xml.getElementsByTagName("parsererror")[0];
        if (!xml || parserErrorElem) {
          jQuery.error("Invalid XML: " + (parserErrorElem ? jQuery.map(parserErrorElem.childNodes, function(el) {
            return el.textContent;
          }).join("\n") : data));
        }
        return xml;
      };
      var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
      function buildParams(prefix, obj, traditional, add) {
        var name;
        if (Array.isArray(obj)) {
          jQuery.each(obj, function(i, v) {
            if (traditional || rbracket.test(prefix)) {
              add(prefix, v);
            } else {
              buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
            }
          });
        } else if (!traditional && toType(obj) === "object") {
          for (name in obj) {
            buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
          }
        } else {
          add(prefix, obj);
        }
      }
      jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, valueOrFunction) {
          var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value == null ? "" : value);
        };
        if (a == null) {
          return "";
        }
        if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
          jQuery.each(a, function() {
            add(this.name, this.value);
          });
        } else {
          for (prefix in a) {
            buildParams(prefix, a[prefix], traditional, add);
          }
        }
        return s.join("&");
      };
      jQuery.fn.extend({
        serialize: function() {
          return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
          return this.map(function() {
            var elements = jQuery.prop(this, "elements");
            return elements ? jQuery.makeArray(elements) : this;
          }).filter(function() {
            var type = this.type;
            return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
          }).map(function(_i, elem) {
            var val = jQuery(this).val();
            if (val == null) {
              return null;
            }
            if (Array.isArray(val)) {
              return jQuery.map(val, function(val2) {
                return { name: elem.name, value: val2.replace(rCRLF, "\r\n") };
              });
            }
            return { name: elem.name, value: val.replace(rCRLF, "\r\n") };
          }).get();
        }
      });
      var r20 = /%20/g, rhash = /#.*$/, rantiCache = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document2.createElement("a");
      originAnchor.href = location.href;
      function addToPrefiltersOrTransports(structure) {
        return function(dataTypeExpression, func) {
          if (typeof dataTypeExpression !== "string") {
            func = dataTypeExpression;
            dataTypeExpression = "*";
          }
          var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
          if (isFunction(func)) {
            while (dataType = dataTypes[i++]) {
              if (dataType[0] === "+") {
                dataType = dataType.slice(1) || "*";
                (structure[dataType] = structure[dataType] || []).unshift(func);
              } else {
                (structure[dataType] = structure[dataType] || []).push(func);
              }
            }
          }
        };
      }
      function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
        var inspected = {}, seekingTransport = structure === transports;
        function inspect(dataType) {
          var selected;
          inspected[dataType] = true;
          jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
            var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
            if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
              options.dataTypes.unshift(dataTypeOrTransport);
              inspect(dataTypeOrTransport);
              return false;
            } else if (seekingTransport) {
              return !(selected = dataTypeOrTransport);
            }
          });
          return selected;
        }
        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
      }
      function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
        for (key in src) {
          if (src[key] !== void 0) {
            (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
          }
        }
        if (deep) {
          jQuery.extend(true, target, deep);
        }
        return target;
      }
      function ajaxHandleResponses(s, jqXHR, responses) {
        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
        while (dataTypes[0] === "*") {
          dataTypes.shift();
          if (ct === void 0) {
            ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
          }
        }
        if (ct) {
          for (type in contents) {
            if (contents[type] && contents[type].test(ct)) {
              dataTypes.unshift(type);
              break;
            }
          }
        }
        if (dataTypes[0] in responses) {
          finalDataType = dataTypes[0];
        } else {
          for (type in responses) {
            if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
              finalDataType = type;
              break;
            }
            if (!firstDataType) {
              firstDataType = type;
            }
          }
          finalDataType = finalDataType || firstDataType;
        }
        if (finalDataType) {
          if (finalDataType !== dataTypes[0]) {
            dataTypes.unshift(finalDataType);
          }
          return responses[finalDataType];
        }
      }
      function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
        if (dataTypes[1]) {
          for (conv in s.converters) {
            converters[conv.toLowerCase()] = s.converters[conv];
          }
        }
        current = dataTypes.shift();
        while (current) {
          if (s.responseFields[current]) {
            jqXHR[s.responseFields[current]] = response;
          }
          if (!prev && isSuccess && s.dataFilter) {
            response = s.dataFilter(response, s.dataType);
          }
          prev = current;
          current = dataTypes.shift();
          if (current) {
            if (current === "*") {
              current = prev;
            } else if (prev !== "*" && prev !== current) {
              conv = converters[prev + " " + current] || converters["* " + current];
              if (!conv) {
                for (conv2 in converters) {
                  tmp = conv2.split(" ");
                  if (tmp[1] === current) {
                    conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                    if (conv) {
                      if (conv === true) {
                        conv = converters[conv2];
                      } else if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                      break;
                    }
                  }
                }
              }
              if (conv !== true) {
                if (conv && s.throws) {
                  response = conv(response);
                } else {
                  try {
                    response = conv(response);
                  } catch (e) {
                    return {
                      state: "parsererror",
                      error: conv ? e : "No conversion from " + prev + " to " + current
                    };
                  }
                }
              }
            }
          }
        }
        return { state: "success", data: response };
      }
      jQuery.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
          url: location.href,
          type: "GET",
          isLocal: rlocalProtocol.test(location.protocol),
          global: true,
          processData: true,
          async: true,
          contentType: "application/x-www-form-urlencoded; charset=UTF-8",
          accepts: {
            "*": allTypes,
            text: "text/plain",
            html: "text/html",
            xml: "application/xml, text/xml",
            json: "application/json, text/javascript"
          },
          contents: {
            xml: /\bxml\b/,
            html: /\bhtml/,
            json: /\bjson\b/
          },
          responseFields: {
            xml: "responseXML",
            text: "responseText",
            json: "responseJSON"
          },
          converters: {
            "* text": String,
            "text html": true,
            "text json": JSON.parse,
            "text xml": jQuery.parseXML
          },
          flatOptions: {
            url: true,
            context: true
          }
        },
        ajaxSetup: function(target, settings) {
          return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
        },
        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),
        ajax: function(url, options) {
          if (typeof url === "object") {
            options = url;
            url = void 0;
          }
          options = options || {};
          var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed2, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (completed2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while (match = rheaders.exec(responseHeadersString)) {
                    responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                  }
                }
                match = responseHeaders[key.toLowerCase() + " "];
              }
              return match == null ? null : match.join(", ");
            },
            getAllResponseHeaders: function() {
              return completed2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              if (completed2 == null) {
                name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (completed2 == null) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (completed2) {
                  jqXHR.always(map[jqXHR.status]);
                } else {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
          deferred.promise(jqXHR);
          s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//");
          s.type = options.method || options.type || s.method || s.type;
          s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""];
          if (s.crossDomain == null) {
            urlAnchor = document2.createElement("a");
            try {
              urlAnchor.href = s.url;
              urlAnchor.href = urlAnchor.href;
              s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
            } catch (e) {
              s.crossDomain = true;
            }
          }
          if (s.data && s.processData && typeof s.data !== "string") {
            s.data = jQuery.param(s.data, s.traditional);
          }
          inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
          if (completed2) {
            return jqXHR;
          }
          fireGlobals = jQuery.event && s.global;
          if (fireGlobals && jQuery.active++ === 0) {
            jQuery.event.trigger("ajaxStart");
          }
          s.type = s.type.toUpperCase();
          s.hasContent = !rnoContent.test(s.type);
          cacheURL = s.url.replace(rhash, "");
          if (!s.hasContent) {
            uncached = s.url.slice(cacheURL.length);
            if (s.data && (s.processData || typeof s.data === "string")) {
              cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data;
              delete s.data;
            }
            if (s.cache === false) {
              cacheURL = cacheURL.replace(rantiCache, "$1");
              uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached;
            }
            s.url = cacheURL + uncached;
          } else if (s.data && s.processData && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0) {
            s.data = s.data.replace(r20, "+");
          }
          if (s.ifModified) {
            if (jQuery.lastModified[cacheURL]) {
              jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
            }
            if (jQuery.etag[cacheURL]) {
              jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
            }
          }
          if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
            jqXHR.setRequestHeader("Content-Type", s.contentType);
          }
          jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
          for (i in s.headers) {
            jqXHR.setRequestHeader(i, s.headers[i]);
          }
          if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed2)) {
            return jqXHR.abort();
          }
          strAbort = "abort";
          completeDeferred.add(s.complete);
          jqXHR.done(s.success);
          jqXHR.fail(s.error);
          transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
          if (!transport) {
            done(-1, "No Transport");
          } else {
            jqXHR.readyState = 1;
            if (fireGlobals) {
              globalEventContext.trigger("ajaxSend", [jqXHR, s]);
            }
            if (completed2) {
              return jqXHR;
            }
            if (s.async && s.timeout > 0) {
              timeoutTimer = window2.setTimeout(function() {
                jqXHR.abort("timeout");
              }, s.timeout);
            }
            try {
              completed2 = false;
              transport.send(requestHeaders, done);
            } catch (e) {
              if (completed2) {
                throw e;
              }
              done(-1, e);
            }
          }
          function done(status, nativeStatusText, responses, headers) {
            var isSuccess, success, error, response, modified, statusText = nativeStatusText;
            if (completed2) {
              return;
            }
            completed2 = true;
            if (timeoutTimer) {
              window2.clearTimeout(timeoutTimer);
            }
            transport = void 0;
            responseHeadersString = headers || "";
            jqXHR.readyState = status > 0 ? 4 : 0;
            isSuccess = status >= 200 && status < 300 || status === 304;
            if (responses) {
              response = ajaxHandleResponses(s, jqXHR, responses);
            }
            if (!isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && jQuery.inArray("json", s.dataTypes) < 0) {
              s.converters["text script"] = function() {
              };
            }
            response = ajaxConvert(s, response, jqXHR, isSuccess);
            if (isSuccess) {
              if (s.ifModified) {
                modified = jqXHR.getResponseHeader("Last-Modified");
                if (modified) {
                  jQuery.lastModified[cacheURL] = modified;
                }
                modified = jqXHR.getResponseHeader("etag");
                if (modified) {
                  jQuery.etag[cacheURL] = modified;
                }
              }
              if (status === 204 || s.type === "HEAD") {
                statusText = "nocontent";
              } else if (status === 304) {
                statusText = "notmodified";
              } else {
                statusText = response.state;
                success = response.data;
                error = response.error;
                isSuccess = !error;
              }
            } else {
              error = statusText;
              if (status || !statusText) {
                statusText = "error";
                if (status < 0) {
                  status = 0;
                }
              }
            }
            jqXHR.status = status;
            jqXHR.statusText = (nativeStatusText || statusText) + "";
            if (isSuccess) {
              deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
            } else {
              deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
            }
            jqXHR.statusCode(statusCode);
            statusCode = void 0;
            if (fireGlobals) {
              globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
            }
            completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
            if (fireGlobals) {
              globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
              if (!--jQuery.active) {
                jQuery.event.trigger("ajaxStop");
              }
            }
          }
          return jqXHR;
        },
        getJSON: function(url, data, callback) {
          return jQuery.get(url, data, callback, "json");
        },
        getScript: function(url, callback) {
          return jQuery.get(url, void 0, callback, "script");
        }
      });
      jQuery.each(["get", "post"], function(_i, method) {
        jQuery[method] = function(url, data, callback, type) {
          if (isFunction(data)) {
            type = type || callback;
            callback = data;
            data = void 0;
          }
          return jQuery.ajax(jQuery.extend({
            url,
            type: method,
            dataType: type,
            data,
            success: callback
          }, jQuery.isPlainObject(url) && url));
        };
      });
      jQuery.ajaxPrefilter(function(s) {
        var i;
        for (i in s.headers) {
          if (i.toLowerCase() === "content-type") {
            s.contentType = s.headers[i] || "";
          }
        }
      });
      jQuery._evalUrl = function(url, options, doc) {
        return jQuery.ajax({
          url,
          type: "GET",
          dataType: "script",
          cache: true,
          async: false,
          global: false,
          converters: {
            "text script": function() {
            }
          },
          dataFilter: function(response) {
            jQuery.globalEval(response, options, doc);
          }
        });
      };
      jQuery.fn.extend({
        wrapAll: function(html) {
          var wrap;
          if (this[0]) {
            if (isFunction(html)) {
              html = html.call(this[0]);
            }
            wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
            if (this[0].parentNode) {
              wrap.insertBefore(this[0]);
            }
            wrap.map(function() {
              var elem = this;
              while (elem.firstElementChild) {
                elem = elem.firstElementChild;
              }
              return elem;
            }).append(this);
          }
          return this;
        },
        wrapInner: function(html) {
          if (isFunction(html)) {
            return this.each(function(i) {
              jQuery(this).wrapInner(html.call(this, i));
            });
          }
          return this.each(function() {
            var self2 = jQuery(this), contents = self2.contents();
            if (contents.length) {
              contents.wrapAll(html);
            } else {
              self2.append(html);
            }
          });
        },
        wrap: function(html) {
          var htmlIsFunction = isFunction(html);
          return this.each(function(i) {
            jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html);
          });
        },
        unwrap: function(selector) {
          this.parent(selector).not("body").each(function() {
            jQuery(this).replaceWith(this.childNodes);
          });
          return this;
        }
      });
      jQuery.expr.pseudos.hidden = function(elem) {
        return !jQuery.expr.pseudos.visible(elem);
      };
      jQuery.expr.pseudos.visible = function(elem) {
        return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length);
      };
      jQuery.ajaxSettings.xhr = function() {
        try {
          return new window2.XMLHttpRequest();
        } catch (e) {
        }
      };
      var xhrSuccessStatus = {
        0: 200,
        1223: 204
      }, xhrSupported = jQuery.ajaxSettings.xhr();
      support.cors = !!xhrSupported && "withCredentials" in xhrSupported;
      support.ajax = xhrSupported = !!xhrSupported;
      jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;
        if (support.cors || xhrSupported && !options.crossDomain) {
          return {
            send: function(headers, complete) {
              var i, xhr = options.xhr();
              xhr.open(options.type, options.url, options.async, options.username, options.password);
              if (options.xhrFields) {
                for (i in options.xhrFields) {
                  xhr[i] = options.xhrFields[i];
                }
              }
              if (options.mimeType && xhr.overrideMimeType) {
                xhr.overrideMimeType(options.mimeType);
              }
              if (!options.crossDomain && !headers["X-Requested-With"]) {
                headers["X-Requested-With"] = "XMLHttpRequest";
              }
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
              callback = function(type) {
                return function() {
                  if (callback) {
                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null;
                    if (type === "abort") {
                      xhr.abort();
                    } else if (type === "error") {
                      if (typeof xhr.status !== "number") {
                        complete(0, "error");
                      } else {
                        complete(xhr.status, xhr.statusText);
                      }
                    } else {
                      complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                    }
                  }
                };
              };
              xhr.onload = callback();
              errorCallback = xhr.onerror = xhr.ontimeout = callback("error");
              if (xhr.onabort !== void 0) {
                xhr.onabort = errorCallback;
              } else {
                xhr.onreadystatechange = function() {
                  if (xhr.readyState === 4) {
                    window2.setTimeout(function() {
                      if (callback) {
                        errorCallback();
                      }
                    });
                  }
                };
              }
              callback = callback("abort");
              try {
                xhr.send(options.hasContent && options.data || null);
              } catch (e) {
                if (callback) {
                  throw e;
                }
              }
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      jQuery.ajaxPrefilter(function(s) {
        if (s.crossDomain) {
          s.contents.script = false;
        }
      });
      jQuery.ajaxSetup({
        accepts: {
          script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
          script: /\b(?:java|ecma)script\b/
        },
        converters: {
          "text script": function(text) {
            jQuery.globalEval(text);
            return text;
          }
        }
      });
      jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === void 0) {
          s.cache = false;
        }
        if (s.crossDomain) {
          s.type = "GET";
        }
      });
      jQuery.ajaxTransport("script", function(s) {
        if (s.crossDomain || s.scriptAttrs) {
          var script, callback;
          return {
            send: function(_, complete) {
              script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({ charset: s.scriptCharset, src: s.url }).on("load error", callback = function(evt) {
                script.remove();
                callback = null;
                if (evt) {
                  complete(evt.type === "error" ? 404 : 200, evt.type);
                }
              });
              document2.head.appendChild(script[0]);
            },
            abort: function() {
              if (callback) {
                callback();
              }
            }
          };
        }
      });
      var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
      jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
          var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
          this[callback] = true;
          return callback;
        }
      });
      jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
        if (jsonProp || s.dataTypes[0] === "jsonp") {
          callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
          if (jsonProp) {
            s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
          } else if (s.jsonp !== false) {
            s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
          }
          s.converters["script json"] = function() {
            if (!responseContainer) {
              jQuery.error(callbackName + " was not called");
            }
            return responseContainer[0];
          };
          s.dataTypes[0] = "json";
          overwritten = window2[callbackName];
          window2[callbackName] = function() {
            responseContainer = arguments;
          };
          jqXHR.always(function() {
            if (overwritten === void 0) {
              jQuery(window2).removeProp(callbackName);
            } else {
              window2[callbackName] = overwritten;
            }
            if (s[callbackName]) {
              s.jsonpCallback = originalSettings.jsonpCallback;
              oldCallbacks.push(callbackName);
            }
            if (responseContainer && isFunction(overwritten)) {
              overwritten(responseContainer[0]);
            }
            responseContainer = overwritten = void 0;
          });
          return "script";
        }
      });
      support.createHTMLDocument = function() {
        var body = document2.implementation.createHTMLDocument("").body;
        body.innerHTML = "<form></form><form></form>";
        return body.childNodes.length === 2;
      }();
      jQuery.parseHTML = function(data, context, keepScripts) {
        if (typeof data !== "string") {
          return [];
        }
        if (typeof context === "boolean") {
          keepScripts = context;
          context = false;
        }
        var base, parsed, scripts;
        if (!context) {
          if (support.createHTMLDocument) {
            context = document2.implementation.createHTMLDocument("");
            base = context.createElement("base");
            base.href = document2.location.href;
            context.head.appendChild(base);
          } else {
            context = document2;
          }
        }
        parsed = rsingleTag.exec(data);
        scripts = !keepScripts && [];
        if (parsed) {
          return [context.createElement(parsed[1])];
        }
        parsed = buildFragment([data], context, scripts);
        if (scripts && scripts.length) {
          jQuery(scripts).remove();
        }
        return jQuery.merge([], parsed.childNodes);
      };
      jQuery.fn.load = function(url, params, callback) {
        var selector, type, response, self2 = this, off = url.indexOf(" ");
        if (off > -1) {
          selector = stripAndCollapse(url.slice(off));
          url = url.slice(0, off);
        }
        if (isFunction(params)) {
          callback = params;
          params = void 0;
        } else if (params && typeof params === "object") {
          type = "POST";
        }
        if (self2.length > 0) {
          jQuery.ajax({
            url,
            type: type || "GET",
            dataType: "html",
            data: params
          }).done(function(responseText) {
            response = arguments;
            self2.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
          }).always(callback && function(jqXHR, status) {
            self2.each(function() {
              callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
            });
          });
        }
        return this;
      };
      jQuery.expr.pseudos.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
          return elem === fn.elem;
        }).length;
      };
      jQuery.offset = {
        setOffset: function(elem, options, i) {
          var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
          if (position === "static") {
            elem.style.position = "relative";
          }
          curOffset = curElem.offset();
          curCSSTop = jQuery.css(elem, "top");
          curCSSLeft = jQuery.css(elem, "left");
          calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
          if (calculatePosition) {
            curPosition = curElem.position();
            curTop = curPosition.top;
            curLeft = curPosition.left;
          } else {
            curTop = parseFloat(curCSSTop) || 0;
            curLeft = parseFloat(curCSSLeft) || 0;
          }
          if (isFunction(options)) {
            options = options.call(elem, i, jQuery.extend({}, curOffset));
          }
          if (options.top != null) {
            props.top = options.top - curOffset.top + curTop;
          }
          if (options.left != null) {
            props.left = options.left - curOffset.left + curLeft;
          }
          if ("using" in options) {
            options.using.call(elem, props);
          } else {
            curElem.css(props);
          }
        }
      };
      jQuery.fn.extend({
        offset: function(options) {
          if (arguments.length) {
            return options === void 0 ? this : this.each(function(i) {
              jQuery.offset.setOffset(this, options, i);
            });
          }
          var rect, win, elem = this[0];
          if (!elem) {
            return;
          }
          if (!elem.getClientRects().length) {
            return { top: 0, left: 0 };
          }
          rect = elem.getBoundingClientRect();
          win = elem.ownerDocument.defaultView;
          return {
            top: rect.top + win.pageYOffset,
            left: rect.left + win.pageXOffset
          };
        },
        position: function() {
          if (!this[0]) {
            return;
          }
          var offsetParent, offset, doc, elem = this[0], parentOffset = { top: 0, left: 0 };
          if (jQuery.css(elem, "position") === "fixed") {
            offset = elem.getBoundingClientRect();
          } else {
            offset = this.offset();
            doc = elem.ownerDocument;
            offsetParent = elem.offsetParent || doc.documentElement;
            while (offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.parentNode;
            }
            if (offsetParent && offsetParent !== elem && offsetParent.nodeType === 1) {
              parentOffset = jQuery(offsetParent).offset();
              parentOffset.top += jQuery.css(offsetParent, "borderTopWidth", true);
              parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", true);
            }
          }
          return {
            top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
            left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
          };
        },
        offsetParent: function() {
          return this.map(function() {
            var offsetParent = this.offsetParent;
            while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
              offsetParent = offsetParent.offsetParent;
            }
            return offsetParent || documentElement;
          });
        }
      });
      jQuery.each({ scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function(method, prop) {
        var top = prop === "pageYOffset";
        jQuery.fn[method] = function(val) {
          return access(this, function(elem, method2, val2) {
            var win;
            if (isWindow(elem)) {
              win = elem;
            } else if (elem.nodeType === 9) {
              win = elem.defaultView;
            }
            if (val2 === void 0) {
              return win ? win[prop] : elem[method2];
            }
            if (win) {
              win.scrollTo(!top ? val2 : win.pageXOffset, top ? val2 : win.pageYOffset);
            } else {
              elem[method2] = val2;
            }
          }, method, val, arguments.length);
        };
      });
      jQuery.each(["top", "left"], function(_i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
          if (computed) {
            computed = curCSS(elem, prop);
            return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
          }
        });
      });
      jQuery.each({ Height: "height", Width: "width" }, function(name, type) {
        jQuery.each({
          padding: "inner" + name,
          content: type,
          "": "outer" + name
        }, function(defaultExtra, funcName) {
          jQuery.fn[funcName] = function(margin, value) {
            var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"), extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
            return access(this, function(elem, type2, value2) {
              var doc;
              if (isWindow(elem)) {
                return funcName.indexOf("outer") === 0 ? elem["inner" + name] : elem.document.documentElement["client" + name];
              }
              if (elem.nodeType === 9) {
                doc = elem.documentElement;
                return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
              }
              return value2 === void 0 ? jQuery.css(elem, type2, extra) : jQuery.style(elem, type2, value2, extra);
            }, type, chainable ? margin : void 0, chainable);
          };
        });
      });
      jQuery.each([
        "ajaxStart",
        "ajaxStop",
        "ajaxComplete",
        "ajaxError",
        "ajaxSuccess",
        "ajaxSend"
      ], function(_i, type) {
        jQuery.fn[type] = function(fn) {
          return this.on(type, fn);
        };
      });
      jQuery.fn.extend({
        bind: function(types, data, fn) {
          return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
          return this.off(types, null, fn);
        },
        delegate: function(selector, types, data, fn) {
          return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {
          return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        hover: function(fnOver, fnOut) {
          return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
      });
      jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function(_i, name) {
        jQuery.fn[name] = function(data, fn) {
          return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        };
      });
      var rtrim = /^[\s\uFEFF\xA0]+|([^\s\uFEFF\xA0])[\s\uFEFF\xA0]+$/g;
      jQuery.proxy = function(fn, context) {
        var tmp, args, proxy;
        if (typeof context === "string") {
          tmp = fn[context];
          context = fn;
          fn = tmp;
        }
        if (!isFunction(fn)) {
          return void 0;
        }
        args = slice.call(arguments, 2);
        proxy = function() {
          return fn.apply(context || this, args.concat(slice.call(arguments)));
        };
        proxy.guid = fn.guid = fn.guid || jQuery.guid++;
        return proxy;
      };
      jQuery.holdReady = function(hold) {
        if (hold) {
          jQuery.readyWait++;
        } else {
          jQuery.ready(true);
        }
      };
      jQuery.isArray = Array.isArray;
      jQuery.parseJSON = JSON.parse;
      jQuery.nodeName = nodeName;
      jQuery.isFunction = isFunction;
      jQuery.isWindow = isWindow;
      jQuery.camelCase = camelCase;
      jQuery.type = toType;
      jQuery.now = Date.now;
      jQuery.isNumeric = function(obj) {
        var type = jQuery.type(obj);
        return (type === "number" || type === "string") && !isNaN(obj - parseFloat(obj));
      };
      jQuery.trim = function(text) {
        return text == null ? "" : (text + "").replace(rtrim, "$1");
      };
      if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
          return jQuery;
        });
      }
      var _jQuery = window2.jQuery, _$ = window2.$;
      jQuery.noConflict = function(deep) {
        if (window2.$ === jQuery) {
          window2.$ = _$;
        }
        if (deep && window2.jQuery === jQuery) {
          window2.jQuery = _jQuery;
        }
        return jQuery;
      };
      if (typeof noGlobal === "undefined") {
        window2.jQuery = window2.$ = jQuery;
      }
      return jQuery;
    });
  }
});

// ../pk-lib/dist/pklib.js
var require_pklib = __commonJS({
  "../pk-lib/dist/pklib.js"(exports, module2) {
    "use strict";
    var fs$3 = require_lib();
    var require$$0$1 = require("node:fs");
    var require$$4 = require("node:path");
    var require$$3 = require("node:events");
    var require$$5 = require("node:assert");
    require("node:util");
    var Filesize = require_filesize();
    var frontMatter = require_front_matter();
    var require$$8 = require("node:punycode");
    var jquery = require_jquery();
    function _interopNamespaceDefault(e) {
      var n = /* @__PURE__ */ Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n.default = e;
      return Object.freeze(n);
    }
    function _mergeNamespaces(n, m) {
      m.forEach(function(e) {
        e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
          if (k !== "default" && !(k in n)) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      });
      return Object.freeze(n);
    }
    var Filesize__namespace = /* @__PURE__ */ _interopNamespaceDefault(Filesize);
    var timeout = (time = 0) => new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, time);
    });
    var Global = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      timeout
    });
    var Crypto$2 = class Crypto {
      constructor() {
        __publicField(this, "lib");
        __publicField(this, "encrypt", async (plaintext, password) => {
          const pwUtf8 = new TextEncoder().encode(password);
          const pwHash = await this.lib.subtle.digest("SHA-256", pwUtf8);
          const iv = this.lib.getRandomValues(new Uint8Array(12));
          const ivStr = Array.from(iv).map((b) => String.fromCharCode(b)).join("");
          const alg = { name: "AES-GCM", iv };
          const key = await this.lib.subtle.importKey("raw", pwHash, alg, false, [
            "encrypt"
          ]);
          const ptUint8 = new TextEncoder().encode(plaintext);
          const ctBuffer = await this.lib.subtle.encrypt(alg, key, ptUint8);
          const ctArray = Array.from(new Uint8Array(ctBuffer));
          const ctStr = ctArray.map((byte) => String.fromCharCode(byte)).join("");
          return btoa(ivStr + ctStr);
        });
        __publicField(this, "decrypt", async (ciphertext, password) => {
          const pwUtf8 = new TextEncoder().encode(password);
          const pwHash = await this.lib.subtle.digest("SHA-256", pwUtf8);
          const ivStr = atob(ciphertext).slice(0, 12);
          const iv = new Uint8Array(Array.from(ivStr).map((ch) => ch.charCodeAt(0)));
          const alg = { name: "AES-GCM", iv };
          const key = await this.lib.subtle.importKey("raw", pwHash, alg, false, [
            "decrypt"
          ]);
          const ctStr = atob(ciphertext).slice(12);
          const ctUint8 = new Uint8Array(Array.from(ctStr).map((ch) => ch.charCodeAt(0)));
          try {
            const plainBuffer = await this.lib.subtle.decrypt(alg, key, ctUint8);
            return new TextDecoder().decode(plainBuffer);
          } catch (error) {
            throw new Error("decrypt failed");
          }
        });
        try {
          this.lib = window.crypto;
        } catch (e) {
        }
      }
    };
    var Crypto = new Crypto$2();
    var setLib = (lib2) => {
      Crypto.lib = lib2;
    };
    var encrypt = async (body2, pwd) => {
      return Crypto.encrypt(body2, pwd);
    };
    var decrypt = async (body2, pwd) => {
      return Crypto.decrypt(body2, pwd);
    };
    var sha256 = async function(text2) {
      const encoder = new TextEncoder();
      const data = encoder.encode(text2);
      const hash = await Crypto.lib.subtle.digest("SHA-256", data);
      return Array.from(new Uint8Array(hash)).map((b) => b.toString(16).padStart(2, "0")).join("");
    };
    var getHash = async (text2) => {
      return (await sha256(text2)).slice(0, 32);
    };
    var Crypto$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setLib,
      encrypt,
      decrypt,
      sha256,
      getHash
    });
    require_jquery();
    var asArray = (input, { delim = ",", trim = true, uniq = true, compact = true } = {}) => {
      if (!input)
        return [];
      let output2 = typeof input == "string" ? input.split(delim) : input || [];
      if (trim)
        output2 = output2.map((v) => {
          var _a;
          return ((_a = v == null ? void 0 : v.trim) == null ? void 0 : _a.call(v)) || v;
        });
      if (compact)
        output2 = output2.filter(Boolean);
      if (uniq)
        output2 = [...new Set(output2)];
      return output2;
    };
    var unique = (array) => {
      var a = array.concat();
      for (var i2 = 0; i2 < a.length; ++i2) {
        for (var j = i2 + 1; j < a.length; ++j) {
          if (a[i2] === a[j])
            a.splice(j--, 1);
        }
      }
      return a;
    };
    var clean = (array) => unique(array.flat().filter(Boolean));
    var Array$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      asArray,
      unique,
      clean
    });
    var isObject$1 = (item) => {
      return item && typeof item === "object" && !Array.isArray(item);
    };
    var merge = (target2, ...sources) => {
      if (!sources.length)
        return target2;
      const source = sources.shift();
      if (isObject$1(target2) && isObject$1(source)) {
        for (const key in source) {
          if (isObject$1(source[key])) {
            if (!target2[key])
              Object.assign(target2, { [key]: {} });
            merge(target2[key], source[key]);
          } else {
            Object.assign(target2, { [key]: source[key] });
          }
        }
      }
      return merge(target2, ...sources);
    };
    var get = (obj, path2) => path2.split(".").reduce((acc, part2) => acc && acc[part2], obj);
    var put = (obj, path2, val) => {
      function stringToPath(path3) {
        if (typeof path3 !== "string")
          return path3;
        let output2 = [];
        path3.split(".").forEach(function(item) {
          item.split(/\[([^}]+)\]/g).forEach(function(key) {
            if (key.length > 0)
              output2.push(key);
          });
        });
        return output2;
      }
      path2 = stringToPath(path2);
      let length = path2.length;
      let current = obj;
      path2.forEach(function(key, index) {
        let isArray = key.slice(-2) === "[]";
        key = isArray ? key.slice(0, -2) : key;
        if (isArray && !Array.isArray(current[key]))
          current[key] = [];
        if (index === length - 1) {
          if (isArray)
            current[key].push(val);
          else
            current[key] = val;
        } else {
          if (!current[key])
            current[key] = {};
          current = current[key];
        }
      });
    };
    var clone = (o, del) => {
      const remove2 = del ? asArray(del) : [];
      const copy2 = JSON.parse(JSON.stringify(o));
      remove2.forEach((k) => delete copy2[k]);
      return copy2;
    };
    var Object$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isObject: isObject$1,
      merge,
      get,
      put,
      clone
    });
    var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
    function getDefaultExportFromCjs(x) {
      return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
    }
    var jsExports = {};
    var js$1 = {
      get exports() {
        return jsExports;
      },
      set exports(v) {
        jsExports = v;
      }
    };
    var src = {};
    var javascriptExports = {};
    var javascript = {
      get exports() {
        return javascriptExports;
      },
      set exports(v) {
        javascriptExports = v;
      }
    };
    var beautifier$2 = {};
    var output = {};
    var hasRequiredOutput;
    function requireOutput() {
      if (hasRequiredOutput)
        return output;
      hasRequiredOutput = 1;
      function OutputLine(parent) {
        this.__parent = parent;
        this.__character_count = 0;
        this.__indent_count = -1;
        this.__alignment_count = 0;
        this.__wrap_point_index = 0;
        this.__wrap_point_character_count = 0;
        this.__wrap_point_indent_count = -1;
        this.__wrap_point_alignment_count = 0;
        this.__items = [];
      }
      OutputLine.prototype.clone_empty = function() {
        var line = new OutputLine(this.__parent);
        line.set_indent(this.__indent_count, this.__alignment_count);
        return line;
      };
      OutputLine.prototype.item = function(index) {
        if (index < 0) {
          return this.__items[this.__items.length + index];
        } else {
          return this.__items[index];
        }
      };
      OutputLine.prototype.has_match = function(pattern2) {
        for (var lastCheckedOutput = this.__items.length - 1; lastCheckedOutput >= 0; lastCheckedOutput--) {
          if (this.__items[lastCheckedOutput].match(pattern2)) {
            return true;
          }
        }
        return false;
      };
      OutputLine.prototype.set_indent = function(indent, alignment) {
        if (this.is_empty()) {
          this.__indent_count = indent || 0;
          this.__alignment_count = alignment || 0;
          this.__character_count = this.__parent.get_indent_size(this.__indent_count, this.__alignment_count);
        }
      };
      OutputLine.prototype._set_wrap_point = function() {
        if (this.__parent.wrap_line_length) {
          this.__wrap_point_index = this.__items.length;
          this.__wrap_point_character_count = this.__character_count;
          this.__wrap_point_indent_count = this.__parent.next_line.__indent_count;
          this.__wrap_point_alignment_count = this.__parent.next_line.__alignment_count;
        }
      };
      OutputLine.prototype._should_wrap = function() {
        return this.__wrap_point_index && this.__character_count > this.__parent.wrap_line_length && this.__wrap_point_character_count > this.__parent.next_line.__character_count;
      };
      OutputLine.prototype._allow_wrap = function() {
        if (this._should_wrap()) {
          this.__parent.add_new_line();
          var next = this.__parent.current_line;
          next.set_indent(this.__wrap_point_indent_count, this.__wrap_point_alignment_count);
          next.__items = this.__items.slice(this.__wrap_point_index);
          this.__items = this.__items.slice(0, this.__wrap_point_index);
          next.__character_count += this.__character_count - this.__wrap_point_character_count;
          this.__character_count = this.__wrap_point_character_count;
          if (next.__items[0] === " ") {
            next.__items.splice(0, 1);
            next.__character_count -= 1;
          }
          return true;
        }
        return false;
      };
      OutputLine.prototype.is_empty = function() {
        return this.__items.length === 0;
      };
      OutputLine.prototype.last = function() {
        if (!this.is_empty()) {
          return this.__items[this.__items.length - 1];
        } else {
          return null;
        }
      };
      OutputLine.prototype.push = function(item) {
        this.__items.push(item);
        var last_newline_index = item.lastIndexOf("\n");
        if (last_newline_index !== -1) {
          this.__character_count = item.length - last_newline_index;
        } else {
          this.__character_count += item.length;
        }
      };
      OutputLine.prototype.pop = function() {
        var item = null;
        if (!this.is_empty()) {
          item = this.__items.pop();
          this.__character_count -= item.length;
        }
        return item;
      };
      OutputLine.prototype._remove_indent = function() {
        if (this.__indent_count > 0) {
          this.__indent_count -= 1;
          this.__character_count -= this.__parent.indent_size;
        }
      };
      OutputLine.prototype._remove_wrap_indent = function() {
        if (this.__wrap_point_indent_count > 0) {
          this.__wrap_point_indent_count -= 1;
        }
      };
      OutputLine.prototype.trim = function() {
        while (this.last() === " ") {
          this.__items.pop();
          this.__character_count -= 1;
        }
      };
      OutputLine.prototype.toString = function() {
        var result = "";
        if (this.is_empty()) {
          if (this.__parent.indent_empty_lines) {
            result = this.__parent.get_indent_string(this.__indent_count);
          }
        } else {
          result = this.__parent.get_indent_string(this.__indent_count, this.__alignment_count);
          result += this.__items.join("");
        }
        return result;
      };
      function IndentStringCache(options2, baseIndentString) {
        this.__cache = [""];
        this.__indent_size = options2.indent_size;
        this.__indent_string = options2.indent_char;
        if (!options2.indent_with_tabs) {
          this.__indent_string = new Array(options2.indent_size + 1).join(options2.indent_char);
        }
        baseIndentString = baseIndentString || "";
        if (options2.indent_level > 0) {
          baseIndentString = new Array(options2.indent_level + 1).join(this.__indent_string);
        }
        this.__base_string = baseIndentString;
        this.__base_string_length = baseIndentString.length;
      }
      IndentStringCache.prototype.get_indent_size = function(indent, column) {
        var result = this.__base_string_length;
        column = column || 0;
        if (indent < 0) {
          result = 0;
        }
        result += indent * this.__indent_size;
        result += column;
        return result;
      };
      IndentStringCache.prototype.get_indent_string = function(indent_level, column) {
        var result = this.__base_string;
        column = column || 0;
        if (indent_level < 0) {
          indent_level = 0;
          result = "";
        }
        column += indent_level * this.__indent_size;
        this.__ensure_cache(column);
        result += this.__cache[column];
        return result;
      };
      IndentStringCache.prototype.__ensure_cache = function(column) {
        while (column >= this.__cache.length) {
          this.__add_column();
        }
      };
      IndentStringCache.prototype.__add_column = function() {
        var column = this.__cache.length;
        var indent = 0;
        var result = "";
        if (this.__indent_size && column >= this.__indent_size) {
          indent = Math.floor(column / this.__indent_size);
          column -= indent * this.__indent_size;
          result = new Array(indent + 1).join(this.__indent_string);
        }
        if (column) {
          result += new Array(column + 1).join(" ");
        }
        this.__cache.push(result);
      };
      function Output(options2, baseIndentString) {
        this.__indent_cache = new IndentStringCache(options2, baseIndentString);
        this.raw = false;
        this._end_with_newline = options2.end_with_newline;
        this.indent_size = options2.indent_size;
        this.wrap_line_length = options2.wrap_line_length;
        this.indent_empty_lines = options2.indent_empty_lines;
        this.__lines = [];
        this.previous_line = null;
        this.current_line = null;
        this.next_line = new OutputLine(this);
        this.space_before_token = false;
        this.non_breaking_space = false;
        this.previous_token_wrapped = false;
        this.__add_outputline();
      }
      Output.prototype.__add_outputline = function() {
        this.previous_line = this.current_line;
        this.current_line = this.next_line.clone_empty();
        this.__lines.push(this.current_line);
      };
      Output.prototype.get_line_number = function() {
        return this.__lines.length;
      };
      Output.prototype.get_indent_string = function(indent, column) {
        return this.__indent_cache.get_indent_string(indent, column);
      };
      Output.prototype.get_indent_size = function(indent, column) {
        return this.__indent_cache.get_indent_size(indent, column);
      };
      Output.prototype.is_empty = function() {
        return !this.previous_line && this.current_line.is_empty();
      };
      Output.prototype.add_new_line = function(force_newline) {
        if (this.is_empty() || !force_newline && this.just_added_newline()) {
          return false;
        }
        if (!this.raw) {
          this.__add_outputline();
        }
        return true;
      };
      Output.prototype.get_code = function(eol) {
        this.trim(true);
        var last_item = this.current_line.pop();
        if (last_item) {
          if (last_item[last_item.length - 1] === "\n") {
            last_item = last_item.replace(/\n+$/g, "");
          }
          this.current_line.push(last_item);
        }
        if (this._end_with_newline) {
          this.__add_outputline();
        }
        var sweet_code = this.__lines.join("\n");
        if (eol !== "\n") {
          sweet_code = sweet_code.replace(/[\n]/g, eol);
        }
        return sweet_code;
      };
      Output.prototype.set_wrap_point = function() {
        this.current_line._set_wrap_point();
      };
      Output.prototype.set_indent = function(indent, alignment) {
        indent = indent || 0;
        alignment = alignment || 0;
        this.next_line.set_indent(indent, alignment);
        if (this.__lines.length > 1) {
          this.current_line.set_indent(indent, alignment);
          return true;
        }
        this.current_line.set_indent();
        return false;
      };
      Output.prototype.add_raw_token = function(token2) {
        for (var x = 0; x < token2.newlines; x++) {
          this.__add_outputline();
        }
        this.current_line.set_indent(-1);
        this.current_line.push(token2.whitespace_before);
        this.current_line.push(token2.text);
        this.space_before_token = false;
        this.non_breaking_space = false;
        this.previous_token_wrapped = false;
      };
      Output.prototype.add_token = function(printable_token) {
        this.__add_space_before_token();
        this.current_line.push(printable_token);
        this.space_before_token = false;
        this.non_breaking_space = false;
        this.previous_token_wrapped = this.current_line._allow_wrap();
      };
      Output.prototype.__add_space_before_token = function() {
        if (this.space_before_token && !this.just_added_newline()) {
          if (!this.non_breaking_space) {
            this.set_wrap_point();
          }
          this.current_line.push(" ");
        }
      };
      Output.prototype.remove_indent = function(index) {
        var output_length = this.__lines.length;
        while (index < output_length) {
          this.__lines[index]._remove_indent();
          index++;
        }
        this.current_line._remove_wrap_indent();
      };
      Output.prototype.trim = function(eat_newlines) {
        eat_newlines = eat_newlines === void 0 ? false : eat_newlines;
        this.current_line.trim();
        while (eat_newlines && this.__lines.length > 1 && this.current_line.is_empty()) {
          this.__lines.pop();
          this.current_line = this.__lines[this.__lines.length - 1];
          this.current_line.trim();
        }
        this.previous_line = this.__lines.length > 1 ? this.__lines[this.__lines.length - 2] : null;
      };
      Output.prototype.just_added_newline = function() {
        return this.current_line.is_empty();
      };
      Output.prototype.just_added_blankline = function() {
        return this.is_empty() || this.current_line.is_empty() && this.previous_line.is_empty();
      };
      Output.prototype.ensure_empty_line_above = function(starts_with, ends_with) {
        var index = this.__lines.length - 2;
        while (index >= 0) {
          var potentialEmptyLine = this.__lines[index];
          if (potentialEmptyLine.is_empty()) {
            break;
          } else if (potentialEmptyLine.item(0).indexOf(starts_with) !== 0 && potentialEmptyLine.item(-1) !== ends_with) {
            this.__lines.splice(index + 1, 0, new OutputLine(this));
            this.previous_line = this.__lines[this.__lines.length - 2];
            break;
          }
          index--;
        }
      };
      output.Output = Output;
      return output;
    }
    var token$1 = {};
    var hasRequiredToken;
    function requireToken() {
      if (hasRequiredToken)
        return token$1;
      hasRequiredToken = 1;
      function Token2(type, text2, newlines, whitespace_before) {
        this.type = type;
        this.text = text2;
        this.comments_before = null;
        this.newlines = newlines || 0;
        this.whitespace_before = whitespace_before || "";
        this.parent = null;
        this.next = null;
        this.previous = null;
        this.opened = null;
        this.closed = null;
        this.directives = null;
      }
      token$1.Token = Token2;
      return token$1;
    }
    var acorn = {};
    var hasRequiredAcorn;
    function requireAcorn() {
      if (hasRequiredAcorn)
        return acorn;
      hasRequiredAcorn = 1;
      (function(exports2) {
        var baseASCIIidentifierStartChars = "\\x23\\x24\\x40\\x41-\\x5a\\x5f\\x61-\\x7a";
        var baseASCIIidentifierChars = "\\x24\\x30-\\x39\\x41-\\x5a\\x5f\\x61-\\x7a";
        var nonASCIIidentifierStartChars = "\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u0527\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0\\u08a2-\\u08ac\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0977\\u0979-\\u097f\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c33\\u0c35-\\u0c39\\u0c3d\\u0c58\\u0c59\\u0c60\\u0c61\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d60\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f4\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f0\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191c\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19c1-\\u19c7\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2119-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u212d\\u212f-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u2e2f\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309d-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua697\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua78e\\ua790-\\ua793\\ua7a0-\\ua7aa\\ua7f8-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa80-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uabc0-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc";
        var nonASCIIidentifierChars = "\\u0300-\\u036f\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u0620-\\u0649\\u0672-\\u06d3\\u06e7-\\u06e8\\u06fb-\\u06fc\\u0730-\\u074a\\u0800-\\u0814\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0840-\\u0857\\u08e4-\\u08fe\\u0900-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962-\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09d7\\u09df-\\u09e0\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2-\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b5f-\\u0b60\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c01-\\u0c03\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62-\\u0c63\\u0c66-\\u0c6f\\u0c82\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2-\\u0ce3\\u0ce6-\\u0cef\\u0d02\\u0d03\\u0d46-\\u0d48\\u0d57\\u0d62-\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0df2\\u0df3\\u0e34-\\u0e3a\\u0e40-\\u0e45\\u0e50-\\u0e59\\u0eb4-\\u0eb9\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f41-\\u0f47\\u0f71-\\u0f84\\u0f86-\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u1000-\\u1029\\u1040-\\u1049\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u170e-\\u1710\\u1720-\\u1730\\u1740-\\u1750\\u1772\\u1773\\u1780-\\u17b2\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u1920-\\u192b\\u1930-\\u193b\\u1951-\\u196d\\u19b0-\\u19c0\\u19c8-\\u19c9\\u19d0-\\u19d9\\u1a00-\\u1a15\\u1a20-\\u1a53\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1b46-\\u1b4b\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c00-\\u1c22\\u1c40-\\u1c49\\u1c5b-\\u1c7d\\u1cd0-\\u1cd2\\u1d00-\\u1dbe\\u1e01-\\u1f15\\u200c\\u200d\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2d81-\\u2d96\\u2de0-\\u2dff\\u3021-\\u3028\\u3099\\u309a\\ua640-\\ua66d\\ua674-\\ua67d\\ua69f\\ua6f0-\\ua6f1\\ua7f8-\\ua800\\ua806\\ua80b\\ua823-\\ua827\\ua880-\\ua881\\ua8b4-\\ua8c4\\ua8d0-\\ua8d9\\ua8f3-\\ua8f7\\ua900-\\ua909\\ua926-\\ua92d\\ua930-\\ua945\\ua980-\\ua983\\ua9b3-\\ua9c0\\uaa00-\\uaa27\\uaa40-\\uaa41\\uaa4c-\\uaa4d\\uaa50-\\uaa59\\uaa7b\\uaae0-\\uaae9\\uaaf2-\\uaaf3\\uabc0-\\uabe1\\uabec\\uabed\\uabf0-\\uabf9\\ufb20-\\ufb28\\ufe00-\\ufe0f\\ufe20-\\ufe26\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f";
        var identifierStart = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierStartChars + nonASCIIidentifierStartChars + "])";
        var identifierChars = "(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])*";
        exports2.identifier = new RegExp(identifierStart + identifierChars, "g");
        exports2.identifierStart = new RegExp(identifierStart);
        exports2.identifierMatch = new RegExp("(?:\\\\u[0-9a-fA-F]{4}|[" + baseASCIIidentifierChars + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "])+");
        exports2.newline = /[\n\r\u2028\u2029]/;
        exports2.lineBreak = new RegExp("\r\n|" + exports2.newline.source);
        exports2.allLineBreaks = new RegExp(exports2.lineBreak.source, "g");
      })(acorn);
      return acorn;
    }
    var options$3 = {};
    var options$2 = {};
    var hasRequiredOptions$3;
    function requireOptions$3() {
      if (hasRequiredOptions$3)
        return options$2;
      hasRequiredOptions$3 = 1;
      function Options(options2, merge_child_field) {
        this.raw_options = _mergeOpts(options2, merge_child_field);
        this.disabled = this._get_boolean("disabled");
        this.eol = this._get_characters("eol", "auto");
        this.end_with_newline = this._get_boolean("end_with_newline");
        this.indent_size = this._get_number("indent_size", 4);
        this.indent_char = this._get_characters("indent_char", " ");
        this.indent_level = this._get_number("indent_level");
        this.preserve_newlines = this._get_boolean("preserve_newlines", true);
        this.max_preserve_newlines = this._get_number("max_preserve_newlines", 32786);
        if (!this.preserve_newlines) {
          this.max_preserve_newlines = 0;
        }
        this.indent_with_tabs = this._get_boolean("indent_with_tabs", this.indent_char === "	");
        if (this.indent_with_tabs) {
          this.indent_char = "	";
          if (this.indent_size === 1) {
            this.indent_size = 4;
          }
        }
        this.wrap_line_length = this._get_number("wrap_line_length", this._get_number("max_char"));
        this.indent_empty_lines = this._get_boolean("indent_empty_lines");
        this.templating = this._get_selection_list("templating", ["auto", "none", "django", "erb", "handlebars", "php", "smarty"], ["auto"]);
      }
      Options.prototype._get_array = function(name, default_value) {
        var option_value = this.raw_options[name];
        var result = default_value || [];
        if (typeof option_value === "object") {
          if (option_value !== null && typeof option_value.concat === "function") {
            result = option_value.concat();
          }
        } else if (typeof option_value === "string") {
          result = option_value.split(/[^a-zA-Z0-9_\/\-]+/);
        }
        return result;
      };
      Options.prototype._get_boolean = function(name, default_value) {
        var option_value = this.raw_options[name];
        var result = option_value === void 0 ? !!default_value : !!option_value;
        return result;
      };
      Options.prototype._get_characters = function(name, default_value) {
        var option_value = this.raw_options[name];
        var result = default_value || "";
        if (typeof option_value === "string") {
          result = option_value.replace(/\\r/, "\r").replace(/\\n/, "\n").replace(/\\t/, "	");
        }
        return result;
      };
      Options.prototype._get_number = function(name, default_value) {
        var option_value = this.raw_options[name];
        default_value = parseInt(default_value, 10);
        if (isNaN(default_value)) {
          default_value = 0;
        }
        var result = parseInt(option_value, 10);
        if (isNaN(result)) {
          result = default_value;
        }
        return result;
      };
      Options.prototype._get_selection = function(name, selection_list, default_value) {
        var result = this._get_selection_list(name, selection_list, default_value);
        if (result.length !== 1) {
          throw new Error("Invalid Option Value: The option '" + name + "' can only be one of the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
        }
        return result[0];
      };
      Options.prototype._get_selection_list = function(name, selection_list, default_value) {
        if (!selection_list || selection_list.length === 0) {
          throw new Error("Selection list cannot be empty.");
        }
        default_value = default_value || [selection_list[0]];
        if (!this._is_valid_selection(default_value, selection_list)) {
          throw new Error("Invalid Default Value!");
        }
        var result = this._get_array(name, default_value);
        if (!this._is_valid_selection(result, selection_list)) {
          throw new Error("Invalid Option Value: The option '" + name + "' can contain only the following values:\n" + selection_list + "\nYou passed in: '" + this.raw_options[name] + "'");
        }
        return result;
      };
      Options.prototype._is_valid_selection = function(result, selection_list) {
        return result.length && selection_list.length && !result.some(function(item) {
          return selection_list.indexOf(item) === -1;
        });
      };
      function _mergeOpts(allOptions, childFieldName) {
        var finalOpts = {};
        allOptions = _normalizeOpts(allOptions);
        var name;
        for (name in allOptions) {
          if (name !== childFieldName) {
            finalOpts[name] = allOptions[name];
          }
        }
        if (childFieldName && allOptions[childFieldName]) {
          for (name in allOptions[childFieldName]) {
            finalOpts[name] = allOptions[childFieldName][name];
          }
        }
        return finalOpts;
      }
      function _normalizeOpts(options2) {
        var convertedOpts = {};
        var key;
        for (key in options2) {
          var newKey = key.replace(/-/g, "_");
          convertedOpts[newKey] = options2[key];
        }
        return convertedOpts;
      }
      options$2.Options = Options;
      options$2.normalizeOpts = _normalizeOpts;
      options$2.mergeOpts = _mergeOpts;
      return options$2;
    }
    var hasRequiredOptions$2;
    function requireOptions$2() {
      if (hasRequiredOptions$2)
        return options$3;
      hasRequiredOptions$2 = 1;
      var BaseOptions = requireOptions$3().Options;
      var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
      function Options(options2) {
        BaseOptions.call(this, options2, "js");
        var raw_brace_style = this.raw_options.brace_style || null;
        if (raw_brace_style === "expand-strict") {
          this.raw_options.brace_style = "expand";
        } else if (raw_brace_style === "collapse-preserve-inline") {
          this.raw_options.brace_style = "collapse,preserve-inline";
        } else if (this.raw_options.braces_on_own_line !== void 0) {
          this.raw_options.brace_style = this.raw_options.braces_on_own_line ? "expand" : "collapse";
        }
        var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
        this.brace_preserve_inline = false;
        this.brace_style = "collapse";
        for (var bs = 0; bs < brace_style_split.length; bs++) {
          if (brace_style_split[bs] === "preserve-inline") {
            this.brace_preserve_inline = true;
          } else {
            this.brace_style = brace_style_split[bs];
          }
        }
        this.unindent_chained_methods = this._get_boolean("unindent_chained_methods");
        this.break_chained_methods = this._get_boolean("break_chained_methods");
        this.space_in_paren = this._get_boolean("space_in_paren");
        this.space_in_empty_paren = this._get_boolean("space_in_empty_paren");
        this.jslint_happy = this._get_boolean("jslint_happy");
        this.space_after_anon_function = this._get_boolean("space_after_anon_function");
        this.space_after_named_function = this._get_boolean("space_after_named_function");
        this.keep_array_indentation = this._get_boolean("keep_array_indentation");
        this.space_before_conditional = this._get_boolean("space_before_conditional", true);
        this.unescape_strings = this._get_boolean("unescape_strings");
        this.e4x = this._get_boolean("e4x");
        this.comma_first = this._get_boolean("comma_first");
        this.operator_position = this._get_selection("operator_position", validPositionValues);
        this.test_output_raw = this._get_boolean("test_output_raw");
        if (this.jslint_happy) {
          this.space_after_anon_function = true;
        }
      }
      Options.prototype = new BaseOptions();
      options$3.Options = Options;
      return options$3;
    }
    var tokenizer$2 = {};
    var inputscanner = {};
    var hasRequiredInputscanner;
    function requireInputscanner() {
      if (hasRequiredInputscanner)
        return inputscanner;
      hasRequiredInputscanner = 1;
      var regexp_has_sticky = RegExp.prototype.hasOwnProperty("sticky");
      function InputScanner(input_string) {
        this.__input = input_string || "";
        this.__input_length = this.__input.length;
        this.__position = 0;
      }
      InputScanner.prototype.restart = function() {
        this.__position = 0;
      };
      InputScanner.prototype.back = function() {
        if (this.__position > 0) {
          this.__position -= 1;
        }
      };
      InputScanner.prototype.hasNext = function() {
        return this.__position < this.__input_length;
      };
      InputScanner.prototype.next = function() {
        var val = null;
        if (this.hasNext()) {
          val = this.__input.charAt(this.__position);
          this.__position += 1;
        }
        return val;
      };
      InputScanner.prototype.peek = function(index) {
        var val = null;
        index = index || 0;
        index += this.__position;
        if (index >= 0 && index < this.__input_length) {
          val = this.__input.charAt(index);
        }
        return val;
      };
      InputScanner.prototype.__match = function(pattern2, index) {
        pattern2.lastIndex = index;
        var pattern_match = pattern2.exec(this.__input);
        if (pattern_match && !(regexp_has_sticky && pattern2.sticky)) {
          if (pattern_match.index !== index) {
            pattern_match = null;
          }
        }
        return pattern_match;
      };
      InputScanner.prototype.test = function(pattern2, index) {
        index = index || 0;
        index += this.__position;
        if (index >= 0 && index < this.__input_length) {
          return !!this.__match(pattern2, index);
        } else {
          return false;
        }
      };
      InputScanner.prototype.testChar = function(pattern2, index) {
        var val = this.peek(index);
        pattern2.lastIndex = 0;
        return val !== null && pattern2.test(val);
      };
      InputScanner.prototype.match = function(pattern2) {
        var pattern_match = this.__match(pattern2, this.__position);
        if (pattern_match) {
          this.__position += pattern_match[0].length;
        } else {
          pattern_match = null;
        }
        return pattern_match;
      };
      InputScanner.prototype.read = function(starting_pattern, until_pattern, until_after) {
        var val = "";
        var match;
        if (starting_pattern) {
          match = this.match(starting_pattern);
          if (match) {
            val += match[0];
          }
        }
        if (until_pattern && (match || !starting_pattern)) {
          val += this.readUntil(until_pattern, until_after);
        }
        return val;
      };
      InputScanner.prototype.readUntil = function(pattern2, until_after) {
        var val = "";
        var match_index = this.__position;
        pattern2.lastIndex = this.__position;
        var pattern_match = pattern2.exec(this.__input);
        if (pattern_match) {
          match_index = pattern_match.index;
          if (until_after) {
            match_index += pattern_match[0].length;
          }
        } else {
          match_index = this.__input_length;
        }
        val = this.__input.substring(this.__position, match_index);
        this.__position = match_index;
        return val;
      };
      InputScanner.prototype.readUntilAfter = function(pattern2) {
        return this.readUntil(pattern2, true);
      };
      InputScanner.prototype.get_regexp = function(pattern2, match_from) {
        var result = null;
        var flags = "g";
        if (match_from && regexp_has_sticky) {
          flags = "y";
        }
        if (typeof pattern2 === "string" && pattern2 !== "") {
          result = new RegExp(pattern2, flags);
        } else if (pattern2) {
          result = new RegExp(pattern2.source, flags);
        }
        return result;
      };
      InputScanner.prototype.get_literal_regexp = function(literal_string) {
        return RegExp(literal_string.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&"));
      };
      InputScanner.prototype.peekUntilAfter = function(pattern2) {
        var start = this.__position;
        var val = this.readUntilAfter(pattern2);
        this.__position = start;
        return val;
      };
      InputScanner.prototype.lookBack = function(testVal) {
        var start = this.__position - 1;
        return start >= testVal.length && this.__input.substring(start - testVal.length, start).toLowerCase() === testVal;
      };
      inputscanner.InputScanner = InputScanner;
      return inputscanner;
    }
    var tokenizer$1 = {};
    var tokenstream = {};
    var hasRequiredTokenstream;
    function requireTokenstream() {
      if (hasRequiredTokenstream)
        return tokenstream;
      hasRequiredTokenstream = 1;
      function TokenStream(parent_token) {
        this.__tokens = [];
        this.__tokens_length = this.__tokens.length;
        this.__position = 0;
        this.__parent_token = parent_token;
      }
      TokenStream.prototype.restart = function() {
        this.__position = 0;
      };
      TokenStream.prototype.isEmpty = function() {
        return this.__tokens_length === 0;
      };
      TokenStream.prototype.hasNext = function() {
        return this.__position < this.__tokens_length;
      };
      TokenStream.prototype.next = function() {
        var val = null;
        if (this.hasNext()) {
          val = this.__tokens[this.__position];
          this.__position += 1;
        }
        return val;
      };
      TokenStream.prototype.peek = function(index) {
        var val = null;
        index = index || 0;
        index += this.__position;
        if (index >= 0 && index < this.__tokens_length) {
          val = this.__tokens[index];
        }
        return val;
      };
      TokenStream.prototype.add = function(token2) {
        if (this.__parent_token) {
          token2.parent = this.__parent_token;
        }
        this.__tokens.push(token2);
        this.__tokens_length += 1;
      };
      tokenstream.TokenStream = TokenStream;
      return tokenstream;
    }
    var whitespacepattern = {};
    var pattern = {};
    var hasRequiredPattern;
    function requirePattern() {
      if (hasRequiredPattern)
        return pattern;
      hasRequiredPattern = 1;
      function Pattern(input_scanner, parent) {
        this._input = input_scanner;
        this._starting_pattern = null;
        this._match_pattern = null;
        this._until_pattern = null;
        this._until_after = false;
        if (parent) {
          this._starting_pattern = this._input.get_regexp(parent._starting_pattern, true);
          this._match_pattern = this._input.get_regexp(parent._match_pattern, true);
          this._until_pattern = this._input.get_regexp(parent._until_pattern);
          this._until_after = parent._until_after;
        }
      }
      Pattern.prototype.read = function() {
        var result = this._input.read(this._starting_pattern);
        if (!this._starting_pattern || result) {
          result += this._input.read(this._match_pattern, this._until_pattern, this._until_after);
        }
        return result;
      };
      Pattern.prototype.read_match = function() {
        return this._input.match(this._match_pattern);
      };
      Pattern.prototype.until_after = function(pattern2) {
        var result = this._create();
        result._until_after = true;
        result._until_pattern = this._input.get_regexp(pattern2);
        result._update();
        return result;
      };
      Pattern.prototype.until = function(pattern2) {
        var result = this._create();
        result._until_after = false;
        result._until_pattern = this._input.get_regexp(pattern2);
        result._update();
        return result;
      };
      Pattern.prototype.starting_with = function(pattern2) {
        var result = this._create();
        result._starting_pattern = this._input.get_regexp(pattern2, true);
        result._update();
        return result;
      };
      Pattern.prototype.matching = function(pattern2) {
        var result = this._create();
        result._match_pattern = this._input.get_regexp(pattern2, true);
        result._update();
        return result;
      };
      Pattern.prototype._create = function() {
        return new Pattern(this._input, this);
      };
      Pattern.prototype._update = function() {
      };
      pattern.Pattern = Pattern;
      return pattern;
    }
    var hasRequiredWhitespacepattern;
    function requireWhitespacepattern() {
      if (hasRequiredWhitespacepattern)
        return whitespacepattern;
      hasRequiredWhitespacepattern = 1;
      var Pattern = requirePattern().Pattern;
      function WhitespacePattern(input_scanner, parent) {
        Pattern.call(this, input_scanner, parent);
        if (parent) {
          this._line_regexp = this._input.get_regexp(parent._line_regexp);
        } else {
          this.__set_whitespace_patterns("", "");
        }
        this.newline_count = 0;
        this.whitespace_before_token = "";
      }
      WhitespacePattern.prototype = new Pattern();
      WhitespacePattern.prototype.__set_whitespace_patterns = function(whitespace_chars, newline_chars) {
        whitespace_chars += "\\t ";
        newline_chars += "\\n\\r";
        this._match_pattern = this._input.get_regexp("[" + whitespace_chars + newline_chars + "]+", true);
        this._newline_regexp = this._input.get_regexp("\\r\\n|[" + newline_chars + "]");
      };
      WhitespacePattern.prototype.read = function() {
        this.newline_count = 0;
        this.whitespace_before_token = "";
        var resulting_string = this._input.read(this._match_pattern);
        if (resulting_string === " ") {
          this.whitespace_before_token = " ";
        } else if (resulting_string) {
          var matches = this.__split(this._newline_regexp, resulting_string);
          this.newline_count = matches.length - 1;
          this.whitespace_before_token = matches[this.newline_count];
        }
        return resulting_string;
      };
      WhitespacePattern.prototype.matching = function(whitespace_chars, newline_chars) {
        var result = this._create();
        result.__set_whitespace_patterns(whitespace_chars, newline_chars);
        result._update();
        return result;
      };
      WhitespacePattern.prototype._create = function() {
        return new WhitespacePattern(this._input, this);
      };
      WhitespacePattern.prototype.__split = function(regexp, input_string) {
        regexp.lastIndex = 0;
        var start_index = 0;
        var result = [];
        var next_match = regexp.exec(input_string);
        while (next_match) {
          result.push(input_string.substring(start_index, next_match.index));
          start_index = next_match.index + next_match[0].length;
          next_match = regexp.exec(input_string);
        }
        if (start_index < input_string.length) {
          result.push(input_string.substring(start_index, input_string.length));
        } else {
          result.push("");
        }
        return result;
      };
      whitespacepattern.WhitespacePattern = WhitespacePattern;
      return whitespacepattern;
    }
    var hasRequiredTokenizer$2;
    function requireTokenizer$2() {
      if (hasRequiredTokenizer$2)
        return tokenizer$1;
      hasRequiredTokenizer$2 = 1;
      var InputScanner = requireInputscanner().InputScanner;
      var Token2 = requireToken().Token;
      var TokenStream = requireTokenstream().TokenStream;
      var WhitespacePattern = requireWhitespacepattern().WhitespacePattern;
      var TOKEN = {
        START: "TK_START",
        RAW: "TK_RAW",
        EOF: "TK_EOF"
      };
      var Tokenizer = function(input_string, options2) {
        this._input = new InputScanner(input_string);
        this._options = options2 || {};
        this.__tokens = null;
        this._patterns = {};
        this._patterns.whitespace = new WhitespacePattern(this._input);
      };
      Tokenizer.prototype.tokenize = function() {
        this._input.restart();
        this.__tokens = new TokenStream();
        this._reset();
        var current;
        var previous = new Token2(TOKEN.START, "");
        var open_token = null;
        var open_stack = [];
        var comments = new TokenStream();
        while (previous.type !== TOKEN.EOF) {
          current = this._get_next_token(previous, open_token);
          while (this._is_comment(current)) {
            comments.add(current);
            current = this._get_next_token(previous, open_token);
          }
          if (!comments.isEmpty()) {
            current.comments_before = comments;
            comments = new TokenStream();
          }
          current.parent = open_token;
          if (this._is_opening(current)) {
            open_stack.push(open_token);
            open_token = current;
          } else if (open_token && this._is_closing(current, open_token)) {
            current.opened = open_token;
            open_token.closed = current;
            open_token = open_stack.pop();
            current.parent = open_token;
          }
          current.previous = previous;
          previous.next = current;
          this.__tokens.add(current);
          previous = current;
        }
        return this.__tokens;
      };
      Tokenizer.prototype._is_first_token = function() {
        return this.__tokens.isEmpty();
      };
      Tokenizer.prototype._reset = function() {
      };
      Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
        this._readWhitespace();
        var resulting_string = this._input.read(/.+/g);
        if (resulting_string) {
          return this._create_token(TOKEN.RAW, resulting_string);
        } else {
          return this._create_token(TOKEN.EOF, "");
        }
      };
      Tokenizer.prototype._is_comment = function(current_token) {
        return false;
      };
      Tokenizer.prototype._is_opening = function(current_token) {
        return false;
      };
      Tokenizer.prototype._is_closing = function(current_token, open_token) {
        return false;
      };
      Tokenizer.prototype._create_token = function(type, text2) {
        var token2 = new Token2(type, text2, this._patterns.whitespace.newline_count, this._patterns.whitespace.whitespace_before_token);
        return token2;
      };
      Tokenizer.prototype._readWhitespace = function() {
        return this._patterns.whitespace.read();
      };
      tokenizer$1.Tokenizer = Tokenizer;
      tokenizer$1.TOKEN = TOKEN;
      return tokenizer$1;
    }
    var directives = {};
    var hasRequiredDirectives;
    function requireDirectives() {
      if (hasRequiredDirectives)
        return directives;
      hasRequiredDirectives = 1;
      function Directives(start_block_pattern, end_block_pattern) {
        start_block_pattern = typeof start_block_pattern === "string" ? start_block_pattern : start_block_pattern.source;
        end_block_pattern = typeof end_block_pattern === "string" ? end_block_pattern : end_block_pattern.source;
        this.__directives_block_pattern = new RegExp(start_block_pattern + / beautify( \w+[:]\w+)+ /.source + end_block_pattern, "g");
        this.__directive_pattern = / (\w+)[:](\w+)/g;
        this.__directives_end_ignore_pattern = new RegExp(start_block_pattern + /\sbeautify\signore:end\s/.source + end_block_pattern, "g");
      }
      Directives.prototype.get_directives = function(text2) {
        if (!text2.match(this.__directives_block_pattern)) {
          return null;
        }
        var directives2 = {};
        this.__directive_pattern.lastIndex = 0;
        var directive_match = this.__directive_pattern.exec(text2);
        while (directive_match) {
          directives2[directive_match[1]] = directive_match[2];
          directive_match = this.__directive_pattern.exec(text2);
        }
        return directives2;
      };
      Directives.prototype.readIgnored = function(input) {
        return input.readUntilAfter(this.__directives_end_ignore_pattern);
      };
      directives.Directives = Directives;
      return directives;
    }
    var templatablepattern = {};
    var hasRequiredTemplatablepattern;
    function requireTemplatablepattern() {
      if (hasRequiredTemplatablepattern)
        return templatablepattern;
      hasRequiredTemplatablepattern = 1;
      var Pattern = requirePattern().Pattern;
      var template_names = {
        django: false,
        erb: false,
        handlebars: false,
        php: false,
        smarty: false
      };
      function TemplatablePattern(input_scanner, parent) {
        Pattern.call(this, input_scanner, parent);
        this.__template_pattern = null;
        this._disabled = Object.assign({}, template_names);
        this._excluded = Object.assign({}, template_names);
        if (parent) {
          this.__template_pattern = this._input.get_regexp(parent.__template_pattern);
          this._excluded = Object.assign(this._excluded, parent._excluded);
          this._disabled = Object.assign(this._disabled, parent._disabled);
        }
        var pattern2 = new Pattern(input_scanner);
        this.__patterns = {
          handlebars_comment: pattern2.starting_with(/{{!--/).until_after(/--}}/),
          handlebars_unescaped: pattern2.starting_with(/{{{/).until_after(/}}}/),
          handlebars: pattern2.starting_with(/{{/).until_after(/}}/),
          php: pattern2.starting_with(/<\?(?:[= ]|php)/).until_after(/\?>/),
          erb: pattern2.starting_with(/<%[^%]/).until_after(/[^%]%>/),
          django: pattern2.starting_with(/{%/).until_after(/%}/),
          django_value: pattern2.starting_with(/{{/).until_after(/}}/),
          django_comment: pattern2.starting_with(/{#/).until_after(/#}/),
          smarty: pattern2.starting_with(/{(?=[^}{\s\n])/).until_after(/[^\s\n]}/),
          smarty_comment: pattern2.starting_with(/{\*/).until_after(/\*}/),
          smarty_literal: pattern2.starting_with(/{literal}/).until_after(/{\/literal}/)
        };
      }
      TemplatablePattern.prototype = new Pattern();
      TemplatablePattern.prototype._create = function() {
        return new TemplatablePattern(this._input, this);
      };
      TemplatablePattern.prototype._update = function() {
        this.__set_templated_pattern();
      };
      TemplatablePattern.prototype.disable = function(language) {
        var result = this._create();
        result._disabled[language] = true;
        result._update();
        return result;
      };
      TemplatablePattern.prototype.read_options = function(options2) {
        var result = this._create();
        for (var language in template_names) {
          result._disabled[language] = options2.templating.indexOf(language) === -1;
        }
        result._update();
        return result;
      };
      TemplatablePattern.prototype.exclude = function(language) {
        var result = this._create();
        result._excluded[language] = true;
        result._update();
        return result;
      };
      TemplatablePattern.prototype.read = function() {
        var result = "";
        if (this._match_pattern) {
          result = this._input.read(this._starting_pattern);
        } else {
          result = this._input.read(this._starting_pattern, this.__template_pattern);
        }
        var next = this._read_template();
        while (next) {
          if (this._match_pattern) {
            next += this._input.read(this._match_pattern);
          } else {
            next += this._input.readUntil(this.__template_pattern);
          }
          result += next;
          next = this._read_template();
        }
        if (this._until_after) {
          result += this._input.readUntilAfter(this._until_pattern);
        }
        return result;
      };
      TemplatablePattern.prototype.__set_templated_pattern = function() {
        var items = [];
        if (!this._disabled.php) {
          items.push(this.__patterns.php._starting_pattern.source);
        }
        if (!this._disabled.handlebars) {
          items.push(this.__patterns.handlebars._starting_pattern.source);
        }
        if (!this._disabled.erb) {
          items.push(this.__patterns.erb._starting_pattern.source);
        }
        if (!this._disabled.django) {
          items.push(this.__patterns.django._starting_pattern.source);
          items.push(this.__patterns.django_value._starting_pattern.source);
          items.push(this.__patterns.django_comment._starting_pattern.source);
        }
        if (!this._disabled.smarty) {
          items.push(this.__patterns.smarty._starting_pattern.source);
        }
        if (this._until_pattern) {
          items.push(this._until_pattern.source);
        }
        this.__template_pattern = this._input.get_regexp("(?:" + items.join("|") + ")");
      };
      TemplatablePattern.prototype._read_template = function() {
        var resulting_string = "";
        var c = this._input.peek();
        if (c === "<") {
          var peek1 = this._input.peek(1);
          if (!this._disabled.php && !this._excluded.php && peek1 === "?") {
            resulting_string = resulting_string || this.__patterns.php.read();
          }
          if (!this._disabled.erb && !this._excluded.erb && peek1 === "%") {
            resulting_string = resulting_string || this.__patterns.erb.read();
          }
        } else if (c === "{") {
          if (!this._disabled.handlebars && !this._excluded.handlebars) {
            resulting_string = resulting_string || this.__patterns.handlebars_comment.read();
            resulting_string = resulting_string || this.__patterns.handlebars_unescaped.read();
            resulting_string = resulting_string || this.__patterns.handlebars.read();
          }
          if (!this._disabled.django) {
            if (!this._excluded.django && !this._excluded.handlebars) {
              resulting_string = resulting_string || this.__patterns.django_value.read();
            }
            if (!this._excluded.django) {
              resulting_string = resulting_string || this.__patterns.django_comment.read();
              resulting_string = resulting_string || this.__patterns.django.read();
            }
          }
          if (!this._disabled.smarty) {
            if (this._disabled.django && this._disabled.handlebars) {
              resulting_string = resulting_string || this.__patterns.smarty_comment.read();
              resulting_string = resulting_string || this.__patterns.smarty_literal.read();
              resulting_string = resulting_string || this.__patterns.smarty.read();
            }
          }
        }
        return resulting_string;
      };
      templatablepattern.TemplatablePattern = TemplatablePattern;
      return templatablepattern;
    }
    var hasRequiredTokenizer$1;
    function requireTokenizer$1() {
      if (hasRequiredTokenizer$1)
        return tokenizer$2;
      hasRequiredTokenizer$1 = 1;
      var InputScanner = requireInputscanner().InputScanner;
      var BaseTokenizer = requireTokenizer$2().Tokenizer;
      var BASETOKEN = requireTokenizer$2().TOKEN;
      var Directives = requireDirectives().Directives;
      var acorn2 = requireAcorn();
      var Pattern = requirePattern().Pattern;
      var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
      function in_array(what, arr) {
        return arr.indexOf(what) !== -1;
      }
      var TOKEN = {
        START_EXPR: "TK_START_EXPR",
        END_EXPR: "TK_END_EXPR",
        START_BLOCK: "TK_START_BLOCK",
        END_BLOCK: "TK_END_BLOCK",
        WORD: "TK_WORD",
        RESERVED: "TK_RESERVED",
        SEMICOLON: "TK_SEMICOLON",
        STRING: "TK_STRING",
        EQUALS: "TK_EQUALS",
        OPERATOR: "TK_OPERATOR",
        COMMA: "TK_COMMA",
        BLOCK_COMMENT: "TK_BLOCK_COMMENT",
        COMMENT: "TK_COMMENT",
        DOT: "TK_DOT",
        UNKNOWN: "TK_UNKNOWN",
        START: BASETOKEN.START,
        RAW: BASETOKEN.RAW,
        EOF: BASETOKEN.EOF
      };
      var directives_core = new Directives(/\/\*/, /\*\//);
      var number_pattern = /0[xX][0123456789abcdefABCDEF_]*n?|0[oO][01234567_]*n?|0[bB][01_]*n?|\d[\d_]*n|(?:\.\d[\d_]*|\d[\d_]*\.?[\d_]*)(?:[eE][+-]?[\d_]+)?/;
      var digit = /[0-9]/;
      var dot_pattern = /[^\d\.]/;
      var positionable_operators = ">>> === !== &&= ??= ||= << && >= ** != == <= >> || ?? |> < / - + > : & % ? ^ | *".split(" ");
      var punct = ">>>= ... >>= <<= === >>> !== **= &&= ??= ||= => ^= :: /= << <= == && -= >= >> != -- += ** || ?? ++ %= &= *= |= |> = ! ? > < : / ^ - + * & % ~ |";
      punct = punct.replace(/[-[\]{}()*+?.,\\^$|#]/g, "\\$&");
      punct = "\\?\\.(?!\\d) " + punct;
      punct = punct.replace(/ /g, "|");
      var punct_pattern = new RegExp(punct);
      var line_starters = "continue,try,throw,return,var,let,const,if,switch,case,default,for,while,break,function,import,export".split(",");
      var reserved_words = line_starters.concat(["do", "in", "of", "else", "get", "set", "new", "catch", "finally", "typeof", "yield", "async", "await", "from", "as", "class", "extends"]);
      var reserved_word_pattern = new RegExp("^(?:" + reserved_words.join("|") + ")$");
      var in_html_comment;
      var Tokenizer = function(input_string, options2) {
        BaseTokenizer.call(this, input_string, options2);
        this._patterns.whitespace = this._patterns.whitespace.matching(/\u00A0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff/.source, /\u2028\u2029/.source);
        var pattern_reader = new Pattern(this._input);
        var templatable = new TemplatablePattern(this._input).read_options(this._options);
        this.__patterns = {
          template: templatable,
          identifier: templatable.starting_with(acorn2.identifier).matching(acorn2.identifierMatch),
          number: pattern_reader.matching(number_pattern),
          punct: pattern_reader.matching(punct_pattern),
          comment: pattern_reader.starting_with(/\/\//).until(/[\n\r\u2028\u2029]/),
          block_comment: pattern_reader.starting_with(/\/\*/).until_after(/\*\//),
          html_comment_start: pattern_reader.matching(/<!--/),
          html_comment_end: pattern_reader.matching(/-->/),
          include: pattern_reader.starting_with(/#include/).until_after(acorn2.lineBreak),
          shebang: pattern_reader.starting_with(/#!/).until_after(acorn2.lineBreak),
          xml: pattern_reader.matching(/[\s\S]*?<(\/?)([-a-zA-Z:0-9_.]+|{[^}]+?}|!\[CDATA\[[^\]]*?\]\]|)(\s*{[^}]+?}|\s+[-a-zA-Z:0-9_.]+|\s+[-a-zA-Z:0-9_.]+\s*=\s*('[^']*'|"[^"]*"|{([^{}]|{[^}]+?})+?}))*\s*(\/?)\s*>/),
          single_quote: templatable.until(/['\\\n\r\u2028\u2029]/),
          double_quote: templatable.until(/["\\\n\r\u2028\u2029]/),
          template_text: templatable.until(/[`\\$]/),
          template_expression: templatable.until(/[`}\\]/)
        };
      };
      Tokenizer.prototype = new BaseTokenizer();
      Tokenizer.prototype._is_comment = function(current_token) {
        return current_token.type === TOKEN.COMMENT || current_token.type === TOKEN.BLOCK_COMMENT || current_token.type === TOKEN.UNKNOWN;
      };
      Tokenizer.prototype._is_opening = function(current_token) {
        return current_token.type === TOKEN.START_BLOCK || current_token.type === TOKEN.START_EXPR;
      };
      Tokenizer.prototype._is_closing = function(current_token, open_token) {
        return (current_token.type === TOKEN.END_BLOCK || current_token.type === TOKEN.END_EXPR) && (open_token && (current_token.text === "]" && open_token.text === "[" || current_token.text === ")" && open_token.text === "(" || current_token.text === "}" && open_token.text === "{"));
      };
      Tokenizer.prototype._reset = function() {
        in_html_comment = false;
      };
      Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
        var token2 = null;
        this._readWhitespace();
        var c = this._input.peek();
        if (c === null) {
          return this._create_token(TOKEN.EOF, "");
        }
        token2 = token2 || this._read_non_javascript(c);
        token2 = token2 || this._read_string(c);
        token2 = token2 || this._read_word(previous_token);
        token2 = token2 || this._read_singles(c);
        token2 = token2 || this._read_comment(c);
        token2 = token2 || this._read_regexp(c, previous_token);
        token2 = token2 || this._read_xml(c, previous_token);
        token2 = token2 || this._read_punctuation();
        token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
        return token2;
      };
      Tokenizer.prototype._read_word = function(previous_token) {
        var resulting_string;
        resulting_string = this.__patterns.identifier.read();
        if (resulting_string !== "") {
          resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
          if (!(previous_token.type === TOKEN.DOT || previous_token.type === TOKEN.RESERVED && (previous_token.text === "set" || previous_token.text === "get")) && reserved_word_pattern.test(resulting_string)) {
            if ((resulting_string === "in" || resulting_string === "of") && (previous_token.type === TOKEN.WORD || previous_token.type === TOKEN.STRING)) {
              return this._create_token(TOKEN.OPERATOR, resulting_string);
            }
            return this._create_token(TOKEN.RESERVED, resulting_string);
          }
          return this._create_token(TOKEN.WORD, resulting_string);
        }
        resulting_string = this.__patterns.number.read();
        if (resulting_string !== "") {
          return this._create_token(TOKEN.WORD, resulting_string);
        }
      };
      Tokenizer.prototype._read_singles = function(c) {
        var token2 = null;
        if (c === "(" || c === "[") {
          token2 = this._create_token(TOKEN.START_EXPR, c);
        } else if (c === ")" || c === "]") {
          token2 = this._create_token(TOKEN.END_EXPR, c);
        } else if (c === "{") {
          token2 = this._create_token(TOKEN.START_BLOCK, c);
        } else if (c === "}") {
          token2 = this._create_token(TOKEN.END_BLOCK, c);
        } else if (c === ";") {
          token2 = this._create_token(TOKEN.SEMICOLON, c);
        } else if (c === "." && dot_pattern.test(this._input.peek(1))) {
          token2 = this._create_token(TOKEN.DOT, c);
        } else if (c === ",") {
          token2 = this._create_token(TOKEN.COMMA, c);
        }
        if (token2) {
          this._input.next();
        }
        return token2;
      };
      Tokenizer.prototype._read_punctuation = function() {
        var resulting_string = this.__patterns.punct.read();
        if (resulting_string !== "") {
          if (resulting_string === "=") {
            return this._create_token(TOKEN.EQUALS, resulting_string);
          } else if (resulting_string === "?.") {
            return this._create_token(TOKEN.DOT, resulting_string);
          } else {
            return this._create_token(TOKEN.OPERATOR, resulting_string);
          }
        }
      };
      Tokenizer.prototype._read_non_javascript = function(c) {
        var resulting_string = "";
        if (c === "#") {
          if (this._is_first_token()) {
            resulting_string = this.__patterns.shebang.read();
            if (resulting_string) {
              return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
            }
          }
          resulting_string = this.__patterns.include.read();
          if (resulting_string) {
            return this._create_token(TOKEN.UNKNOWN, resulting_string.trim() + "\n");
          }
          c = this._input.next();
          var sharp2 = "#";
          if (this._input.hasNext() && this._input.testChar(digit)) {
            do {
              c = this._input.next();
              sharp2 += c;
            } while (this._input.hasNext() && c !== "#" && c !== "=");
            if (c === "#")
              ;
            else if (this._input.peek() === "[" && this._input.peek(1) === "]") {
              sharp2 += "[]";
              this._input.next();
              this._input.next();
            } else if (this._input.peek() === "{" && this._input.peek(1) === "}") {
              sharp2 += "{}";
              this._input.next();
              this._input.next();
            }
            return this._create_token(TOKEN.WORD, sharp2);
          }
          this._input.back();
        } else if (c === "<" && this._is_first_token()) {
          resulting_string = this.__patterns.html_comment_start.read();
          if (resulting_string) {
            while (this._input.hasNext() && !this._input.testChar(acorn2.newline)) {
              resulting_string += this._input.next();
            }
            in_html_comment = true;
            return this._create_token(TOKEN.COMMENT, resulting_string);
          }
        } else if (in_html_comment && c === "-") {
          resulting_string = this.__patterns.html_comment_end.read();
          if (resulting_string) {
            in_html_comment = false;
            return this._create_token(TOKEN.COMMENT, resulting_string);
          }
        }
        return null;
      };
      Tokenizer.prototype._read_comment = function(c) {
        var token2 = null;
        if (c === "/") {
          var comment2 = "";
          if (this._input.peek(1) === "*") {
            comment2 = this.__patterns.block_comment.read();
            var directives2 = directives_core.get_directives(comment2);
            if (directives2 && directives2.ignore === "start") {
              comment2 += directives_core.readIgnored(this._input);
            }
            comment2 = comment2.replace(acorn2.allLineBreaks, "\n");
            token2 = this._create_token(TOKEN.BLOCK_COMMENT, comment2);
            token2.directives = directives2;
          } else if (this._input.peek(1) === "/") {
            comment2 = this.__patterns.comment.read();
            token2 = this._create_token(TOKEN.COMMENT, comment2);
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_string = function(c) {
        if (c === "`" || c === "'" || c === '"') {
          var resulting_string = this._input.next();
          this.has_char_escapes = false;
          if (c === "`") {
            resulting_string += this._read_string_recursive("`", true, "${");
          } else {
            resulting_string += this._read_string_recursive(c);
          }
          if (this.has_char_escapes && this._options.unescape_strings) {
            resulting_string = unescape_string(resulting_string);
          }
          if (this._input.peek() === c) {
            resulting_string += this._input.next();
          }
          resulting_string = resulting_string.replace(acorn2.allLineBreaks, "\n");
          return this._create_token(TOKEN.STRING, resulting_string);
        }
        return null;
      };
      Tokenizer.prototype._allow_regexp_or_xml = function(previous_token) {
        return previous_token.type === TOKEN.RESERVED && in_array(previous_token.text, ["return", "case", "throw", "else", "do", "typeof", "yield"]) || previous_token.type === TOKEN.END_EXPR && previous_token.text === ")" && previous_token.opened.previous.type === TOKEN.RESERVED && in_array(previous_token.opened.previous.text, ["if", "while", "for"]) || in_array(previous_token.type, [
          TOKEN.COMMENT,
          TOKEN.START_EXPR,
          TOKEN.START_BLOCK,
          TOKEN.START,
          TOKEN.END_BLOCK,
          TOKEN.OPERATOR,
          TOKEN.EQUALS,
          TOKEN.EOF,
          TOKEN.SEMICOLON,
          TOKEN.COMMA
        ]);
      };
      Tokenizer.prototype._read_regexp = function(c, previous_token) {
        if (c === "/" && this._allow_regexp_or_xml(previous_token)) {
          var resulting_string = this._input.next();
          var esc = false;
          var in_char_class = false;
          while (this._input.hasNext() && ((esc || in_char_class || this._input.peek() !== c) && !this._input.testChar(acorn2.newline))) {
            resulting_string += this._input.peek();
            if (!esc) {
              esc = this._input.peek() === "\\";
              if (this._input.peek() === "[") {
                in_char_class = true;
              } else if (this._input.peek() === "]") {
                in_char_class = false;
              }
            } else {
              esc = false;
            }
            this._input.next();
          }
          if (this._input.peek() === c) {
            resulting_string += this._input.next();
            resulting_string += this._input.read(acorn2.identifier);
          }
          return this._create_token(TOKEN.STRING, resulting_string);
        }
        return null;
      };
      Tokenizer.prototype._read_xml = function(c, previous_token) {
        if (this._options.e4x && c === "<" && this._allow_regexp_or_xml(previous_token)) {
          var xmlStr = "";
          var match = this.__patterns.xml.read_match();
          if (match) {
            var rootTag = match[2].replace(/^{\s+/, "{").replace(/\s+}$/, "}");
            var isCurlyRoot = rootTag.indexOf("{") === 0;
            var depth = 0;
            while (match) {
              var isEndTag = !!match[1];
              var tagName = match[2];
              var isSingletonTag = !!match[match.length - 1] || tagName.slice(0, 8) === "![CDATA[";
              if (!isSingletonTag && (tagName === rootTag || isCurlyRoot && tagName.replace(/^{\s+/, "{").replace(/\s+}$/, "}"))) {
                if (isEndTag) {
                  --depth;
                } else {
                  ++depth;
                }
              }
              xmlStr += match[0];
              if (depth <= 0) {
                break;
              }
              match = this.__patterns.xml.read_match();
            }
            if (!match) {
              xmlStr += this._input.match(/[\s\S]*/g)[0];
            }
            xmlStr = xmlStr.replace(acorn2.allLineBreaks, "\n");
            return this._create_token(TOKEN.STRING, xmlStr);
          }
        }
        return null;
      };
      function unescape_string(s) {
        var out = "", escaped = 0;
        var input_scan = new InputScanner(s);
        var matched = null;
        while (input_scan.hasNext()) {
          matched = input_scan.match(/([\s]|[^\\]|\\\\)+/g);
          if (matched) {
            out += matched[0];
          }
          if (input_scan.peek() === "\\") {
            input_scan.next();
            if (input_scan.peek() === "x") {
              matched = input_scan.match(/x([0-9A-Fa-f]{2})/g);
            } else if (input_scan.peek() === "u") {
              matched = input_scan.match(/u([0-9A-Fa-f]{4})/g);
            } else {
              out += "\\";
              if (input_scan.hasNext()) {
                out += input_scan.next();
              }
              continue;
            }
            if (!matched) {
              return s;
            }
            escaped = parseInt(matched[1], 16);
            if (escaped > 126 && escaped <= 255 && matched[0].indexOf("x") === 0) {
              return s;
            } else if (escaped >= 0 && escaped < 32) {
              out += "\\" + matched[0];
              continue;
            } else if (escaped === 34 || escaped === 39 || escaped === 92) {
              out += "\\" + String.fromCharCode(escaped);
            } else {
              out += String.fromCharCode(escaped);
            }
          }
        }
        return out;
      }
      Tokenizer.prototype._read_string_recursive = function(delimiter, allow_unescaped_newlines, start_sub) {
        var current_char;
        var pattern2;
        if (delimiter === "'") {
          pattern2 = this.__patterns.single_quote;
        } else if (delimiter === '"') {
          pattern2 = this.__patterns.double_quote;
        } else if (delimiter === "`") {
          pattern2 = this.__patterns.template_text;
        } else if (delimiter === "}") {
          pattern2 = this.__patterns.template_expression;
        }
        var resulting_string = pattern2.read();
        var next = "";
        while (this._input.hasNext()) {
          next = this._input.next();
          if (next === delimiter || !allow_unescaped_newlines && acorn2.newline.test(next)) {
            this._input.back();
            break;
          } else if (next === "\\" && this._input.hasNext()) {
            current_char = this._input.peek();
            if (current_char === "x" || current_char === "u") {
              this.has_char_escapes = true;
            } else if (current_char === "\r" && this._input.peek(1) === "\n") {
              this._input.next();
            }
            next += this._input.next();
          } else if (start_sub) {
            if (start_sub === "${" && next === "$" && this._input.peek() === "{") {
              next += this._input.next();
            }
            if (start_sub === next) {
              if (delimiter === "`") {
                next += this._read_string_recursive("}", allow_unescaped_newlines, "`");
              } else {
                next += this._read_string_recursive("`", allow_unescaped_newlines, "${");
              }
              if (this._input.hasNext()) {
                next += this._input.next();
              }
            }
          }
          next += pattern2.read();
          resulting_string += next;
        }
        return resulting_string;
      };
      tokenizer$2.Tokenizer = Tokenizer;
      tokenizer$2.TOKEN = TOKEN;
      tokenizer$2.positionable_operators = positionable_operators.slice();
      tokenizer$2.line_starters = line_starters.slice();
      return tokenizer$2;
    }
    var hasRequiredBeautifier$2;
    function requireBeautifier$2() {
      if (hasRequiredBeautifier$2)
        return beautifier$2;
      hasRequiredBeautifier$2 = 1;
      var Output = requireOutput().Output;
      var Token2 = requireToken().Token;
      var acorn2 = requireAcorn();
      var Options = requireOptions$2().Options;
      var Tokenizer = requireTokenizer$1().Tokenizer;
      var line_starters = requireTokenizer$1().line_starters;
      var positionable_operators = requireTokenizer$1().positionable_operators;
      var TOKEN = requireTokenizer$1().TOKEN;
      function in_array(what, arr) {
        return arr.indexOf(what) !== -1;
      }
      function ltrim(s) {
        return s.replace(/^\s+/g, "");
      }
      function generateMapFromStrings(list2) {
        var result = {};
        for (var x = 0; x < list2.length; x++) {
          result[list2[x].replace(/-/g, "_")] = list2[x];
        }
        return result;
      }
      function reserved_word(token2, word) {
        return token2 && token2.type === TOKEN.RESERVED && token2.text === word;
      }
      function reserved_array(token2, words) {
        return token2 && token2.type === TOKEN.RESERVED && in_array(token2.text, words);
      }
      var special_words = ["case", "return", "do", "if", "throw", "else", "await", "break", "continue", "async"];
      var validPositionValues = ["before-newline", "after-newline", "preserve-newline"];
      var OPERATOR_POSITION = generateMapFromStrings(validPositionValues);
      var OPERATOR_POSITION_BEFORE_OR_PRESERVE = [OPERATOR_POSITION.before_newline, OPERATOR_POSITION.preserve_newline];
      var MODE = {
        BlockStatement: "BlockStatement",
        Statement: "Statement",
        ObjectLiteral: "ObjectLiteral",
        ArrayLiteral: "ArrayLiteral",
        ForInitializer: "ForInitializer",
        Conditional: "Conditional",
        Expression: "Expression"
      };
      function remove_redundant_indentation(output2, frame) {
        if (frame.multiline_frame || frame.mode === MODE.ForInitializer || frame.mode === MODE.Conditional) {
          return;
        }
        output2.remove_indent(frame.start_line_index);
      }
      function split_linebreaks(s) {
        s = s.replace(acorn2.allLineBreaks, "\n");
        var out = [], idx = s.indexOf("\n");
        while (idx !== -1) {
          out.push(s.substring(0, idx));
          s = s.substring(idx + 1);
          idx = s.indexOf("\n");
        }
        if (s.length) {
          out.push(s);
        }
        return out;
      }
      function is_array(mode) {
        return mode === MODE.ArrayLiteral;
      }
      function is_expression(mode) {
        return in_array(mode, [MODE.Expression, MODE.ForInitializer, MODE.Conditional]);
      }
      function all_lines_start_with(lines, c) {
        for (var i2 = 0; i2 < lines.length; i2++) {
          var line = lines[i2].trim();
          if (line.charAt(0) !== c) {
            return false;
          }
        }
        return true;
      }
      function each_line_matches_indent(lines, indent) {
        var i2 = 0, len = lines.length, line;
        for (; i2 < len; i2++) {
          line = lines[i2];
          if (line && line.indexOf(indent) !== 0) {
            return false;
          }
        }
        return true;
      }
      function Beautifier(source_text, options2) {
        options2 = options2 || {};
        this._source_text = source_text || "";
        this._output = null;
        this._tokens = null;
        this._last_last_text = null;
        this._flags = null;
        this._previous_flags = null;
        this._flag_store = null;
        this._options = new Options(options2);
      }
      Beautifier.prototype.create_flags = function(flags_base, mode) {
        var next_indent_level = 0;
        if (flags_base) {
          next_indent_level = flags_base.indentation_level;
          if (!this._output.just_added_newline() && flags_base.line_indent_level > next_indent_level) {
            next_indent_level = flags_base.line_indent_level;
          }
        }
        var next_flags = {
          mode,
          parent: flags_base,
          last_token: flags_base ? flags_base.last_token : new Token2(TOKEN.START_BLOCK, ""),
          last_word: flags_base ? flags_base.last_word : "",
          declaration_statement: false,
          declaration_assignment: false,
          multiline_frame: false,
          inline_frame: false,
          if_block: false,
          else_block: false,
          class_start_block: false,
          do_block: false,
          do_while: false,
          import_block: false,
          in_case_statement: false,
          in_case: false,
          case_body: false,
          case_block: false,
          indentation_level: next_indent_level,
          alignment: 0,
          line_indent_level: flags_base ? flags_base.line_indent_level : next_indent_level,
          start_line_index: this._output.get_line_number(),
          ternary_depth: 0
        };
        return next_flags;
      };
      Beautifier.prototype._reset = function(source_text) {
        var baseIndentString = source_text.match(/^[\t ]*/)[0];
        this._last_last_text = "";
        this._output = new Output(this._options, baseIndentString);
        this._output.raw = this._options.test_output_raw;
        this._flag_store = [];
        this.set_mode(MODE.BlockStatement);
        var tokenizer2 = new Tokenizer(source_text, this._options);
        this._tokens = tokenizer2.tokenize();
        return source_text;
      };
      Beautifier.prototype.beautify = function() {
        if (this._options.disabled) {
          return this._source_text;
        }
        var sweet_code;
        var source_text = this._reset(this._source_text);
        var eol = this._options.eol;
        if (this._options.eol === "auto") {
          eol = "\n";
          if (source_text && acorn2.lineBreak.test(source_text || "")) {
            eol = source_text.match(acorn2.lineBreak)[0];
          }
        }
        var current_token = this._tokens.next();
        while (current_token) {
          this.handle_token(current_token);
          this._last_last_text = this._flags.last_token.text;
          this._flags.last_token = current_token;
          current_token = this._tokens.next();
        }
        sweet_code = this._output.get_code(eol);
        return sweet_code;
      };
      Beautifier.prototype.handle_token = function(current_token, preserve_statement_flags) {
        if (current_token.type === TOKEN.START_EXPR) {
          this.handle_start_expr(current_token);
        } else if (current_token.type === TOKEN.END_EXPR) {
          this.handle_end_expr(current_token);
        } else if (current_token.type === TOKEN.START_BLOCK) {
          this.handle_start_block(current_token);
        } else if (current_token.type === TOKEN.END_BLOCK) {
          this.handle_end_block(current_token);
        } else if (current_token.type === TOKEN.WORD) {
          this.handle_word(current_token);
        } else if (current_token.type === TOKEN.RESERVED) {
          this.handle_word(current_token);
        } else if (current_token.type === TOKEN.SEMICOLON) {
          this.handle_semicolon(current_token);
        } else if (current_token.type === TOKEN.STRING) {
          this.handle_string(current_token);
        } else if (current_token.type === TOKEN.EQUALS) {
          this.handle_equals(current_token);
        } else if (current_token.type === TOKEN.OPERATOR) {
          this.handle_operator(current_token);
        } else if (current_token.type === TOKEN.COMMA) {
          this.handle_comma(current_token);
        } else if (current_token.type === TOKEN.BLOCK_COMMENT) {
          this.handle_block_comment(current_token, preserve_statement_flags);
        } else if (current_token.type === TOKEN.COMMENT) {
          this.handle_comment(current_token, preserve_statement_flags);
        } else if (current_token.type === TOKEN.DOT) {
          this.handle_dot(current_token);
        } else if (current_token.type === TOKEN.EOF) {
          this.handle_eof(current_token);
        } else if (current_token.type === TOKEN.UNKNOWN) {
          this.handle_unknown(current_token, preserve_statement_flags);
        } else {
          this.handle_unknown(current_token, preserve_statement_flags);
        }
      };
      Beautifier.prototype.handle_whitespace_and_comments = function(current_token, preserve_statement_flags) {
        var newlines = current_token.newlines;
        var keep_whitespace = this._options.keep_array_indentation && is_array(this._flags.mode);
        if (current_token.comments_before) {
          var comment_token = current_token.comments_before.next();
          while (comment_token) {
            this.handle_whitespace_and_comments(comment_token, preserve_statement_flags);
            this.handle_token(comment_token, preserve_statement_flags);
            comment_token = current_token.comments_before.next();
          }
        }
        if (keep_whitespace) {
          for (var i2 = 0; i2 < newlines; i2 += 1) {
            this.print_newline(i2 > 0, preserve_statement_flags);
          }
        } else {
          if (this._options.max_preserve_newlines && newlines > this._options.max_preserve_newlines) {
            newlines = this._options.max_preserve_newlines;
          }
          if (this._options.preserve_newlines) {
            if (newlines > 1) {
              this.print_newline(false, preserve_statement_flags);
              for (var j = 1; j < newlines; j += 1) {
                this.print_newline(true, preserve_statement_flags);
              }
            }
          }
        }
      };
      var newline_restricted_tokens = ["async", "break", "continue", "return", "throw", "yield"];
      Beautifier.prototype.allow_wrap_or_preserved_newline = function(current_token, force_linewrap) {
        force_linewrap = force_linewrap === void 0 ? false : force_linewrap;
        if (this._output.just_added_newline()) {
          return;
        }
        var shouldPreserveOrForce = this._options.preserve_newlines && current_token.newlines || force_linewrap;
        var operatorLogicApplies = in_array(this._flags.last_token.text, positionable_operators) || in_array(current_token.text, positionable_operators);
        if (operatorLogicApplies) {
          var shouldPrintOperatorNewline = in_array(this._flags.last_token.text, positionable_operators) && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE) || in_array(current_token.text, positionable_operators);
          shouldPreserveOrForce = shouldPreserveOrForce && shouldPrintOperatorNewline;
        }
        if (shouldPreserveOrForce) {
          this.print_newline(false, true);
        } else if (this._options.wrap_line_length) {
          if (reserved_array(this._flags.last_token, newline_restricted_tokens)) {
            return;
          }
          this._output.set_wrap_point();
        }
      };
      Beautifier.prototype.print_newline = function(force_newline, preserve_statement_flags) {
        if (!preserve_statement_flags) {
          if (this._flags.last_token.text !== ";" && this._flags.last_token.text !== "," && this._flags.last_token.text !== "=" && (this._flags.last_token.type !== TOKEN.OPERATOR || this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) {
            var next_token = this._tokens.peek();
            while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
              this.restore_mode();
            }
          }
        }
        if (this._output.add_new_line(force_newline)) {
          this._flags.multiline_frame = true;
        }
      };
      Beautifier.prototype.print_token_line_indentation = function(current_token) {
        if (this._output.just_added_newline()) {
          if (this._options.keep_array_indentation && current_token.newlines && (current_token.text === "[" || is_array(this._flags.mode))) {
            this._output.current_line.set_indent(-1);
            this._output.current_line.push(current_token.whitespace_before);
            this._output.space_before_token = false;
          } else if (this._output.set_indent(this._flags.indentation_level, this._flags.alignment)) {
            this._flags.line_indent_level = this._flags.indentation_level;
          }
        }
      };
      Beautifier.prototype.print_token = function(current_token) {
        if (this._output.raw) {
          this._output.add_raw_token(current_token);
          return;
        }
        if (this._options.comma_first && current_token.previous && current_token.previous.type === TOKEN.COMMA && this._output.just_added_newline()) {
          if (this._output.previous_line.last() === ",") {
            var popped = this._output.previous_line.pop();
            if (this._output.previous_line.is_empty()) {
              this._output.previous_line.push(popped);
              this._output.trim(true);
              this._output.current_line.pop();
              this._output.trim();
            }
            this.print_token_line_indentation(current_token);
            this._output.add_token(",");
            this._output.space_before_token = true;
          }
        }
        this.print_token_line_indentation(current_token);
        this._output.non_breaking_space = true;
        this._output.add_token(current_token.text);
        if (this._output.previous_token_wrapped) {
          this._flags.multiline_frame = true;
        }
      };
      Beautifier.prototype.indent = function() {
        this._flags.indentation_level += 1;
        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      };
      Beautifier.prototype.deindent = function() {
        if (this._flags.indentation_level > 0 && (!this._flags.parent || this._flags.indentation_level > this._flags.parent.indentation_level)) {
          this._flags.indentation_level -= 1;
          this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
        }
      };
      Beautifier.prototype.set_mode = function(mode) {
        if (this._flags) {
          this._flag_store.push(this._flags);
          this._previous_flags = this._flags;
        } else {
          this._previous_flags = this.create_flags(null, mode);
        }
        this._flags = this.create_flags(this._previous_flags, mode);
        this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
      };
      Beautifier.prototype.restore_mode = function() {
        if (this._flag_store.length > 0) {
          this._previous_flags = this._flags;
          this._flags = this._flag_store.pop();
          if (this._previous_flags.mode === MODE.Statement) {
            remove_redundant_indentation(this._output, this._previous_flags);
          }
          this._output.set_indent(this._flags.indentation_level, this._flags.alignment);
        }
      };
      Beautifier.prototype.start_of_object_property = function() {
        return this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
      };
      Beautifier.prototype.start_of_statement = function(current_token) {
        var start = false;
        start = start || reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD;
        start = start || reserved_word(this._flags.last_token, "do");
        start = start || !(this._flags.parent.mode === MODE.ObjectLiteral && this._flags.mode === MODE.Statement) && reserved_array(this._flags.last_token, newline_restricted_tokens) && !current_token.newlines;
        start = start || reserved_word(this._flags.last_token, "else") && !(reserved_word(current_token, "if") && !current_token.comments_before);
        start = start || this._flags.last_token.type === TOKEN.END_EXPR && (this._previous_flags.mode === MODE.ForInitializer || this._previous_flags.mode === MODE.Conditional);
        start = start || this._flags.last_token.type === TOKEN.WORD && this._flags.mode === MODE.BlockStatement && !this._flags.in_case && !(current_token.text === "--" || current_token.text === "++") && this._last_last_text !== "function" && current_token.type !== TOKEN.WORD && current_token.type !== TOKEN.RESERVED;
        start = start || this._flags.mode === MODE.ObjectLiteral && (this._flags.last_token.text === ":" && this._flags.ternary_depth === 0 || reserved_array(this._flags.last_token, ["get", "set"]));
        if (start) {
          this.set_mode(MODE.Statement);
          this.indent();
          this.handle_whitespace_and_comments(current_token, true);
          if (!this.start_of_object_property()) {
            this.allow_wrap_or_preserved_newline(current_token, reserved_array(current_token, ["do", "for", "if", "while"]));
          }
          return true;
        }
        return false;
      };
      Beautifier.prototype.handle_start_expr = function(current_token) {
        if (!this.start_of_statement(current_token)) {
          this.handle_whitespace_and_comments(current_token);
        }
        var next_mode = MODE.Expression;
        if (current_token.text === "[") {
          if (this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === ")") {
            if (reserved_array(this._flags.last_token, line_starters)) {
              this._output.space_before_token = true;
            }
            this.print_token(current_token);
            this.set_mode(next_mode);
            this.indent();
            if (this._options.space_in_paren) {
              this._output.space_before_token = true;
            }
            return;
          }
          next_mode = MODE.ArrayLiteral;
          if (is_array(this._flags.mode)) {
            if (this._flags.last_token.text === "[" || this._flags.last_token.text === "," && (this._last_last_text === "]" || this._last_last_text === "}")) {
              if (!this._options.keep_array_indentation) {
                this.print_newline();
              }
            }
          }
          if (!in_array(this._flags.last_token.type, [TOKEN.START_EXPR, TOKEN.END_EXPR, TOKEN.WORD, TOKEN.OPERATOR, TOKEN.DOT])) {
            this._output.space_before_token = true;
          }
        } else {
          if (this._flags.last_token.type === TOKEN.RESERVED) {
            if (this._flags.last_token.text === "for") {
              this._output.space_before_token = this._options.space_before_conditional;
              next_mode = MODE.ForInitializer;
            } else if (in_array(this._flags.last_token.text, ["if", "while", "switch"])) {
              this._output.space_before_token = this._options.space_before_conditional;
              next_mode = MODE.Conditional;
            } else if (in_array(this._flags.last_word, ["await", "async"])) {
              this._output.space_before_token = true;
            } else if (this._flags.last_token.text === "import" && current_token.whitespace_before === "") {
              this._output.space_before_token = false;
            } else if (in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === "catch") {
              this._output.space_before_token = true;
            }
          } else if (this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
            if (!this.start_of_object_property()) {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else if (this._flags.last_token.type === TOKEN.WORD) {
            this._output.space_before_token = false;
            var peek_back_two = this._tokens.peek(-3);
            if (this._options.space_after_named_function && peek_back_two) {
              var peek_back_three = this._tokens.peek(-4);
              if (reserved_array(peek_back_two, ["async", "function"]) || peek_back_two.text === "*" && reserved_array(peek_back_three, ["async", "function"])) {
                this._output.space_before_token = true;
              } else if (this._flags.mode === MODE.ObjectLiteral) {
                if (peek_back_two.text === "{" || peek_back_two.text === "," || peek_back_two.text === "*" && (peek_back_three.text === "{" || peek_back_three.text === ",")) {
                  this._output.space_before_token = true;
                }
              } else if (this._flags.parent && this._flags.parent.class_start_block) {
                this._output.space_before_token = true;
              }
            }
          } else {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          if (this._flags.last_token.type === TOKEN.RESERVED && (this._flags.last_word === "function" || this._flags.last_word === "typeof") || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
            this._output.space_before_token = this._options.space_after_anon_function;
          }
        }
        if (this._flags.last_token.text === ";" || this._flags.last_token.type === TOKEN.START_BLOCK) {
          this.print_newline();
        } else if (this._flags.last_token.type === TOKEN.END_EXPR || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.END_BLOCK || this._flags.last_token.text === "." || this._flags.last_token.type === TOKEN.COMMA) {
          this.allow_wrap_or_preserved_newline(current_token, current_token.newlines);
        }
        this.print_token(current_token);
        this.set_mode(next_mode);
        if (this._options.space_in_paren) {
          this._output.space_before_token = true;
        }
        this.indent();
      };
      Beautifier.prototype.handle_end_expr = function(current_token) {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this.handle_whitespace_and_comments(current_token);
        if (this._flags.multiline_frame) {
          this.allow_wrap_or_preserved_newline(current_token, current_token.text === "]" && is_array(this._flags.mode) && !this._options.keep_array_indentation);
        }
        if (this._options.space_in_paren) {
          if (this._flags.last_token.type === TOKEN.START_EXPR && !this._options.space_in_empty_paren) {
            this._output.trim();
            this._output.space_before_token = false;
          } else {
            this._output.space_before_token = true;
          }
        }
        this.deindent();
        this.print_token(current_token);
        this.restore_mode();
        remove_redundant_indentation(this._output, this._previous_flags);
        if (this._flags.do_while && this._previous_flags.mode === MODE.Conditional) {
          this._previous_flags.mode = MODE.Expression;
          this._flags.do_block = false;
          this._flags.do_while = false;
        }
      };
      Beautifier.prototype.handle_start_block = function(current_token) {
        this.handle_whitespace_and_comments(current_token);
        var next_token = this._tokens.peek();
        var second_token = this._tokens.peek(1);
        if (this._flags.last_word === "switch" && this._flags.last_token.type === TOKEN.END_EXPR) {
          this.set_mode(MODE.BlockStatement);
          this._flags.in_case_statement = true;
        } else if (this._flags.case_body) {
          this.set_mode(MODE.BlockStatement);
        } else if (second_token && (in_array(second_token.text, [":", ","]) && in_array(next_token.type, [TOKEN.STRING, TOKEN.WORD, TOKEN.RESERVED]) || in_array(next_token.text, ["get", "set", "..."]) && in_array(second_token.type, [TOKEN.WORD, TOKEN.RESERVED]))) {
          if (in_array(this._last_last_text, ["class", "interface"]) && !in_array(second_token.text, [":", ","])) {
            this.set_mode(MODE.BlockStatement);
          } else {
            this.set_mode(MODE.ObjectLiteral);
          }
        } else if (this._flags.last_token.type === TOKEN.OPERATOR && this._flags.last_token.text === "=>") {
          this.set_mode(MODE.BlockStatement);
        } else if (in_array(this._flags.last_token.type, [TOKEN.EQUALS, TOKEN.START_EXPR, TOKEN.COMMA, TOKEN.OPERATOR]) || reserved_array(this._flags.last_token, ["return", "throw", "import", "default"])) {
          this.set_mode(MODE.ObjectLiteral);
        } else {
          this.set_mode(MODE.BlockStatement);
        }
        if (this._flags.last_token) {
          if (reserved_array(this._flags.last_token.previous, ["class", "extends"])) {
            this._flags.class_start_block = true;
          }
        }
        var empty_braces = !next_token.comments_before && next_token.text === "}";
        var empty_anonymous_function = empty_braces && this._flags.last_word === "function" && this._flags.last_token.type === TOKEN.END_EXPR;
        if (this._options.brace_preserve_inline) {
          var index = 0;
          var check_token = null;
          this._flags.inline_frame = true;
          do {
            index += 1;
            check_token = this._tokens.peek(index - 1);
            if (check_token.newlines) {
              this._flags.inline_frame = false;
              break;
            }
          } while (check_token.type !== TOKEN.EOF && !(check_token.type === TOKEN.END_BLOCK && check_token.opened === current_token));
        }
        if ((this._options.brace_style === "expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
          if (this._flags.last_token.type !== TOKEN.OPERATOR && (empty_anonymous_function || this._flags.last_token.type === TOKEN.EQUALS || reserved_array(this._flags.last_token, special_words) && this._flags.last_token.text !== "else")) {
            this._output.space_before_token = true;
          } else {
            this.print_newline(false, true);
          }
        } else {
          if (is_array(this._previous_flags.mode) && (this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.COMMA)) {
            if (this._flags.last_token.type === TOKEN.COMMA || this._options.space_in_paren) {
              this._output.space_before_token = true;
            }
            if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR && this._flags.inline_frame) {
              this.allow_wrap_or_preserved_newline(current_token);
              this._previous_flags.multiline_frame = this._previous_flags.multiline_frame || this._flags.multiline_frame;
              this._flags.multiline_frame = false;
            }
          }
          if (this._flags.last_token.type !== TOKEN.OPERATOR && this._flags.last_token.type !== TOKEN.START_EXPR) {
            if (this._flags.last_token.type === TOKEN.START_BLOCK && !this._flags.inline_frame) {
              this.print_newline();
            } else {
              this._output.space_before_token = true;
            }
          }
        }
        this.print_token(current_token);
        this.indent();
        if (!empty_braces && !(this._options.brace_preserve_inline && this._flags.inline_frame)) {
          this.print_newline();
        }
      };
      Beautifier.prototype.handle_end_block = function(current_token) {
        this.handle_whitespace_and_comments(current_token);
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        var empty_braces = this._flags.last_token.type === TOKEN.START_BLOCK;
        if (this._flags.inline_frame && !empty_braces) {
          this._output.space_before_token = true;
        } else if (this._options.brace_style === "expand") {
          if (!empty_braces) {
            this.print_newline();
          }
        } else {
          if (!empty_braces) {
            if (is_array(this._flags.mode) && this._options.keep_array_indentation) {
              this._options.keep_array_indentation = false;
              this.print_newline();
              this._options.keep_array_indentation = true;
            } else {
              this.print_newline();
            }
          }
        }
        this.restore_mode();
        this.print_token(current_token);
      };
      Beautifier.prototype.handle_word = function(current_token) {
        if (current_token.type === TOKEN.RESERVED) {
          if (in_array(current_token.text, ["set", "get"]) && this._flags.mode !== MODE.ObjectLiteral) {
            current_token.type = TOKEN.WORD;
          } else if (current_token.text === "import" && in_array(this._tokens.peek().text, ["(", "."])) {
            current_token.type = TOKEN.WORD;
          } else if (in_array(current_token.text, ["as", "from"]) && !this._flags.import_block) {
            current_token.type = TOKEN.WORD;
          } else if (this._flags.mode === MODE.ObjectLiteral) {
            var next_token = this._tokens.peek();
            if (next_token.text === ":") {
              current_token.type = TOKEN.WORD;
            }
          }
        }
        if (this.start_of_statement(current_token)) {
          if (reserved_array(this._flags.last_token, ["var", "let", "const"]) && current_token.type === TOKEN.WORD) {
            this._flags.declaration_statement = true;
          }
        } else if (current_token.newlines && !is_expression(this._flags.mode) && (this._flags.last_token.type !== TOKEN.OPERATOR || (this._flags.last_token.text === "--" || this._flags.last_token.text === "++")) && this._flags.last_token.type !== TOKEN.EQUALS && (this._options.preserve_newlines || !reserved_array(this._flags.last_token, ["var", "let", "const", "set", "get"]))) {
          this.handle_whitespace_and_comments(current_token);
          this.print_newline();
        } else {
          this.handle_whitespace_and_comments(current_token);
        }
        if (this._flags.do_block && !this._flags.do_while) {
          if (reserved_word(current_token, "while")) {
            this._output.space_before_token = true;
            this.print_token(current_token);
            this._output.space_before_token = true;
            this._flags.do_while = true;
            return;
          } else {
            this.print_newline();
            this._flags.do_block = false;
          }
        }
        if (this._flags.if_block) {
          if (!this._flags.else_block && reserved_word(current_token, "else")) {
            this._flags.else_block = true;
          } else {
            while (this._flags.mode === MODE.Statement) {
              this.restore_mode();
            }
            this._flags.if_block = false;
            this._flags.else_block = false;
          }
        }
        if (this._flags.in_case_statement && reserved_array(current_token, ["case", "default"])) {
          this.print_newline();
          if (!this._flags.case_block && (this._flags.case_body || this._options.jslint_happy)) {
            this.deindent();
          }
          this._flags.case_body = false;
          this.print_token(current_token);
          this._flags.in_case = true;
          return;
        }
        if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
          if (!this.start_of_object_property()) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        }
        if (reserved_word(current_token, "function")) {
          if (in_array(this._flags.last_token.text, ["}", ";"]) || this._output.just_added_newline() && !(in_array(this._flags.last_token.text, ["(", "[", "{", ":", "=", ","]) || this._flags.last_token.type === TOKEN.OPERATOR)) {
            if (!this._output.just_added_blankline() && !current_token.comments_before) {
              this.print_newline();
              this.print_newline(true);
            }
          }
          if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD) {
            if (reserved_array(this._flags.last_token, ["get", "set", "new", "export"]) || reserved_array(this._flags.last_token, newline_restricted_tokens)) {
              this._output.space_before_token = true;
            } else if (reserved_word(this._flags.last_token, "default") && this._last_last_text === "export") {
              this._output.space_before_token = true;
            } else if (this._flags.last_token.text === "declare") {
              this._output.space_before_token = true;
            } else {
              this.print_newline();
            }
          } else if (this._flags.last_token.type === TOKEN.OPERATOR || this._flags.last_token.text === "=") {
            this._output.space_before_token = true;
          } else if (!this._flags.multiline_frame && (is_expression(this._flags.mode) || is_array(this._flags.mode)))
            ;
          else {
            this.print_newline();
          }
          this.print_token(current_token);
          this._flags.last_word = current_token.text;
          return;
        }
        var prefix = "NONE";
        if (this._flags.last_token.type === TOKEN.END_BLOCK) {
          if (this._previous_flags.inline_frame) {
            prefix = "SPACE";
          } else if (!reserved_array(current_token, ["else", "catch", "finally", "from"])) {
            prefix = "NEWLINE";
          } else {
            if (this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) {
              prefix = "NEWLINE";
            } else {
              prefix = "SPACE";
              this._output.space_before_token = true;
            }
          }
        } else if (this._flags.last_token.type === TOKEN.SEMICOLON && this._flags.mode === MODE.BlockStatement) {
          prefix = "NEWLINE";
        } else if (this._flags.last_token.type === TOKEN.SEMICOLON && is_expression(this._flags.mode)) {
          prefix = "SPACE";
        } else if (this._flags.last_token.type === TOKEN.STRING) {
          prefix = "NEWLINE";
        } else if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.last_token.text === "*" && (in_array(this._last_last_text, ["function", "yield"]) || this._flags.mode === MODE.ObjectLiteral && in_array(this._last_last_text, ["{", ","]))) {
          prefix = "SPACE";
        } else if (this._flags.last_token.type === TOKEN.START_BLOCK) {
          if (this._flags.inline_frame) {
            prefix = "SPACE";
          } else {
            prefix = "NEWLINE";
          }
        } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
          this._output.space_before_token = true;
          prefix = "NEWLINE";
        }
        if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
          if (this._flags.inline_frame || this._flags.last_token.text === "else" || this._flags.last_token.text === "export") {
            prefix = "SPACE";
          } else {
            prefix = "NEWLINE";
          }
        }
        if (reserved_array(current_token, ["else", "catch", "finally"])) {
          if ((!(this._flags.last_token.type === TOKEN.END_BLOCK && this._previous_flags.mode === MODE.BlockStatement) || this._options.brace_style === "expand" || this._options.brace_style === "end-expand" || this._options.brace_style === "none" && current_token.newlines) && !this._flags.inline_frame) {
            this.print_newline();
          } else {
            this._output.trim(true);
            var line = this._output.current_line;
            if (line.last() !== "}") {
              this.print_newline();
            }
            this._output.space_before_token = true;
          }
        } else if (prefix === "NEWLINE") {
          if (reserved_array(this._flags.last_token, special_words)) {
            this._output.space_before_token = true;
          } else if (this._flags.last_token.text === "declare" && reserved_array(current_token, ["var", "let", "const"])) {
            this._output.space_before_token = true;
          } else if (this._flags.last_token.type !== TOKEN.END_EXPR) {
            if ((this._flags.last_token.type !== TOKEN.START_EXPR || !reserved_array(current_token, ["var", "let", "const"])) && this._flags.last_token.text !== ":") {
              if (reserved_word(current_token, "if") && reserved_word(current_token.previous, "else")) {
                this._output.space_before_token = true;
              } else {
                this.print_newline();
              }
            }
          } else if (reserved_array(current_token, line_starters) && this._flags.last_token.text !== ")") {
            this.print_newline();
          }
        } else if (this._flags.multiline_frame && is_array(this._flags.mode) && this._flags.last_token.text === "," && this._last_last_text === "}") {
          this.print_newline();
        } else if (prefix === "SPACE") {
          this._output.space_before_token = true;
        }
        if (current_token.previous && (current_token.previous.type === TOKEN.WORD || current_token.previous.type === TOKEN.RESERVED)) {
          this._output.space_before_token = true;
        }
        this.print_token(current_token);
        this._flags.last_word = current_token.text;
        if (current_token.type === TOKEN.RESERVED) {
          if (current_token.text === "do") {
            this._flags.do_block = true;
          } else if (current_token.text === "if") {
            this._flags.if_block = true;
          } else if (current_token.text === "import") {
            this._flags.import_block = true;
          } else if (this._flags.import_block && reserved_word(current_token, "from")) {
            this._flags.import_block = false;
          }
        }
      };
      Beautifier.prototype.handle_semicolon = function(current_token) {
        if (this.start_of_statement(current_token)) {
          this._output.space_before_token = false;
        } else {
          this.handle_whitespace_and_comments(current_token);
        }
        var next_token = this._tokens.peek();
        while (this._flags.mode === MODE.Statement && !(this._flags.if_block && reserved_word(next_token, "else")) && !this._flags.do_block) {
          this.restore_mode();
        }
        if (this._flags.import_block) {
          this._flags.import_block = false;
        }
        this.print_token(current_token);
      };
      Beautifier.prototype.handle_string = function(current_token) {
        if (current_token.text.startsWith("`") && current_token.newlines === 0 && current_token.whitespace_before === "" && (current_token.previous.text === ")" || this._flags.last_token.type === TOKEN.WORD))
          ;
        else if (this.start_of_statement(current_token)) {
          this._output.space_before_token = true;
        } else {
          this.handle_whitespace_and_comments(current_token);
          if (this._flags.last_token.type === TOKEN.RESERVED || this._flags.last_token.type === TOKEN.WORD || this._flags.inline_frame) {
            this._output.space_before_token = true;
          } else if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR || this._flags.last_token.type === TOKEN.EQUALS || this._flags.last_token.type === TOKEN.OPERATOR) {
            if (!this.start_of_object_property()) {
              this.allow_wrap_or_preserved_newline(current_token);
            }
          } else if (current_token.text.startsWith("`") && this._flags.last_token.type === TOKEN.END_EXPR && (current_token.previous.text === "]" || current_token.previous.text === ")") && current_token.newlines === 0) {
            this._output.space_before_token = true;
          } else {
            this.print_newline();
          }
        }
        this.print_token(current_token);
      };
      Beautifier.prototype.handle_equals = function(current_token) {
        if (this.start_of_statement(current_token))
          ;
        else {
          this.handle_whitespace_and_comments(current_token);
        }
        if (this._flags.declaration_statement) {
          this._flags.declaration_assignment = true;
        }
        this._output.space_before_token = true;
        this.print_token(current_token);
        this._output.space_before_token = true;
      };
      Beautifier.prototype.handle_comma = function(current_token) {
        this.handle_whitespace_and_comments(current_token, true);
        this.print_token(current_token);
        this._output.space_before_token = true;
        if (this._flags.declaration_statement) {
          if (is_expression(this._flags.parent.mode)) {
            this._flags.declaration_assignment = false;
          }
          if (this._flags.declaration_assignment) {
            this._flags.declaration_assignment = false;
            this.print_newline(false, true);
          } else if (this._options.comma_first) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
        } else if (this._flags.mode === MODE.ObjectLiteral || this._flags.mode === MODE.Statement && this._flags.parent.mode === MODE.ObjectLiteral) {
          if (this._flags.mode === MODE.Statement) {
            this.restore_mode();
          }
          if (!this._flags.inline_frame) {
            this.print_newline();
          }
        } else if (this._options.comma_first) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
      };
      Beautifier.prototype.handle_operator = function(current_token) {
        var isGeneratorAsterisk = current_token.text === "*" && (reserved_array(this._flags.last_token, ["function", "yield"]) || in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.COMMA, TOKEN.END_BLOCK, TOKEN.SEMICOLON]));
        var isUnary = in_array(current_token.text, ["-", "+"]) && (in_array(this._flags.last_token.type, [TOKEN.START_BLOCK, TOKEN.START_EXPR, TOKEN.EQUALS, TOKEN.OPERATOR]) || in_array(this._flags.last_token.text, line_starters) || this._flags.last_token.text === ",");
        if (this.start_of_statement(current_token))
          ;
        else {
          var preserve_statement_flags = !isGeneratorAsterisk;
          this.handle_whitespace_and_comments(current_token, preserve_statement_flags);
        }
        if (current_token.text === "*" && this._flags.last_token.type === TOKEN.DOT) {
          this.print_token(current_token);
          return;
        }
        if (current_token.text === "::") {
          this.print_token(current_token);
          return;
        }
        if (this._flags.last_token.type === TOKEN.OPERATOR && in_array(this._options.operator_position, OPERATOR_POSITION_BEFORE_OR_PRESERVE)) {
          this.allow_wrap_or_preserved_newline(current_token);
        }
        if (current_token.text === ":" && this._flags.in_case) {
          this.print_token(current_token);
          this._flags.in_case = false;
          this._flags.case_body = true;
          if (this._tokens.peek().type !== TOKEN.START_BLOCK) {
            this.indent();
            this.print_newline();
            this._flags.case_block = false;
          } else {
            this._flags.case_block = true;
            this._output.space_before_token = true;
          }
          return;
        }
        var space_before = true;
        var space_after = true;
        var in_ternary = false;
        if (current_token.text === ":") {
          if (this._flags.ternary_depth === 0) {
            space_before = false;
          } else {
            this._flags.ternary_depth -= 1;
            in_ternary = true;
          }
        } else if (current_token.text === "?") {
          this._flags.ternary_depth += 1;
        }
        if (!isUnary && !isGeneratorAsterisk && this._options.preserve_newlines && in_array(current_token.text, positionable_operators)) {
          var isColon = current_token.text === ":";
          var isTernaryColon = isColon && in_ternary;
          var isOtherColon = isColon && !in_ternary;
          switch (this._options.operator_position) {
            case OPERATOR_POSITION.before_newline:
              this._output.space_before_token = !isOtherColon;
              this.print_token(current_token);
              if (!isColon || isTernaryColon) {
                this.allow_wrap_or_preserved_newline(current_token);
              }
              this._output.space_before_token = true;
              return;
            case OPERATOR_POSITION.after_newline:
              this._output.space_before_token = true;
              if (!isColon || isTernaryColon) {
                if (this._tokens.peek().newlines) {
                  this.print_newline(false, true);
                } else {
                  this.allow_wrap_or_preserved_newline(current_token);
                }
              } else {
                this._output.space_before_token = false;
              }
              this.print_token(current_token);
              this._output.space_before_token = true;
              return;
            case OPERATOR_POSITION.preserve_newline:
              if (!isOtherColon) {
                this.allow_wrap_or_preserved_newline(current_token);
              }
              space_before = !(this._output.just_added_newline() || isOtherColon);
              this._output.space_before_token = space_before;
              this.print_token(current_token);
              this._output.space_before_token = true;
              return;
          }
        }
        if (isGeneratorAsterisk) {
          this.allow_wrap_or_preserved_newline(current_token);
          space_before = false;
          var next_token = this._tokens.peek();
          space_after = next_token && in_array(next_token.type, [TOKEN.WORD, TOKEN.RESERVED]);
        } else if (current_token.text === "...") {
          this.allow_wrap_or_preserved_newline(current_token);
          space_before = this._flags.last_token.type === TOKEN.START_BLOCK;
          space_after = false;
        } else if (in_array(current_token.text, ["--", "++", "!", "~"]) || isUnary) {
          if (this._flags.last_token.type === TOKEN.COMMA || this._flags.last_token.type === TOKEN.START_EXPR) {
            this.allow_wrap_or_preserved_newline(current_token);
          }
          space_before = false;
          space_after = false;
          if (current_token.newlines && (current_token.text === "--" || current_token.text === "++" || current_token.text === "~")) {
            var new_line_needed = reserved_array(this._flags.last_token, special_words) && current_token.newlines;
            if (new_line_needed && (this._previous_flags.if_block || this._previous_flags.else_block)) {
              this.restore_mode();
            }
            this.print_newline(new_line_needed, true);
          }
          if (this._flags.last_token.text === ";" && is_expression(this._flags.mode)) {
            space_before = true;
          }
          if (this._flags.last_token.type === TOKEN.RESERVED) {
            space_before = true;
          } else if (this._flags.last_token.type === TOKEN.END_EXPR) {
            space_before = !(this._flags.last_token.text === "]" && (current_token.text === "--" || current_token.text === "++"));
          } else if (this._flags.last_token.type === TOKEN.OPERATOR) {
            space_before = in_array(current_token.text, ["--", "-", "++", "+"]) && in_array(this._flags.last_token.text, ["--", "-", "++", "+"]);
            if (in_array(current_token.text, ["+", "-"]) && in_array(this._flags.last_token.text, ["--", "++"])) {
              space_after = true;
            }
          }
          if ((this._flags.mode === MODE.BlockStatement && !this._flags.inline_frame || this._flags.mode === MODE.Statement) && (this._flags.last_token.text === "{" || this._flags.last_token.text === ";")) {
            this.print_newline();
          }
        }
        this._output.space_before_token = this._output.space_before_token || space_before;
        this.print_token(current_token);
        this._output.space_before_token = space_after;
      };
      Beautifier.prototype.handle_block_comment = function(current_token, preserve_statement_flags) {
        if (this._output.raw) {
          this._output.add_raw_token(current_token);
          if (current_token.directives && current_token.directives.preserve === "end") {
            this._output.raw = this._options.test_output_raw;
          }
          return;
        }
        if (current_token.directives) {
          this.print_newline(false, preserve_statement_flags);
          this.print_token(current_token);
          if (current_token.directives.preserve === "start") {
            this._output.raw = true;
          }
          this.print_newline(false, true);
          return;
        }
        if (!acorn2.newline.test(current_token.text) && !current_token.newlines) {
          this._output.space_before_token = true;
          this.print_token(current_token);
          this._output.space_before_token = true;
          return;
        } else {
          this.print_block_commment(current_token, preserve_statement_flags);
        }
      };
      Beautifier.prototype.print_block_commment = function(current_token, preserve_statement_flags) {
        var lines = split_linebreaks(current_token.text);
        var j;
        var javadoc = false;
        var starless = false;
        var lastIndent = current_token.whitespace_before;
        var lastIndentLength = lastIndent.length;
        this.print_newline(false, preserve_statement_flags);
        this.print_token_line_indentation(current_token);
        this._output.add_token(lines[0]);
        this.print_newline(false, preserve_statement_flags);
        if (lines.length > 1) {
          lines = lines.slice(1);
          javadoc = all_lines_start_with(lines, "*");
          starless = each_line_matches_indent(lines, lastIndent);
          if (javadoc) {
            this._flags.alignment = 1;
          }
          for (j = 0; j < lines.length; j++) {
            if (javadoc) {
              this.print_token_line_indentation(current_token);
              this._output.add_token(ltrim(lines[j]));
            } else if (starless && lines[j]) {
              this.print_token_line_indentation(current_token);
              this._output.add_token(lines[j].substring(lastIndentLength));
            } else {
              this._output.current_line.set_indent(-1);
              this._output.add_token(lines[j]);
            }
            this.print_newline(false, preserve_statement_flags);
          }
          this._flags.alignment = 0;
        }
      };
      Beautifier.prototype.handle_comment = function(current_token, preserve_statement_flags) {
        if (current_token.newlines) {
          this.print_newline(false, preserve_statement_flags);
        } else {
          this._output.trim(true);
        }
        this._output.space_before_token = true;
        this.print_token(current_token);
        this.print_newline(false, preserve_statement_flags);
      };
      Beautifier.prototype.handle_dot = function(current_token) {
        if (this.start_of_statement(current_token))
          ;
        else {
          this.handle_whitespace_and_comments(current_token, true);
        }
        if (this._flags.last_token.text.match("^[0-9]+$")) {
          this._output.space_before_token = true;
        }
        if (reserved_array(this._flags.last_token, special_words)) {
          this._output.space_before_token = false;
        } else {
          this.allow_wrap_or_preserved_newline(current_token, this._flags.last_token.text === ")" && this._options.break_chained_methods);
        }
        if (this._options.unindent_chained_methods && this._output.just_added_newline()) {
          this.deindent();
        }
        this.print_token(current_token);
      };
      Beautifier.prototype.handle_unknown = function(current_token, preserve_statement_flags) {
        this.print_token(current_token);
        if (current_token.text[current_token.text.length - 1] === "\n") {
          this.print_newline(false, preserve_statement_flags);
        }
      };
      Beautifier.prototype.handle_eof = function(current_token) {
        while (this._flags.mode === MODE.Statement) {
          this.restore_mode();
        }
        this.handle_whitespace_and_comments(current_token);
      };
      beautifier$2.Beautifier = Beautifier;
      return beautifier$2;
    }
    var hasRequiredJavascript;
    function requireJavascript() {
      if (hasRequiredJavascript)
        return javascriptExports;
      hasRequiredJavascript = 1;
      var Beautifier = requireBeautifier$2().Beautifier, Options = requireOptions$2().Options;
      function js_beautify(js_source_text, options2) {
        var beautifier2 = new Beautifier(js_source_text, options2);
        return beautifier2.beautify();
      }
      javascript.exports = js_beautify;
      javascriptExports.defaultOptions = function() {
        return new Options();
      };
      return javascriptExports;
    }
    var cssExports = {};
    var css = {
      get exports() {
        return cssExports;
      },
      set exports(v) {
        cssExports = v;
      }
    };
    var beautifier$1 = {};
    var options$1 = {};
    var hasRequiredOptions$1;
    function requireOptions$1() {
      if (hasRequiredOptions$1)
        return options$1;
      hasRequiredOptions$1 = 1;
      var BaseOptions = requireOptions$3().Options;
      function Options(options2) {
        BaseOptions.call(this, options2, "css");
        this.selector_separator_newline = this._get_boolean("selector_separator_newline", true);
        this.newline_between_rules = this._get_boolean("newline_between_rules", true);
        var space_around_selector_separator = this._get_boolean("space_around_selector_separator");
        this.space_around_combinator = this._get_boolean("space_around_combinator") || space_around_selector_separator;
        var brace_style_split = this._get_selection_list("brace_style", ["collapse", "expand", "end-expand", "none", "preserve-inline"]);
        this.brace_style = "collapse";
        for (var bs = 0; bs < brace_style_split.length; bs++) {
          if (brace_style_split[bs] !== "expand") {
            this.brace_style = "collapse";
          } else {
            this.brace_style = brace_style_split[bs];
          }
        }
      }
      Options.prototype = new BaseOptions();
      options$1.Options = Options;
      return options$1;
    }
    var hasRequiredBeautifier$1;
    function requireBeautifier$1() {
      if (hasRequiredBeautifier$1)
        return beautifier$1;
      hasRequiredBeautifier$1 = 1;
      var Options = requireOptions$1().Options;
      var Output = requireOutput().Output;
      var InputScanner = requireInputscanner().InputScanner;
      var Directives = requireDirectives().Directives;
      var directives_core = new Directives(/\/\*/, /\*\//);
      var lineBreak = /\r\n|[\r\n]/;
      var allLineBreaks = /\r\n|[\r\n]/g;
      var whitespaceChar = /\s/;
      var whitespacePattern = /(?:\s|\n)+/g;
      var block_comment_pattern = /\/\*(?:[\s\S]*?)((?:\*\/)|$)/g;
      var comment_pattern = /\/\/(?:[^\n\r\u2028\u2029]*)/g;
      function Beautifier(source_text, options2) {
        this._source_text = source_text || "";
        this._options = new Options(options2);
        this._ch = null;
        this._input = null;
        this.NESTED_AT_RULE = {
          "@page": true,
          "@font-face": true,
          "@keyframes": true,
          "@media": true,
          "@supports": true,
          "@document": true
        };
        this.CONDITIONAL_GROUP_RULE = {
          "@media": true,
          "@supports": true,
          "@document": true
        };
        this.NON_SEMICOLON_NEWLINE_PROPERTY = [
          "grid-template-areas",
          "grid-template"
        ];
      }
      Beautifier.prototype.eatString = function(endChars) {
        var result = "";
        this._ch = this._input.next();
        while (this._ch) {
          result += this._ch;
          if (this._ch === "\\") {
            result += this._input.next();
          } else if (endChars.indexOf(this._ch) !== -1 || this._ch === "\n") {
            break;
          }
          this._ch = this._input.next();
        }
        return result;
      };
      Beautifier.prototype.eatWhitespace = function(allowAtLeastOneNewLine) {
        var result = whitespaceChar.test(this._input.peek());
        var newline_count = 0;
        while (whitespaceChar.test(this._input.peek())) {
          this._ch = this._input.next();
          if (allowAtLeastOneNewLine && this._ch === "\n") {
            if (newline_count === 0 || newline_count < this._options.max_preserve_newlines) {
              newline_count++;
              this._output.add_new_line(true);
            }
          }
        }
        return result;
      };
      Beautifier.prototype.foundNestedPseudoClass = function() {
        var openParen = 0;
        var i2 = 1;
        var ch = this._input.peek(i2);
        while (ch) {
          if (ch === "{") {
            return true;
          } else if (ch === "(") {
            openParen += 1;
          } else if (ch === ")") {
            if (openParen === 0) {
              return false;
            }
            openParen -= 1;
          } else if (ch === ";" || ch === "}") {
            return false;
          }
          i2++;
          ch = this._input.peek(i2);
        }
        return false;
      };
      Beautifier.prototype.print_string = function(output_string) {
        this._output.set_indent(this._indentLevel);
        this._output.non_breaking_space = true;
        this._output.add_token(output_string);
      };
      Beautifier.prototype.preserveSingleSpace = function(isAfterSpace) {
        if (isAfterSpace) {
          this._output.space_before_token = true;
        }
      };
      Beautifier.prototype.indent = function() {
        this._indentLevel++;
      };
      Beautifier.prototype.outdent = function() {
        if (this._indentLevel > 0) {
          this._indentLevel--;
        }
      };
      Beautifier.prototype.beautify = function() {
        if (this._options.disabled) {
          return this._source_text;
        }
        var source_text = this._source_text;
        var eol = this._options.eol;
        if (eol === "auto") {
          eol = "\n";
          if (source_text && lineBreak.test(source_text || "")) {
            eol = source_text.match(lineBreak)[0];
          }
        }
        source_text = source_text.replace(allLineBreaks, "\n");
        var baseIndentString = source_text.match(/^[\t ]*/)[0];
        this._output = new Output(this._options, baseIndentString);
        this._input = new InputScanner(source_text);
        this._indentLevel = 0;
        this._nestedLevel = 0;
        this._ch = null;
        var parenLevel = 0;
        var insideRule = false;
        var insidePropertyValue = false;
        var enteringConditionalGroup = false;
        var insideAtExtend = false;
        var insideAtImport = false;
        var insideScssMap = false;
        var topCharacter = this._ch;
        var insideNonSemiColonValues = false;
        var whitespace;
        var isAfterSpace;
        var previous_ch;
        while (true) {
          whitespace = this._input.read(whitespacePattern);
          isAfterSpace = whitespace !== "";
          previous_ch = topCharacter;
          this._ch = this._input.next();
          if (this._ch === "\\" && this._input.hasNext()) {
            this._ch += this._input.next();
          }
          topCharacter = this._ch;
          if (!this._ch) {
            break;
          } else if (this._ch === "/" && this._input.peek() === "*") {
            this._output.add_new_line();
            this._input.back();
            var comment2 = this._input.read(block_comment_pattern);
            var directives2 = directives_core.get_directives(comment2);
            if (directives2 && directives2.ignore === "start") {
              comment2 += directives_core.readIgnored(this._input);
            }
            this.print_string(comment2);
            this.eatWhitespace(true);
            this._output.add_new_line();
          } else if (this._ch === "/" && this._input.peek() === "/") {
            this._output.space_before_token = true;
            this._input.back();
            this.print_string(this._input.read(comment_pattern));
            this.eatWhitespace(true);
          } else if (this._ch === "@" || this._ch === "$") {
            this.preserveSingleSpace(isAfterSpace);
            if (this._input.peek() === "{") {
              this.print_string(this._ch + this.eatString("}"));
            } else {
              this.print_string(this._ch);
              var variableOrRule = this._input.peekUntilAfter(/[: ,;{}()[\]\/='"]/g);
              if (variableOrRule.match(/[ :]$/)) {
                variableOrRule = this.eatString(": ").replace(/\s$/, "");
                this.print_string(variableOrRule);
                this._output.space_before_token = true;
              }
              variableOrRule = variableOrRule.replace(/\s$/, "");
              if (variableOrRule === "extend") {
                insideAtExtend = true;
              } else if (variableOrRule === "import") {
                insideAtImport = true;
              }
              if (variableOrRule in this.NESTED_AT_RULE) {
                this._nestedLevel += 1;
                if (variableOrRule in this.CONDITIONAL_GROUP_RULE) {
                  enteringConditionalGroup = true;
                }
              } else if (!insideRule && parenLevel === 0 && variableOrRule.indexOf(":") !== -1) {
                insidePropertyValue = true;
                this.indent();
              }
            }
          } else if (this._ch === "#" && this._input.peek() === "{") {
            this.preserveSingleSpace(isAfterSpace);
            this.print_string(this._ch + this.eatString("}"));
          } else if (this._ch === "{") {
            if (insidePropertyValue) {
              insidePropertyValue = false;
              this.outdent();
            }
            if (enteringConditionalGroup) {
              enteringConditionalGroup = false;
              insideRule = this._indentLevel >= this._nestedLevel;
            } else {
              insideRule = this._indentLevel >= this._nestedLevel - 1;
            }
            if (this._options.newline_between_rules && insideRule) {
              if (this._output.previous_line && this._output.previous_line.item(-1) !== "{") {
                this._output.ensure_empty_line_above("/", ",");
              }
            }
            this._output.space_before_token = true;
            if (this._options.brace_style === "expand") {
              this._output.add_new_line();
              this.print_string(this._ch);
              this.indent();
              this._output.set_indent(this._indentLevel);
            } else {
              if (previous_ch === "(") {
                this._output.space_before_token = false;
              } else if (previous_ch !== ",") {
                this.indent();
              }
              this.print_string(this._ch);
            }
            this.eatWhitespace(true);
            this._output.add_new_line();
          } else if (this._ch === "}") {
            this.outdent();
            this._output.add_new_line();
            if (previous_ch === "{") {
              this._output.trim(true);
            }
            insideAtImport = false;
            insideAtExtend = false;
            if (insidePropertyValue) {
              this.outdent();
              insidePropertyValue = false;
            }
            this.print_string(this._ch);
            insideRule = false;
            if (this._nestedLevel) {
              this._nestedLevel--;
            }
            this.eatWhitespace(true);
            this._output.add_new_line();
            if (this._options.newline_between_rules && !this._output.just_added_blankline()) {
              if (this._input.peek() !== "}") {
                this._output.add_new_line(true);
              }
            }
            if (this._input.peek() === ")") {
              this._output.trim(true);
              if (this._options.brace_style === "expand") {
                this._output.add_new_line(true);
              }
            }
          } else if (this._ch === ":") {
            for (var i2 = 0; i2 < this.NON_SEMICOLON_NEWLINE_PROPERTY.length; i2++) {
              if (this._input.lookBack(this.NON_SEMICOLON_NEWLINE_PROPERTY[i2])) {
                insideNonSemiColonValues = true;
                break;
              }
            }
            if ((insideRule || enteringConditionalGroup) && !(this._input.lookBack("&") || this.foundNestedPseudoClass()) && !this._input.lookBack("(") && !insideAtExtend && parenLevel === 0) {
              this.print_string(":");
              if (!insidePropertyValue) {
                insidePropertyValue = true;
                this._output.space_before_token = true;
                this.eatWhitespace(true);
                this.indent();
              }
            } else {
              if (this._input.lookBack(" ")) {
                this._output.space_before_token = true;
              }
              if (this._input.peek() === ":") {
                this._ch = this._input.next();
                this.print_string("::");
              } else {
                this.print_string(":");
              }
            }
          } else if (this._ch === '"' || this._ch === "'") {
            var preserveQuoteSpace = previous_ch === '"' || previous_ch === "'";
            this.preserveSingleSpace(preserveQuoteSpace || isAfterSpace);
            this.print_string(this._ch + this.eatString(this._ch));
            this.eatWhitespace(true);
          } else if (this._ch === ";") {
            insideNonSemiColonValues = false;
            if (parenLevel === 0) {
              if (insidePropertyValue) {
                this.outdent();
                insidePropertyValue = false;
              }
              insideAtExtend = false;
              insideAtImport = false;
              this.print_string(this._ch);
              this.eatWhitespace(true);
              if (this._input.peek() !== "/") {
                this._output.add_new_line();
              }
            } else {
              this.print_string(this._ch);
              this.eatWhitespace(true);
              this._output.space_before_token = true;
            }
          } else if (this._ch === "(") {
            if (this._input.lookBack("url")) {
              this.print_string(this._ch);
              this.eatWhitespace();
              parenLevel++;
              this.indent();
              this._ch = this._input.next();
              if (this._ch === ")" || this._ch === '"' || this._ch === "'") {
                this._input.back();
              } else if (this._ch) {
                this.print_string(this._ch + this.eatString(")"));
                if (parenLevel) {
                  parenLevel--;
                  this.outdent();
                }
              }
            } else {
              var space_needed = false;
              if (this._input.lookBack("with")) {
                space_needed = true;
              }
              this.preserveSingleSpace(isAfterSpace || space_needed);
              this.print_string(this._ch);
              if (insidePropertyValue && previous_ch === "$" && this._options.selector_separator_newline) {
                this._output.add_new_line();
                insideScssMap = true;
              } else {
                this.eatWhitespace();
                parenLevel++;
                this.indent();
              }
            }
          } else if (this._ch === ")") {
            if (parenLevel) {
              parenLevel--;
              this.outdent();
            }
            if (insideScssMap && this._input.peek() === ";" && this._options.selector_separator_newline) {
              insideScssMap = false;
              this.outdent();
              this._output.add_new_line();
            }
            this.print_string(this._ch);
          } else if (this._ch === ",") {
            this.print_string(this._ch);
            this.eatWhitespace(true);
            if (this._options.selector_separator_newline && (!insidePropertyValue || insideScssMap) && parenLevel === 0 && !insideAtImport && !insideAtExtend) {
              this._output.add_new_line();
            } else {
              this._output.space_before_token = true;
            }
          } else if ((this._ch === ">" || this._ch === "+" || this._ch === "~") && !insidePropertyValue && parenLevel === 0) {
            if (this._options.space_around_combinator) {
              this._output.space_before_token = true;
              this.print_string(this._ch);
              this._output.space_before_token = true;
            } else {
              this.print_string(this._ch);
              this.eatWhitespace();
              if (this._ch && whitespaceChar.test(this._ch)) {
                this._ch = "";
              }
            }
          } else if (this._ch === "]") {
            this.print_string(this._ch);
          } else if (this._ch === "[") {
            this.preserveSingleSpace(isAfterSpace);
            this.print_string(this._ch);
          } else if (this._ch === "=") {
            this.eatWhitespace();
            this.print_string("=");
            if (whitespaceChar.test(this._ch)) {
              this._ch = "";
            }
          } else if (this._ch === "!" && !this._input.lookBack("\\")) {
            this._output.space_before_token = true;
            this.print_string(this._ch);
          } else {
            var preserveAfterSpace = previous_ch === '"' || previous_ch === "'";
            this.preserveSingleSpace(preserveAfterSpace || isAfterSpace);
            this.print_string(this._ch);
            if (!this._output.just_added_newline() && this._input.peek() === "\n" && insideNonSemiColonValues) {
              this._output.add_new_line();
            }
          }
        }
        var sweetCode = this._output.get_code(eol);
        return sweetCode;
      };
      beautifier$1.Beautifier = Beautifier;
      return beautifier$1;
    }
    var hasRequiredCss;
    function requireCss() {
      if (hasRequiredCss)
        return cssExports;
      hasRequiredCss = 1;
      var Beautifier = requireBeautifier$1().Beautifier, Options = requireOptions$1().Options;
      function css_beautify(source_text, options2) {
        var beautifier2 = new Beautifier(source_text, options2);
        return beautifier2.beautify();
      }
      css.exports = css_beautify;
      cssExports.defaultOptions = function() {
        return new Options();
      };
      return cssExports;
    }
    var htmlExports = {};
    var html$1 = {
      get exports() {
        return htmlExports;
      },
      set exports(v) {
        htmlExports = v;
      }
    };
    var beautifier = {};
    var options = {};
    var hasRequiredOptions;
    function requireOptions() {
      if (hasRequiredOptions)
        return options;
      hasRequiredOptions = 1;
      var BaseOptions = requireOptions$3().Options;
      function Options(options2) {
        BaseOptions.call(this, options2, "html");
        if (this.templating.length === 1 && this.templating[0] === "auto") {
          this.templating = ["django", "erb", "handlebars", "php"];
        }
        this.indent_inner_html = this._get_boolean("indent_inner_html");
        this.indent_body_inner_html = this._get_boolean("indent_body_inner_html", true);
        this.indent_head_inner_html = this._get_boolean("indent_head_inner_html", true);
        this.indent_handlebars = this._get_boolean("indent_handlebars", true);
        this.wrap_attributes = this._get_selection("wrap_attributes", ["auto", "force", "force-aligned", "force-expand-multiline", "aligned-multiple", "preserve", "preserve-aligned"]);
        this.wrap_attributes_indent_size = this._get_number("wrap_attributes_indent_size", this.indent_size);
        this.extra_liners = this._get_array("extra_liners", ["head", "body", "/html"]);
        this.inline = this._get_array("inline", [
          "a",
          "abbr",
          "area",
          "audio",
          "b",
          "bdi",
          "bdo",
          "br",
          "button",
          "canvas",
          "cite",
          "code",
          "data",
          "datalist",
          "del",
          "dfn",
          "em",
          "embed",
          "i",
          "iframe",
          "img",
          "input",
          "ins",
          "kbd",
          "keygen",
          "label",
          "map",
          "mark",
          "math",
          "meter",
          "noscript",
          "object",
          "output",
          "progress",
          "q",
          "ruby",
          "s",
          "samp",
          "select",
          "small",
          "span",
          "strong",
          "sub",
          "sup",
          "svg",
          "template",
          "textarea",
          "time",
          "u",
          "var",
          "video",
          "wbr",
          "text",
          "acronym",
          "big",
          "strike",
          "tt"
        ]);
        this.void_elements = this._get_array("void_elements", [
          "area",
          "base",
          "br",
          "col",
          "embed",
          "hr",
          "img",
          "input",
          "keygen",
          "link",
          "menuitem",
          "meta",
          "param",
          "source",
          "track",
          "wbr",
          "!doctype",
          "?xml",
          "basefont",
          "isindex"
        ]);
        this.unformatted = this._get_array("unformatted", []);
        this.content_unformatted = this._get_array("content_unformatted", [
          "pre",
          "textarea"
        ]);
        this.unformatted_content_delimiter = this._get_characters("unformatted_content_delimiter");
        this.indent_scripts = this._get_selection("indent_scripts", ["normal", "keep", "separate"]);
      }
      Options.prototype = new BaseOptions();
      options.Options = Options;
      return options;
    }
    var tokenizer = {};
    var hasRequiredTokenizer;
    function requireTokenizer() {
      if (hasRequiredTokenizer)
        return tokenizer;
      hasRequiredTokenizer = 1;
      var BaseTokenizer = requireTokenizer$2().Tokenizer;
      var BASETOKEN = requireTokenizer$2().TOKEN;
      var Directives = requireDirectives().Directives;
      var TemplatablePattern = requireTemplatablepattern().TemplatablePattern;
      var Pattern = requirePattern().Pattern;
      var TOKEN = {
        TAG_OPEN: "TK_TAG_OPEN",
        TAG_CLOSE: "TK_TAG_CLOSE",
        ATTRIBUTE: "TK_ATTRIBUTE",
        EQUALS: "TK_EQUALS",
        VALUE: "TK_VALUE",
        COMMENT: "TK_COMMENT",
        TEXT: "TK_TEXT",
        UNKNOWN: "TK_UNKNOWN",
        START: BASETOKEN.START,
        RAW: BASETOKEN.RAW,
        EOF: BASETOKEN.EOF
      };
      var directives_core = new Directives(/<\!--/, /-->/);
      var Tokenizer = function(input_string, options2) {
        BaseTokenizer.call(this, input_string, options2);
        this._current_tag_name = "";
        var templatable_reader = new TemplatablePattern(this._input).read_options(this._options);
        var pattern_reader = new Pattern(this._input);
        this.__patterns = {
          word: templatable_reader.until(/[\n\r\t <]/),
          single_quote: templatable_reader.until_after(/'/),
          double_quote: templatable_reader.until_after(/"/),
          attribute: templatable_reader.until(/[\n\r\t =>]|\/>/),
          element_name: templatable_reader.until(/[\n\r\t >\/]/),
          handlebars_comment: pattern_reader.starting_with(/{{!--/).until_after(/--}}/),
          handlebars: pattern_reader.starting_with(/{{/).until_after(/}}/),
          handlebars_open: pattern_reader.until(/[\n\r\t }]/),
          handlebars_raw_close: pattern_reader.until(/}}/),
          comment: pattern_reader.starting_with(/<!--/).until_after(/-->/),
          cdata: pattern_reader.starting_with(/<!\[CDATA\[/).until_after(/]]>/),
          conditional_comment: pattern_reader.starting_with(/<!\[/).until_after(/]>/),
          processing: pattern_reader.starting_with(/<\?/).until_after(/\?>/)
        };
        if (this._options.indent_handlebars) {
          this.__patterns.word = this.__patterns.word.exclude("handlebars");
        }
        this._unformatted_content_delimiter = null;
        if (this._options.unformatted_content_delimiter) {
          var literal_regexp = this._input.get_literal_regexp(this._options.unformatted_content_delimiter);
          this.__patterns.unformatted_content_delimiter = pattern_reader.matching(literal_regexp).until_after(literal_regexp);
        }
      };
      Tokenizer.prototype = new BaseTokenizer();
      Tokenizer.prototype._is_comment = function(current_token) {
        return false;
      };
      Tokenizer.prototype._is_opening = function(current_token) {
        return current_token.type === TOKEN.TAG_OPEN;
      };
      Tokenizer.prototype._is_closing = function(current_token, open_token) {
        return current_token.type === TOKEN.TAG_CLOSE && (open_token && ((current_token.text === ">" || current_token.text === "/>") && open_token.text[0] === "<" || current_token.text === "}}" && open_token.text[0] === "{" && open_token.text[1] === "{"));
      };
      Tokenizer.prototype._reset = function() {
        this._current_tag_name = "";
      };
      Tokenizer.prototype._get_next_token = function(previous_token, open_token) {
        var token2 = null;
        this._readWhitespace();
        var c = this._input.peek();
        if (c === null) {
          return this._create_token(TOKEN.EOF, "");
        }
        token2 = token2 || this._read_open_handlebars(c, open_token);
        token2 = token2 || this._read_attribute(c, previous_token, open_token);
        token2 = token2 || this._read_close(c, open_token);
        token2 = token2 || this._read_raw_content(c, previous_token, open_token);
        token2 = token2 || this._read_content_word(c);
        token2 = token2 || this._read_comment_or_cdata(c);
        token2 = token2 || this._read_processing(c);
        token2 = token2 || this._read_open(c, open_token);
        token2 = token2 || this._create_token(TOKEN.UNKNOWN, this._input.next());
        return token2;
      };
      Tokenizer.prototype._read_comment_or_cdata = function(c) {
        var token2 = null;
        var resulting_string = null;
        var directives2 = null;
        if (c === "<") {
          var peek1 = this._input.peek(1);
          if (peek1 === "!") {
            resulting_string = this.__patterns.comment.read();
            if (resulting_string) {
              directives2 = directives_core.get_directives(resulting_string);
              if (directives2 && directives2.ignore === "start") {
                resulting_string += directives_core.readIgnored(this._input);
              }
            } else {
              resulting_string = this.__patterns.cdata.read();
            }
          }
          if (resulting_string) {
            token2 = this._create_token(TOKEN.COMMENT, resulting_string);
            token2.directives = directives2;
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_processing = function(c) {
        var token2 = null;
        var resulting_string = null;
        var directives2 = null;
        if (c === "<") {
          var peek1 = this._input.peek(1);
          if (peek1 === "!" || peek1 === "?") {
            resulting_string = this.__patterns.conditional_comment.read();
            resulting_string = resulting_string || this.__patterns.processing.read();
          }
          if (resulting_string) {
            token2 = this._create_token(TOKEN.COMMENT, resulting_string);
            token2.directives = directives2;
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_open = function(c, open_token) {
        var resulting_string = null;
        var token2 = null;
        if (!open_token) {
          if (c === "<") {
            resulting_string = this._input.next();
            if (this._input.peek() === "/") {
              resulting_string += this._input.next();
            }
            resulting_string += this.__patterns.element_name.read();
            token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_open_handlebars = function(c, open_token) {
        var resulting_string = null;
        var token2 = null;
        if (!open_token) {
          if (this._options.indent_handlebars && c === "{" && this._input.peek(1) === "{") {
            if (this._input.peek(2) === "!") {
              resulting_string = this.__patterns.handlebars_comment.read();
              resulting_string = resulting_string || this.__patterns.handlebars.read();
              token2 = this._create_token(TOKEN.COMMENT, resulting_string);
            } else {
              resulting_string = this.__patterns.handlebars_open.read();
              token2 = this._create_token(TOKEN.TAG_OPEN, resulting_string);
            }
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_close = function(c, open_token) {
        var resulting_string = null;
        var token2 = null;
        if (open_token) {
          if (open_token.text[0] === "<" && (c === ">" || c === "/" && this._input.peek(1) === ">")) {
            resulting_string = this._input.next();
            if (c === "/") {
              resulting_string += this._input.next();
            }
            token2 = this._create_token(TOKEN.TAG_CLOSE, resulting_string);
          } else if (open_token.text[0] === "{" && c === "}" && this._input.peek(1) === "}") {
            this._input.next();
            this._input.next();
            token2 = this._create_token(TOKEN.TAG_CLOSE, "}}");
          }
        }
        return token2;
      };
      Tokenizer.prototype._read_attribute = function(c, previous_token, open_token) {
        var token2 = null;
        var resulting_string = "";
        if (open_token && open_token.text[0] === "<") {
          if (c === "=") {
            token2 = this._create_token(TOKEN.EQUALS, this._input.next());
          } else if (c === '"' || c === "'") {
            var content = this._input.next();
            if (c === '"') {
              content += this.__patterns.double_quote.read();
            } else {
              content += this.__patterns.single_quote.read();
            }
            token2 = this._create_token(TOKEN.VALUE, content);
          } else {
            resulting_string = this.__patterns.attribute.read();
            if (resulting_string) {
              if (previous_token.type === TOKEN.EQUALS) {
                token2 = this._create_token(TOKEN.VALUE, resulting_string);
              } else {
                token2 = this._create_token(TOKEN.ATTRIBUTE, resulting_string);
              }
            }
          }
        }
        return token2;
      };
      Tokenizer.prototype._is_content_unformatted = function(tag_name) {
        return this._options.void_elements.indexOf(tag_name) === -1 && (this._options.content_unformatted.indexOf(tag_name) !== -1 || this._options.unformatted.indexOf(tag_name) !== -1);
      };
      Tokenizer.prototype._read_raw_content = function(c, previous_token, open_token) {
        var resulting_string = "";
        if (open_token && open_token.text[0] === "{") {
          resulting_string = this.__patterns.handlebars_raw_close.read();
        } else if (previous_token.type === TOKEN.TAG_CLOSE && previous_token.opened.text[0] === "<" && previous_token.text[0] !== "/") {
          var tag_name = previous_token.opened.text.substr(1).toLowerCase();
          if (tag_name === "script" || tag_name === "style") {
            var token2 = this._read_comment_or_cdata(c);
            if (token2) {
              token2.type = TOKEN.TEXT;
              return token2;
            }
            resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
          } else if (this._is_content_unformatted(tag_name)) {
            resulting_string = this._input.readUntil(new RegExp("</" + tag_name + "[\\n\\r\\t ]*?>", "ig"));
          }
        }
        if (resulting_string) {
          return this._create_token(TOKEN.TEXT, resulting_string);
        }
        return null;
      };
      Tokenizer.prototype._read_content_word = function(c) {
        var resulting_string = "";
        if (this._options.unformatted_content_delimiter) {
          if (c === this._options.unformatted_content_delimiter[0]) {
            resulting_string = this.__patterns.unformatted_content_delimiter.read();
          }
        }
        if (!resulting_string) {
          resulting_string = this.__patterns.word.read();
        }
        if (resulting_string) {
          return this._create_token(TOKEN.TEXT, resulting_string);
        }
      };
      tokenizer.Tokenizer = Tokenizer;
      tokenizer.TOKEN = TOKEN;
      return tokenizer;
    }
    var hasRequiredBeautifier;
    function requireBeautifier() {
      if (hasRequiredBeautifier)
        return beautifier;
      hasRequiredBeautifier = 1;
      var Options = requireOptions().Options;
      var Output = requireOutput().Output;
      var Tokenizer = requireTokenizer().Tokenizer;
      var TOKEN = requireTokenizer().TOKEN;
      var lineBreak = /\r\n|[\r\n]/;
      var allLineBreaks = /\r\n|[\r\n]/g;
      var Printer = function(options2, base_indent_string) {
        this.indent_level = 0;
        this.alignment_size = 0;
        this.max_preserve_newlines = options2.max_preserve_newlines;
        this.preserve_newlines = options2.preserve_newlines;
        this._output = new Output(options2, base_indent_string);
      };
      Printer.prototype.current_line_has_match = function(pattern2) {
        return this._output.current_line.has_match(pattern2);
      };
      Printer.prototype.set_space_before_token = function(value, non_breaking) {
        this._output.space_before_token = value;
        this._output.non_breaking_space = non_breaking;
      };
      Printer.prototype.set_wrap_point = function() {
        this._output.set_indent(this.indent_level, this.alignment_size);
        this._output.set_wrap_point();
      };
      Printer.prototype.add_raw_token = function(token2) {
        this._output.add_raw_token(token2);
      };
      Printer.prototype.print_preserved_newlines = function(raw_token) {
        var newlines = 0;
        if (raw_token.type !== TOKEN.TEXT && raw_token.previous.type !== TOKEN.TEXT) {
          newlines = raw_token.newlines ? 1 : 0;
        }
        if (this.preserve_newlines) {
          newlines = raw_token.newlines < this.max_preserve_newlines + 1 ? raw_token.newlines : this.max_preserve_newlines + 1;
        }
        for (var n = 0; n < newlines; n++) {
          this.print_newline(n > 0);
        }
        return newlines !== 0;
      };
      Printer.prototype.traverse_whitespace = function(raw_token) {
        if (raw_token.whitespace_before || raw_token.newlines) {
          if (!this.print_preserved_newlines(raw_token)) {
            this._output.space_before_token = true;
          }
          return true;
        }
        return false;
      };
      Printer.prototype.previous_token_wrapped = function() {
        return this._output.previous_token_wrapped;
      };
      Printer.prototype.print_newline = function(force) {
        this._output.add_new_line(force);
      };
      Printer.prototype.print_token = function(token2) {
        if (token2.text) {
          this._output.set_indent(this.indent_level, this.alignment_size);
          this._output.add_token(token2.text);
        }
      };
      Printer.prototype.indent = function() {
        this.indent_level++;
      };
      Printer.prototype.get_full_indent = function(level) {
        level = this.indent_level + (level || 0);
        if (level < 1) {
          return "";
        }
        return this._output.get_indent_string(level);
      };
      var get_type_attribute = function(start_token) {
        var result = null;
        var raw_token = start_token.next;
        while (raw_token.type !== TOKEN.EOF && start_token.closed !== raw_token) {
          if (raw_token.type === TOKEN.ATTRIBUTE && raw_token.text === "type") {
            if (raw_token.next && raw_token.next.type === TOKEN.EQUALS && raw_token.next.next && raw_token.next.next.type === TOKEN.VALUE) {
              result = raw_token.next.next.text;
            }
            break;
          }
          raw_token = raw_token.next;
        }
        return result;
      };
      var get_custom_beautifier_name = function(tag_check, raw_token) {
        var typeAttribute = null;
        var result = null;
        if (!raw_token.closed) {
          return null;
        }
        if (tag_check === "script") {
          typeAttribute = "text/javascript";
        } else if (tag_check === "style") {
          typeAttribute = "text/css";
        }
        typeAttribute = get_type_attribute(raw_token) || typeAttribute;
        if (typeAttribute.search("text/css") > -1) {
          result = "css";
        } else if (typeAttribute.search(/module|((text|application|dojo)\/(x-)?(javascript|ecmascript|jscript|livescript|(ld\+)?json|method|aspect))/) > -1) {
          result = "javascript";
        } else if (typeAttribute.search(/(text|application|dojo)\/(x-)?(html)/) > -1) {
          result = "html";
        } else if (typeAttribute.search(/test\/null/) > -1) {
          result = "null";
        }
        return result;
      };
      function in_array(what, arr) {
        return arr.indexOf(what) !== -1;
      }
      function TagFrame(parent, parser_token, indent_level) {
        this.parent = parent || null;
        this.tag = parser_token ? parser_token.tag_name : "";
        this.indent_level = indent_level || 0;
        this.parser_token = parser_token || null;
      }
      function TagStack(printer) {
        this._printer = printer;
        this._current_frame = null;
      }
      TagStack.prototype.get_parser_token = function() {
        return this._current_frame ? this._current_frame.parser_token : null;
      };
      TagStack.prototype.record_tag = function(parser_token) {
        var new_frame = new TagFrame(this._current_frame, parser_token, this._printer.indent_level);
        this._current_frame = new_frame;
      };
      TagStack.prototype._try_pop_frame = function(frame) {
        var parser_token = null;
        if (frame) {
          parser_token = frame.parser_token;
          this._printer.indent_level = frame.indent_level;
          this._current_frame = frame.parent;
        }
        return parser_token;
      };
      TagStack.prototype._get_frame = function(tag_list, stop_list) {
        var frame = this._current_frame;
        while (frame) {
          if (tag_list.indexOf(frame.tag) !== -1) {
            break;
          } else if (stop_list && stop_list.indexOf(frame.tag) !== -1) {
            frame = null;
            break;
          }
          frame = frame.parent;
        }
        return frame;
      };
      TagStack.prototype.try_pop = function(tag, stop_list) {
        var frame = this._get_frame([tag], stop_list);
        return this._try_pop_frame(frame);
      };
      TagStack.prototype.indent_to_tag = function(tag_list) {
        var frame = this._get_frame(tag_list);
        if (frame) {
          this._printer.indent_level = frame.indent_level;
        }
      };
      function Beautifier(source_text, options2, js_beautify, css_beautify) {
        this._source_text = source_text || "";
        options2 = options2 || {};
        this._js_beautify = js_beautify;
        this._css_beautify = css_beautify;
        this._tag_stack = null;
        var optionHtml = new Options(options2, "html");
        this._options = optionHtml;
        this._is_wrap_attributes_force = this._options.wrap_attributes.substr(0, "force".length) === "force";
        this._is_wrap_attributes_force_expand_multiline = this._options.wrap_attributes === "force-expand-multiline";
        this._is_wrap_attributes_force_aligned = this._options.wrap_attributes === "force-aligned";
        this._is_wrap_attributes_aligned_multiple = this._options.wrap_attributes === "aligned-multiple";
        this._is_wrap_attributes_preserve = this._options.wrap_attributes.substr(0, "preserve".length) === "preserve";
        this._is_wrap_attributes_preserve_aligned = this._options.wrap_attributes === "preserve-aligned";
      }
      Beautifier.prototype.beautify = function() {
        if (this._options.disabled) {
          return this._source_text;
        }
        var source_text = this._source_text;
        var eol = this._options.eol;
        if (this._options.eol === "auto") {
          eol = "\n";
          if (source_text && lineBreak.test(source_text)) {
            eol = source_text.match(lineBreak)[0];
          }
        }
        source_text = source_text.replace(allLineBreaks, "\n");
        var baseIndentString = source_text.match(/^[\t ]*/)[0];
        var last_token = {
          text: "",
          type: ""
        };
        var last_tag_token = new TagOpenParserToken();
        var printer = new Printer(this._options, baseIndentString);
        var tokens = new Tokenizer(source_text, this._options).tokenize();
        this._tag_stack = new TagStack(printer);
        var parser_token = null;
        var raw_token = tokens.next();
        while (raw_token.type !== TOKEN.EOF) {
          if (raw_token.type === TOKEN.TAG_OPEN || raw_token.type === TOKEN.COMMENT) {
            parser_token = this._handle_tag_open(printer, raw_token, last_tag_token, last_token);
            last_tag_token = parser_token;
          } else if (raw_token.type === TOKEN.ATTRIBUTE || raw_token.type === TOKEN.EQUALS || raw_token.type === TOKEN.VALUE || raw_token.type === TOKEN.TEXT && !last_tag_token.tag_complete) {
            parser_token = this._handle_inside_tag(printer, raw_token, last_tag_token, tokens);
          } else if (raw_token.type === TOKEN.TAG_CLOSE) {
            parser_token = this._handle_tag_close(printer, raw_token, last_tag_token);
          } else if (raw_token.type === TOKEN.TEXT) {
            parser_token = this._handle_text(printer, raw_token, last_tag_token);
          } else {
            printer.add_raw_token(raw_token);
          }
          last_token = parser_token;
          raw_token = tokens.next();
        }
        var sweet_code = printer._output.get_code(eol);
        return sweet_code;
      };
      Beautifier.prototype._handle_tag_close = function(printer, raw_token, last_tag_token) {
        var parser_token = {
          text: raw_token.text,
          type: raw_token.type
        };
        printer.alignment_size = 0;
        last_tag_token.tag_complete = true;
        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
        if (last_tag_token.is_unformatted) {
          printer.add_raw_token(raw_token);
        } else {
          if (last_tag_token.tag_start_char === "<") {
            printer.set_space_before_token(raw_token.text[0] === "/", true);
            if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.has_wrapped_attrs) {
              printer.print_newline(false);
            }
          }
          printer.print_token(raw_token);
        }
        if (last_tag_token.indent_content && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
          printer.indent();
          last_tag_token.indent_content = false;
        }
        if (!last_tag_token.is_inline_element && !(last_tag_token.is_unformatted || last_tag_token.is_content_unformatted)) {
          printer.set_wrap_point();
        }
        return parser_token;
      };
      Beautifier.prototype._handle_inside_tag = function(printer, raw_token, last_tag_token, tokens) {
        var wrapped = last_tag_token.has_wrapped_attrs;
        var parser_token = {
          text: raw_token.text,
          type: raw_token.type
        };
        printer.set_space_before_token(raw_token.newlines || raw_token.whitespace_before !== "", true);
        if (last_tag_token.is_unformatted) {
          printer.add_raw_token(raw_token);
        } else if (last_tag_token.tag_start_char === "{" && raw_token.type === TOKEN.TEXT) {
          if (printer.print_preserved_newlines(raw_token)) {
            raw_token.newlines = 0;
            printer.add_raw_token(raw_token);
          } else {
            printer.print_token(raw_token);
          }
        } else {
          if (raw_token.type === TOKEN.ATTRIBUTE) {
            printer.set_space_before_token(true);
            last_tag_token.attr_count += 1;
          } else if (raw_token.type === TOKEN.EQUALS) {
            printer.set_space_before_token(false);
          } else if (raw_token.type === TOKEN.VALUE && raw_token.previous.type === TOKEN.EQUALS) {
            printer.set_space_before_token(false);
          }
          if (raw_token.type === TOKEN.ATTRIBUTE && last_tag_token.tag_start_char === "<") {
            if (this._is_wrap_attributes_preserve || this._is_wrap_attributes_preserve_aligned) {
              printer.traverse_whitespace(raw_token);
              wrapped = wrapped || raw_token.newlines !== 0;
            }
            if (this._is_wrap_attributes_force) {
              var force_attr_wrap = last_tag_token.attr_count > 1;
              if (this._is_wrap_attributes_force_expand_multiline && last_tag_token.attr_count === 1) {
                var is_only_attribute = true;
                var peek_index = 0;
                var peek_token;
                do {
                  peek_token = tokens.peek(peek_index);
                  if (peek_token.type === TOKEN.ATTRIBUTE) {
                    is_only_attribute = false;
                    break;
                  }
                  peek_index += 1;
                } while (peek_index < 4 && peek_token.type !== TOKEN.EOF && peek_token.type !== TOKEN.TAG_CLOSE);
                force_attr_wrap = !is_only_attribute;
              }
              if (force_attr_wrap) {
                printer.print_newline(false);
                wrapped = true;
              }
            }
          }
          printer.print_token(raw_token);
          wrapped = wrapped || printer.previous_token_wrapped();
          last_tag_token.has_wrapped_attrs = wrapped;
        }
        return parser_token;
      };
      Beautifier.prototype._handle_text = function(printer, raw_token, last_tag_token) {
        var parser_token = {
          text: raw_token.text,
          type: "TK_CONTENT"
        };
        if (last_tag_token.custom_beautifier_name) {
          this._print_custom_beatifier_text(printer, raw_token, last_tag_token);
        } else if (last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) {
          printer.add_raw_token(raw_token);
        } else {
          printer.traverse_whitespace(raw_token);
          printer.print_token(raw_token);
        }
        return parser_token;
      };
      Beautifier.prototype._print_custom_beatifier_text = function(printer, raw_token, last_tag_token) {
        var local = this;
        if (raw_token.text !== "") {
          var text2 = raw_token.text, _beautifier, script_indent_level = 1, pre2 = "", post = "";
          if (last_tag_token.custom_beautifier_name === "javascript" && typeof this._js_beautify === "function") {
            _beautifier = this._js_beautify;
          } else if (last_tag_token.custom_beautifier_name === "css" && typeof this._css_beautify === "function") {
            _beautifier = this._css_beautify;
          } else if (last_tag_token.custom_beautifier_name === "html") {
            _beautifier = function(html_source, options2) {
              var beautifier2 = new Beautifier(html_source, options2, local._js_beautify, local._css_beautify);
              return beautifier2.beautify();
            };
          }
          if (this._options.indent_scripts === "keep") {
            script_indent_level = 0;
          } else if (this._options.indent_scripts === "separate") {
            script_indent_level = -printer.indent_level;
          }
          var indentation = printer.get_full_indent(script_indent_level);
          text2 = text2.replace(/\n[ \t]*$/, "");
          if (last_tag_token.custom_beautifier_name !== "html" && text2[0] === "<" && text2.match(/^(<!--|<!\[CDATA\[)/)) {
            var matched = /^(<!--[^\n]*|<!\[CDATA\[)(\n?)([ \t\n]*)([\s\S]*)(-->|]]>)$/.exec(text2);
            if (!matched) {
              printer.add_raw_token(raw_token);
              return;
            }
            pre2 = indentation + matched[1] + "\n";
            text2 = matched[4];
            if (matched[5]) {
              post = indentation + matched[5];
            }
            text2 = text2.replace(/\n[ \t]*$/, "");
            if (matched[2] || matched[3].indexOf("\n") !== -1) {
              matched = matched[3].match(/[ \t]+$/);
              if (matched) {
                raw_token.whitespace_before = matched[0];
              }
            }
          }
          if (text2) {
            if (_beautifier) {
              var Child_options = function() {
                this.eol = "\n";
              };
              Child_options.prototype = this._options.raw_options;
              var child_options = new Child_options();
              text2 = _beautifier(indentation + text2, child_options);
            } else {
              var white = raw_token.whitespace_before;
              if (white) {
                text2 = text2.replace(new RegExp("\n(" + white + ")?", "g"), "\n");
              }
              text2 = indentation + text2.replace(/\n/g, "\n" + indentation);
            }
          }
          if (pre2) {
            if (!text2) {
              text2 = pre2 + post;
            } else {
              text2 = pre2 + text2 + "\n" + post;
            }
          }
          printer.print_newline(false);
          if (text2) {
            raw_token.text = text2;
            raw_token.whitespace_before = "";
            raw_token.newlines = 0;
            printer.add_raw_token(raw_token);
            printer.print_newline(true);
          }
        }
      };
      Beautifier.prototype._handle_tag_open = function(printer, raw_token, last_tag_token, last_token) {
        var parser_token = this._get_tag_open_token(raw_token);
        if ((last_tag_token.is_unformatted || last_tag_token.is_content_unformatted) && !last_tag_token.is_empty_element && raw_token.type === TOKEN.TAG_OPEN && raw_token.text.indexOf("</") === 0) {
          printer.add_raw_token(raw_token);
          parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
        } else {
          printer.traverse_whitespace(raw_token);
          this._set_tag_position(printer, raw_token, parser_token, last_tag_token, last_token);
          if (!parser_token.is_inline_element) {
            printer.set_wrap_point();
          }
          printer.print_token(raw_token);
        }
        if (this._is_wrap_attributes_force_aligned || this._is_wrap_attributes_aligned_multiple || this._is_wrap_attributes_preserve_aligned) {
          parser_token.alignment_size = raw_token.text.length + 1;
        }
        if (!parser_token.tag_complete && !parser_token.is_unformatted) {
          printer.alignment_size = parser_token.alignment_size;
        }
        return parser_token;
      };
      var TagOpenParserToken = function(parent, raw_token) {
        this.parent = parent || null;
        this.text = "";
        this.type = "TK_TAG_OPEN";
        this.tag_name = "";
        this.is_inline_element = false;
        this.is_unformatted = false;
        this.is_content_unformatted = false;
        this.is_empty_element = false;
        this.is_start_tag = false;
        this.is_end_tag = false;
        this.indent_content = false;
        this.multiline_content = false;
        this.custom_beautifier_name = null;
        this.start_tag_token = null;
        this.attr_count = 0;
        this.has_wrapped_attrs = false;
        this.alignment_size = 0;
        this.tag_complete = false;
        this.tag_start_char = "";
        this.tag_check = "";
        if (!raw_token) {
          this.tag_complete = true;
        } else {
          var tag_check_match;
          this.tag_start_char = raw_token.text[0];
          this.text = raw_token.text;
          if (this.tag_start_char === "<") {
            tag_check_match = raw_token.text.match(/^<([^\s>]*)/);
            this.tag_check = tag_check_match ? tag_check_match[1] : "";
          } else {
            tag_check_match = raw_token.text.match(/^{{~?(?:[\^]|#\*?)?([^\s}]+)/);
            this.tag_check = tag_check_match ? tag_check_match[1] : "";
            if ((raw_token.text.startsWith("{{#>") || raw_token.text.startsWith("{{~#>")) && this.tag_check[0] === ">") {
              if (this.tag_check === ">" && raw_token.next !== null) {
                this.tag_check = raw_token.next.text.split(" ")[0];
              } else {
                this.tag_check = raw_token.text.split(">")[1];
              }
            }
          }
          this.tag_check = this.tag_check.toLowerCase();
          if (raw_token.type === TOKEN.COMMENT) {
            this.tag_complete = true;
          }
          this.is_start_tag = this.tag_check.charAt(0) !== "/";
          this.tag_name = !this.is_start_tag ? this.tag_check.substr(1) : this.tag_check;
          this.is_end_tag = !this.is_start_tag || raw_token.closed && raw_token.closed.text === "/>";
          var handlebar_starts = 2;
          if (this.tag_start_char === "{" && this.text.length >= 3) {
            if (this.text.charAt(2) === "~") {
              handlebar_starts = 3;
            }
          }
          this.is_end_tag = this.is_end_tag || this.tag_start_char === "{" && (this.text.length < 3 || /[^#\^]/.test(this.text.charAt(handlebar_starts)));
        }
      };
      Beautifier.prototype._get_tag_open_token = function(raw_token) {
        var parser_token = new TagOpenParserToken(this._tag_stack.get_parser_token(), raw_token);
        parser_token.alignment_size = this._options.wrap_attributes_indent_size;
        parser_token.is_end_tag = parser_token.is_end_tag || in_array(parser_token.tag_check, this._options.void_elements);
        parser_token.is_empty_element = parser_token.tag_complete || parser_token.is_start_tag && parser_token.is_end_tag;
        parser_token.is_unformatted = !parser_token.tag_complete && in_array(parser_token.tag_check, this._options.unformatted);
        parser_token.is_content_unformatted = !parser_token.is_empty_element && in_array(parser_token.tag_check, this._options.content_unformatted);
        parser_token.is_inline_element = in_array(parser_token.tag_name, this._options.inline) || parser_token.tag_name.includes("-") || parser_token.tag_start_char === "{";
        return parser_token;
      };
      Beautifier.prototype._set_tag_position = function(printer, raw_token, parser_token, last_tag_token, last_token) {
        if (!parser_token.is_empty_element) {
          if (parser_token.is_end_tag) {
            parser_token.start_tag_token = this._tag_stack.try_pop(parser_token.tag_name);
          } else {
            if (this._do_optional_end_element(parser_token)) {
              if (!parser_token.is_inline_element) {
                printer.print_newline(false);
              }
            }
            this._tag_stack.record_tag(parser_token);
            if ((parser_token.tag_name === "script" || parser_token.tag_name === "style") && !(parser_token.is_unformatted || parser_token.is_content_unformatted)) {
              parser_token.custom_beautifier_name = get_custom_beautifier_name(parser_token.tag_check, raw_token);
            }
          }
        }
        if (in_array(parser_token.tag_check, this._options.extra_liners)) {
          printer.print_newline(false);
          if (!printer._output.just_added_blankline()) {
            printer.print_newline(true);
          }
        }
        if (parser_token.is_empty_element) {
          if (parser_token.tag_start_char === "{" && parser_token.tag_check === "else") {
            this._tag_stack.indent_to_tag(["if", "unless", "each"]);
            parser_token.indent_content = true;
            var foundIfOnCurrentLine = printer.current_line_has_match(/{{#if/);
            if (!foundIfOnCurrentLine) {
              printer.print_newline(false);
            }
          }
          if (parser_token.tag_name === "!--" && last_token.type === TOKEN.TAG_CLOSE && last_tag_token.is_end_tag && parser_token.text.indexOf("\n") === -1)
            ;
          else {
            if (!(parser_token.is_inline_element || parser_token.is_unformatted)) {
              printer.print_newline(false);
            }
            this._calcluate_parent_multiline(printer, parser_token);
          }
        } else if (parser_token.is_end_tag) {
          var do_end_expand = false;
          do_end_expand = parser_token.start_tag_token && parser_token.start_tag_token.multiline_content;
          do_end_expand = do_end_expand || !parser_token.is_inline_element && !(last_tag_token.is_inline_element || last_tag_token.is_unformatted) && !(last_token.type === TOKEN.TAG_CLOSE && parser_token.start_tag_token === last_tag_token) && last_token.type !== "TK_CONTENT";
          if (parser_token.is_content_unformatted || parser_token.is_unformatted) {
            do_end_expand = false;
          }
          if (do_end_expand) {
            printer.print_newline(false);
          }
        } else {
          parser_token.indent_content = !parser_token.custom_beautifier_name;
          if (parser_token.tag_start_char === "<") {
            if (parser_token.tag_name === "html") {
              parser_token.indent_content = this._options.indent_inner_html;
            } else if (parser_token.tag_name === "head") {
              parser_token.indent_content = this._options.indent_head_inner_html;
            } else if (parser_token.tag_name === "body") {
              parser_token.indent_content = this._options.indent_body_inner_html;
            }
          }
          if (!(parser_token.is_inline_element || parser_token.is_unformatted) && (last_token.type !== "TK_CONTENT" || parser_token.is_content_unformatted)) {
            printer.print_newline(false);
          }
          this._calcluate_parent_multiline(printer, parser_token);
        }
      };
      Beautifier.prototype._calcluate_parent_multiline = function(printer, parser_token) {
        if (parser_token.parent && printer._output.just_added_newline() && !((parser_token.is_inline_element || parser_token.is_unformatted) && parser_token.parent.is_inline_element)) {
          parser_token.parent.multiline_content = true;
        }
      };
      var p_closers = ["address", "article", "aside", "blockquote", "details", "div", "dl", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hr", "main", "nav", "ol", "p", "pre", "section", "table", "ul"];
      var p_parent_excludes = ["a", "audio", "del", "ins", "map", "noscript", "video"];
      Beautifier.prototype._do_optional_end_element = function(parser_token) {
        var result = null;
        if (parser_token.is_empty_element || !parser_token.is_start_tag || !parser_token.parent) {
          return;
        }
        if (parser_token.tag_name === "body") {
          result = result || this._tag_stack.try_pop("head");
        } else if (parser_token.tag_name === "li") {
          result = result || this._tag_stack.try_pop("li", ["ol", "ul"]);
        } else if (parser_token.tag_name === "dd" || parser_token.tag_name === "dt") {
          result = result || this._tag_stack.try_pop("dt", ["dl"]);
          result = result || this._tag_stack.try_pop("dd", ["dl"]);
        } else if (parser_token.parent.tag_name === "p" && p_closers.indexOf(parser_token.tag_name) !== -1) {
          var p_parent = parser_token.parent.parent;
          if (!p_parent || p_parent_excludes.indexOf(p_parent.tag_name) === -1) {
            result = result || this._tag_stack.try_pop("p");
          }
        } else if (parser_token.tag_name === "rp" || parser_token.tag_name === "rt") {
          result = result || this._tag_stack.try_pop("rt", ["ruby", "rtc"]);
          result = result || this._tag_stack.try_pop("rp", ["ruby", "rtc"]);
        } else if (parser_token.tag_name === "optgroup") {
          result = result || this._tag_stack.try_pop("optgroup", ["select"]);
        } else if (parser_token.tag_name === "option") {
          result = result || this._tag_stack.try_pop("option", ["select", "datalist", "optgroup"]);
        } else if (parser_token.tag_name === "colgroup") {
          result = result || this._tag_stack.try_pop("caption", ["table"]);
        } else if (parser_token.tag_name === "thead") {
          result = result || this._tag_stack.try_pop("caption", ["table"]);
          result = result || this._tag_stack.try_pop("colgroup", ["table"]);
        } else if (parser_token.tag_name === "tbody" || parser_token.tag_name === "tfoot") {
          result = result || this._tag_stack.try_pop("caption", ["table"]);
          result = result || this._tag_stack.try_pop("colgroup", ["table"]);
          result = result || this._tag_stack.try_pop("thead", ["table"]);
          result = result || this._tag_stack.try_pop("tbody", ["table"]);
        } else if (parser_token.tag_name === "tr") {
          result = result || this._tag_stack.try_pop("caption", ["table"]);
          result = result || this._tag_stack.try_pop("colgroup", ["table"]);
          result = result || this._tag_stack.try_pop("tr", ["table", "thead", "tbody", "tfoot"]);
        } else if (parser_token.tag_name === "th" || parser_token.tag_name === "td") {
          result = result || this._tag_stack.try_pop("td", ["table", "thead", "tbody", "tfoot", "tr"]);
          result = result || this._tag_stack.try_pop("th", ["table", "thead", "tbody", "tfoot", "tr"]);
        }
        parser_token.parent = this._tag_stack.get_parser_token();
        return result;
      };
      beautifier.Beautifier = Beautifier;
      return beautifier;
    }
    var hasRequiredHtml;
    function requireHtml() {
      if (hasRequiredHtml)
        return htmlExports;
      hasRequiredHtml = 1;
      var Beautifier = requireBeautifier().Beautifier, Options = requireOptions().Options;
      function style_html(html_source, options2, js_beautify, css_beautify) {
        var beautifier2 = new Beautifier(html_source, options2, js_beautify, css_beautify);
        return beautifier2.beautify();
      }
      html$1.exports = style_html;
      htmlExports.defaultOptions = function() {
        return new Options();
      };
      return htmlExports;
    }
    var hasRequiredSrc;
    function requireSrc() {
      if (hasRequiredSrc)
        return src;
      hasRequiredSrc = 1;
      var js_beautify = requireJavascript();
      var css_beautify = requireCss();
      var html_beautify = requireHtml();
      function style_html(html_source, options2, js2, css2) {
        js2 = js2 || js_beautify;
        css2 = css2 || css_beautify;
        return html_beautify(html_source, options2, js2, css2);
      }
      style_html.defaultOptions = html_beautify.defaultOptions;
      src.js = js_beautify;
      src.css = css_beautify;
      src.html = style_html;
      return src;
    }
    (function(module3) {
      function get_beautify(js_beautify, css_beautify, html_beautify) {
        var beautify2 = function(src2, config2) {
          return js_beautify.js_beautify(src2, config2);
        };
        beautify2.js = js_beautify.js_beautify;
        beautify2.css = css_beautify.css_beautify;
        beautify2.html = html_beautify.html_beautify;
        beautify2.js_beautify = js_beautify.js_beautify;
        beautify2.css_beautify = css_beautify.css_beautify;
        beautify2.html_beautify = html_beautify.html_beautify;
        return beautify2;
      }
      {
        (function(mod) {
          var beautifier2 = requireSrc();
          beautifier2.js_beautify = beautifier2.js;
          beautifier2.css_beautify = beautifier2.css;
          beautifier2.html_beautify = beautifier2.html;
          mod.exports = get_beautify(beautifier2, beautifier2, beautifier2);
        })(module3);
      }
    })(js$1);
    var js = jsExports;
    var Beautify = /* @__PURE__ */ _mergeNamespaces({
      __proto__: null,
      default: js
    }, [jsExports]);
    var capitalize = (s = "") => s.charAt(0).toUpperCase() + s.slice(1);
    var beautify = (str, type = "html", options2) => Beautify[type](str, { ...{ indent_size: 2 }, ...options2 });
    var String$1 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      capitalize,
      beautify
    });
    var remove = {};
    remove.class = (classes, target2) => asArray(classes).forEach((classname) => {
      const els2 = target2.querySelectorAll(classname);
      els2.forEach((el2) => {
        el2.classList.remove(classname.replace(".", ""));
      });
    });
    remove.el = (els2, target2) => asArray(els2).forEach((selector) => {
      const els3 = target2.querySelectorAll(selector);
      els3.forEach((el2) => {
        var _a;
        (_a = el2.parentElement) == null ? void 0 : _a.removeChild(el2);
      });
    });
    remove.attr = (attrs, target2) => asArray(attrs).forEach((attr) => {
      const els2 = target2.querySelectorAll(`[${attr}]`);
      els2.forEach((el2) => {
        el2.removeAttribute(attr);
      });
    });
    remove.emptyAttr = (attrs, target2) => asArray(attrs).forEach((attr) => {
      const els2 = target2.querySelectorAll(`[${attr}=""]`);
      els2.forEach((el2) => {
        el2.removeAttribute(attr);
      });
    });
    remove.emptyTags = (tags, target2) => asArray(tags).forEach((tag) => {
      const els2 = target2.querySelectorAll(`${tag}`);
      els2.forEach((el2) => {
        var _a;
        const inside = (el2.innerHTML || "").trim();
        if (inside === "&nbsp;" || !inside) {
          (_a = el2.parentNode) == null ? void 0 : _a.removeChild(el2);
        }
      });
    });
    var parseUl = (win, rootUl) => {
      var _a;
      const { $: $2 } = win;
      if (!rootUl)
        return { items: [] };
      const array = [];
      if ($2(rootUl).find("ul").length) {
        for (const el2 of $2(rootUl).find("> li")) {
          const label = ((_a = $2(el2).find("label")[0]) == null ? void 0 : _a.innerHTML) || $2(el2).clone().children().remove().end().text().trim();
          const isOpen = !$2(el2).find('[type="checkbox"][checked=""]')[0];
          const items = [];
          $2(el2).find("ul li").map(function() {
            const item = $2(this).html().split("||").map((slot) => (slot || "").trim());
            items.push(item);
          });
          const section = { label, isOpen, items };
          array.push(section);
        }
        return { nested: true, items: array };
      } else {
        for (const el2 of $2(rootUl).find("> li")) {
          const item = $2(el2).html().split("||").map((slot) => (slot || "").trim());
          array.push(item);
        }
        return { nested: false, items: array };
      }
    };
    var Dom = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      remove,
      parseUl
    });
    var old$1 = {};
    var pathModule = require$$4;
    var isWindows$2 = process.platform === "win32";
    var fs$2 = require$$0$1;
    var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
    function rethrow() {
      var callback;
      if (DEBUG) {
        var backtrace = new Error();
        callback = debugCallback;
      } else
        callback = missingCallback;
      return callback;
      function debugCallback(err) {
        if (err) {
          backtrace.message = err.message;
          err = backtrace;
          missingCallback(err);
        }
      }
      function missingCallback(err) {
        if (err) {
          if (process.throwDeprecation)
            throw err;
          else if (!process.noDeprecation) {
            var msg = "fs: missing callback " + (err.stack || err.message);
            if (process.traceDeprecation)
              console.trace(msg);
            else
              console.error(msg);
          }
        }
      }
    }
    function maybeCallback(cb) {
      return typeof cb === "function" ? cb : rethrow();
    }
    pathModule.normalize;
    if (isWindows$2) {
      nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
    } else {
      nextPartRe = /(.*?)(?:[\/]+|$)/g;
    }
    var nextPartRe;
    if (isWindows$2) {
      splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
    } else {
      splitRootRe = /^[\/]*/;
    }
    var splitRootRe;
    old$1.realpathSync = function realpathSync2(p, cache) {
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return cache[p];
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows$2 && !knownHard[base]) {
          fs$2.lstatSync(base);
          knownHard[base] = true;
        }
      }
      while (pos < p.length) {
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          continue;
        }
        var resolvedLink;
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          resolvedLink = cache[base];
        } else {
          var stat = fs$2.lstatSync(base);
          if (!stat.isSymbolicLink()) {
            knownHard[base] = true;
            if (cache)
              cache[base] = base;
            continue;
          }
          var linkTarget = null;
          if (!isWindows$2) {
            var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
            if (seenLinks.hasOwnProperty(id)) {
              linkTarget = seenLinks[id];
            }
          }
          if (linkTarget === null) {
            fs$2.statSync(base);
            linkTarget = fs$2.readlinkSync(base);
          }
          resolvedLink = pathModule.resolve(previous, linkTarget);
          if (cache)
            cache[base] = resolvedLink;
          if (!isWindows$2)
            seenLinks[id] = linkTarget;
        }
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
      if (cache)
        cache[original] = p;
      return p;
    };
    old$1.realpath = function realpath2(p, cache, cb) {
      if (typeof cb !== "function") {
        cb = maybeCallback(cache);
        cache = null;
      }
      p = pathModule.resolve(p);
      if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
        return process.nextTick(cb.bind(null, null, cache[p]));
      }
      var original = p, seenLinks = {}, knownHard = {};
      var pos;
      var current;
      var base;
      var previous;
      start();
      function start() {
        var m = splitRootRe.exec(p);
        pos = m[0].length;
        current = m[0];
        base = m[0];
        previous = "";
        if (isWindows$2 && !knownHard[base]) {
          fs$2.lstat(base, function(err) {
            if (err)
              return cb(err);
            knownHard[base] = true;
            LOOP();
          });
        } else {
          process.nextTick(LOOP);
        }
      }
      function LOOP() {
        if (pos >= p.length) {
          if (cache)
            cache[original] = p;
          return cb(null, p);
        }
        nextPartRe.lastIndex = pos;
        var result = nextPartRe.exec(p);
        previous = current;
        current += result[0];
        base = previous + result[1];
        pos = nextPartRe.lastIndex;
        if (knownHard[base] || cache && cache[base] === base) {
          return process.nextTick(LOOP);
        }
        if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
          return gotResolvedLink(cache[base]);
        }
        return fs$2.lstat(base, gotStat);
      }
      function gotStat(err, stat) {
        if (err)
          return cb(err);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          return process.nextTick(LOOP);
        }
        if (!isWindows$2) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            return gotTarget(null, seenLinks[id], base);
          }
        }
        fs$2.stat(base, function(err2) {
          if (err2)
            return cb(err2);
          fs$2.readlink(base, function(err3, target2) {
            if (!isWindows$2)
              seenLinks[id] = target2;
            gotTarget(err3, target2);
          });
        });
      }
      function gotTarget(err, target2, base2) {
        if (err)
          return cb(err);
        var resolvedLink = pathModule.resolve(previous, target2);
        if (cache)
          cache[base2] = resolvedLink;
        gotResolvedLink(resolvedLink);
      }
      function gotResolvedLink(resolvedLink) {
        p = pathModule.resolve(resolvedLink, p.slice(pos));
        start();
      }
    };
    var fs_realpath = realpath;
    realpath.realpath = realpath;
    realpath.sync = realpathSync;
    realpath.realpathSync = realpathSync;
    realpath.monkeypatch = monkeypatch;
    realpath.unmonkeypatch = unmonkeypatch;
    var fs$1 = require$$0$1;
    var origRealpath = fs$1.realpath;
    var origRealpathSync = fs$1.realpathSync;
    var version = process.version;
    var ok = /^v[0-5]\./.test(version);
    var old = old$1;
    function newError(er) {
      return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
    }
    function realpath(p, cache, cb) {
      if (ok) {
        return origRealpath(p, cache, cb);
      }
      if (typeof cache === "function") {
        cb = cache;
        cache = null;
      }
      origRealpath(p, cache, function(er, result) {
        if (newError(er)) {
          old.realpath(p, cache, cb);
        } else {
          cb(er, result);
        }
      });
    }
    function realpathSync(p, cache) {
      if (ok) {
        return origRealpathSync(p, cache);
      }
      try {
        return origRealpathSync(p, cache);
      } catch (er) {
        if (newError(er)) {
          return old.realpathSync(p, cache);
        } else {
          throw er;
        }
      }
    }
    function monkeypatch() {
      fs$1.realpath = realpath;
      fs$1.realpathSync = realpathSync;
    }
    function unmonkeypatch() {
      fs$1.realpath = origRealpath;
      fs$1.realpathSync = origRealpathSync;
    }
    var isWindows$1 = typeof process === "object" && process && process.platform === "win32";
    var path$2 = isWindows$1 ? { sep: "\\" } : { sep: "/" };
    var balancedMatch = balanced$1;
    function balanced$1(a, b, str) {
      if (a instanceof RegExp)
        a = maybeMatch(a, str);
      if (b instanceof RegExp)
        b = maybeMatch(b, str);
      var r = range$1(a, b, str);
      return r && {
        start: r[0],
        end: r[1],
        pre: str.slice(0, r[0]),
        body: str.slice(r[0] + a.length, r[1]),
        post: str.slice(r[1] + b.length)
      };
    }
    function maybeMatch(reg2, str) {
      var m = str.match(reg2);
      return m ? m[0] : null;
    }
    balanced$1.range = range$1;
    function range$1(a, b, str) {
      var begs, beg, left, right, result;
      var ai = str.indexOf(a);
      var bi = str.indexOf(b, ai + 1);
      var i2 = ai;
      if (ai >= 0 && bi > 0) {
        if (a === b) {
          return [ai, bi];
        }
        begs = [];
        left = str.length;
        while (i2 >= 0 && !result) {
          if (i2 == ai) {
            begs.push(i2);
            ai = str.indexOf(a, i2 + 1);
          } else if (begs.length == 1) {
            result = [begs.pop(), bi];
          } else {
            beg = begs.pop();
            if (beg < left) {
              left = beg;
              right = bi;
            }
            bi = str.indexOf(b, i2 + 1);
          }
          i2 = ai < bi && ai >= 0 ? ai : bi;
        }
        if (begs.length) {
          result = [left, right];
        }
      }
      return result;
    }
    var balanced = balancedMatch;
    var braceExpansion = expandTop;
    var escSlash = "\0SLASH" + Math.random() + "\0";
    var escOpen = "\0OPEN" + Math.random() + "\0";
    var escClose = "\0CLOSE" + Math.random() + "\0";
    var escComma = "\0COMMA" + Math.random() + "\0";
    var escPeriod = "\0PERIOD" + Math.random() + "\0";
    function numeric(str) {
      return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
    }
    function escapeBraces(str) {
      return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
    }
    function unescapeBraces(str) {
      return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
    }
    function parseCommaParts(str) {
      if (!str)
        return [""];
      var parts = [];
      var m = balanced("{", "}", str);
      if (!m)
        return str.split(",");
      var pre2 = m.pre;
      var body2 = m.body;
      var post = m.post;
      var p = pre2.split(",");
      p[p.length - 1] += "{" + body2 + "}";
      var postParts = parseCommaParts(post);
      if (post.length) {
        p[p.length - 1] += postParts.shift();
        p.push.apply(p, postParts);
      }
      parts.push.apply(parts, p);
      return parts;
    }
    function expandTop(str) {
      if (!str)
        return [];
      if (str.substr(0, 2) === "{}") {
        str = "\\{\\}" + str.substr(2);
      }
      return expand$1(escapeBraces(str), true).map(unescapeBraces);
    }
    function embrace(str) {
      return "{" + str + "}";
    }
    function isPadded(el2) {
      return /^-?0\d/.test(el2);
    }
    function lte(i2, y) {
      return i2 <= y;
    }
    function gte(i2, y) {
      return i2 >= y;
    }
    function expand$1(str, isTop) {
      var expansions = [];
      var m = balanced("{", "}", str);
      if (!m)
        return [str];
      var pre2 = m.pre;
      var post = m.post.length ? expand$1(m.post, false) : [""];
      if (/\$$/.test(m.pre)) {
        for (var k = 0; k < post.length; k++) {
          var expansion = pre2 + "{" + m.body + "}" + post[k];
          expansions.push(expansion);
        }
      } else {
        var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
        var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
        var isSequence = isNumericSequence || isAlphaSequence;
        var isOptions = m.body.indexOf(",") >= 0;
        if (!isSequence && !isOptions) {
          if (m.post.match(/,.*\}/)) {
            str = m.pre + "{" + m.body + escClose + m.post;
            return expand$1(str);
          }
          return [str];
        }
        var n;
        if (isSequence) {
          n = m.body.split(/\.\./);
        } else {
          n = parseCommaParts(m.body);
          if (n.length === 1) {
            n = expand$1(n[0], false).map(embrace);
            if (n.length === 1) {
              return post.map(function(p) {
                return m.pre + n[0] + p;
              });
            }
          }
        }
        var N;
        if (isSequence) {
          var x = numeric(n[0]);
          var y = numeric(n[1]);
          var width = Math.max(n[0].length, n[1].length);
          var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
          var test = lte;
          var reverse = y < x;
          if (reverse) {
            incr *= -1;
            test = gte;
          }
          var pad = n.some(isPadded);
          N = [];
          for (var i2 = x; test(i2, y); i2 += incr) {
            var c;
            if (isAlphaSequence) {
              c = String.fromCharCode(i2);
              if (c === "\\")
                c = "";
            } else {
              c = String(i2);
              if (pad) {
                var need = width - c.length;
                if (need > 0) {
                  var z = new Array(need + 1).join("0");
                  if (i2 < 0)
                    c = "-" + z + c.slice(1);
                  else
                    c = z + c;
                }
              }
            }
            N.push(c);
          }
        } else {
          N = [];
          for (var j = 0; j < n.length; j++) {
            N.push.apply(N, expand$1(n[j], false));
          }
        }
        for (var j = 0; j < N.length; j++) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre2 + N[j] + post[k];
            if (!isTop || isSequence || expansion)
              expansions.push(expansion);
          }
        }
      }
      return expansions;
    }
    var minimatch$1 = minimatch_1 = (p, pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (!options2.nocomment && pattern2.charAt(0) === "#") {
        return false;
      }
      return new Minimatch$1(pattern2, options2).match(p);
    };
    var minimatch_1 = minimatch$1;
    var path$1 = path$2;
    minimatch$1.sep = path$1.sep;
    var GLOBSTAR = Symbol("globstar **");
    minimatch$1.GLOBSTAR = GLOBSTAR;
    var expand = braceExpansion;
    var plTypes = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" }
    };
    var qmark = "[^/]";
    var star$1 = qmark + "*?";
    var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
    var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
    var charSet = (s) => s.split("").reduce((set, c) => {
      set[c] = true;
      return set;
    }, {});
    var reSpecials = charSet("().*{}+?[]^$\\!");
    var addPatternStartSet = charSet("[.(");
    var slashSplit = /\/+/;
    minimatch$1.filter = (pattern2, options2 = {}) => (p, i2, list2) => minimatch$1(p, pattern2, options2);
    var ext = (a, b = {}) => {
      const t = {};
      Object.keys(a).forEach((k) => t[k] = a[k]);
      Object.keys(b).forEach((k) => t[k] = b[k]);
      return t;
    };
    minimatch$1.defaults = (def) => {
      if (!def || typeof def !== "object" || !Object.keys(def).length) {
        return minimatch$1;
      }
      const orig = minimatch$1;
      const m = (p, pattern2, options2) => orig(p, pattern2, ext(def, options2));
      m.Minimatch = class Minimatch extends orig.Minimatch {
        constructor(pattern2, options2) {
          super(pattern2, ext(def, options2));
        }
      };
      m.Minimatch.defaults = (options2) => orig.defaults(ext(def, options2)).Minimatch;
      m.filter = (pattern2, options2) => orig.filter(pattern2, ext(def, options2));
      m.defaults = (options2) => orig.defaults(ext(def, options2));
      m.makeRe = (pattern2, options2) => orig.makeRe(pattern2, ext(def, options2));
      m.braceExpand = (pattern2, options2) => orig.braceExpand(pattern2, ext(def, options2));
      m.match = (list2, pattern2, options2) => orig.match(list2, pattern2, ext(def, options2));
      return m;
    };
    minimatch$1.braceExpand = (pattern2, options2) => braceExpand(pattern2, options2);
    var braceExpand = (pattern2, options2 = {}) => {
      assertValidPattern(pattern2);
      if (options2.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern2)) {
        return [pattern2];
      }
      return expand(pattern2);
    };
    var MAX_PATTERN_LENGTH = 1024 * 64;
    var assertValidPattern = (pattern2) => {
      if (typeof pattern2 !== "string") {
        throw new TypeError("invalid pattern");
      }
      if (pattern2.length > MAX_PATTERN_LENGTH) {
        throw new TypeError("pattern is too long");
      }
    };
    var SUBPARSE = Symbol("subparse");
    minimatch$1.makeRe = (pattern2, options2) => new Minimatch$1(pattern2, options2 || {}).makeRe();
    minimatch$1.match = (list2, pattern2, options2 = {}) => {
      const mm = new Minimatch$1(pattern2, options2);
      list2 = list2.filter((f) => mm.match(f));
      if (mm.options.nonull && !list2.length) {
        list2.push(pattern2);
      }
      return list2;
    };
    var globUnescape = (s) => s.replace(/\\(.)/g, "$1");
    var charUnescape = (s) => s.replace(/\\([^-\]])/g, "$1");
    var regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    var braExpEscape = (s) => s.replace(/[[\]\\]/g, "\\$&");
    var Minimatch$1 = class Minimatch {
      constructor(pattern2, options2) {
        assertValidPattern(pattern2);
        if (!options2)
          options2 = {};
        this.options = options2;
        this.set = [];
        this.pattern = pattern2;
        this.windowsPathsNoEscape = !!options2.windowsPathsNoEscape || options2.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
          this.pattern = this.pattern.replace(/\\/g, "/");
        }
        this.regexp = null;
        this.negate = false;
        this.comment = false;
        this.empty = false;
        this.partial = !!options2.partial;
        this.make();
      }
      debug() {
      }
      make() {
        const pattern2 = this.pattern;
        const options2 = this.options;
        if (!options2.nocomment && pattern2.charAt(0) === "#") {
          this.comment = true;
          return;
        }
        if (!pattern2) {
          this.empty = true;
          return;
        }
        this.parseNegate();
        let set = this.globSet = this.braceExpand();
        if (options2.debug)
          this.debug = (...args) => console.error(...args);
        this.debug(this.pattern, set);
        set = this.globParts = set.map((s) => s.split(slashSplit));
        this.debug(this.pattern, set);
        set = set.map((s, si, set2) => s.map(this.parse, this));
        this.debug(this.pattern, set);
        set = set.filter((s) => s.indexOf(false) === -1);
        this.debug(this.pattern, set);
        this.set = set;
      }
      parseNegate() {
        if (this.options.nonegate)
          return;
        const pattern2 = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i2 = 0; i2 < pattern2.length && pattern2.charAt(i2) === "!"; i2++) {
          negate = !negate;
          negateOffset++;
        }
        if (negateOffset)
          this.pattern = pattern2.slice(negateOffset);
        this.negate = negate;
      }
      matchOne(file, pattern2, partial) {
        var options2 = this.options;
        this.debug("matchOne", { "this": this, file, pattern: pattern2 });
        this.debug("matchOne", file.length, pattern2.length);
        for (var fi = 0, pi2 = 0, fl = file.length, pl = pattern2.length; fi < fl && pi2 < pl; fi++, pi2++) {
          this.debug("matchOne loop");
          var p = pattern2[pi2];
          var f = file[fi];
          this.debug(pattern2, p, f);
          if (p === false)
            return false;
          if (p === GLOBSTAR) {
            this.debug("GLOBSTAR", [pattern2, p, f]);
            var fr = fi;
            var pr2 = pi2 + 1;
            if (pr2 === pl) {
              this.debug("** at the end");
              for (; fi < fl; fi++) {
                if (file[fi] === "." || file[fi] === ".." || !options2.dot && file[fi].charAt(0) === ".")
                  return false;
              }
              return true;
            }
            while (fr < fl) {
              var swallowee = file[fr];
              this.debug("\nglobstar while", file, fr, pattern2, pr2, swallowee);
              if (this.matchOne(file.slice(fr), pattern2.slice(pr2), partial)) {
                this.debug("globstar found match!", fr, fl, swallowee);
                return true;
              } else {
                if (swallowee === "." || swallowee === ".." || !options2.dot && swallowee.charAt(0) === ".") {
                  this.debug("dot detected!", file, fr, pattern2, pr2);
                  break;
                }
                this.debug("globstar swallow a segment, and continue");
                fr++;
              }
            }
            if (partial) {
              this.debug("\n>>> no match, partial?", file, fr, pattern2, pr2);
              if (fr === fl)
                return true;
            }
            return false;
          }
          var hit;
          if (typeof p === "string") {
            hit = f === p;
            this.debug("string match", p, f, hit);
          } else {
            hit = f.match(p);
            this.debug("pattern match", p, f, hit);
          }
          if (!hit)
            return false;
        }
        if (fi === fl && pi2 === pl) {
          return true;
        } else if (fi === fl) {
          return partial;
        } else if (pi2 === pl) {
          return fi === fl - 1 && file[fi] === "";
        }
        throw new Error("wtf?");
      }
      braceExpand() {
        return braceExpand(this.pattern, this.options);
      }
      parse(pattern2, isSub) {
        assertValidPattern(pattern2);
        const options2 = this.options;
        if (pattern2 === "**") {
          if (!options2.noglobstar)
            return GLOBSTAR;
          else
            pattern2 = "*";
        }
        if (pattern2 === "")
          return "";
        let re2 = "";
        let hasMagic = !!options2.nocase;
        let escaping = false;
        const patternListStack = [];
        const negativeLists = [];
        let stateChar;
        let inClass = false;
        let reClassStart = -1;
        let classStart = -1;
        let cs;
        let pl;
        let sp;
        const patternStart = pattern2.charAt(0) === "." ? "" : options2.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
        const clearStateChar = () => {
          if (stateChar) {
            switch (stateChar) {
              case "*":
                re2 += star$1;
                hasMagic = true;
                break;
              case "?":
                re2 += qmark;
                hasMagic = true;
                break;
              default:
                re2 += "\\" + stateChar;
                break;
            }
            this.debug("clearStateChar %j %j", stateChar, re2);
            stateChar = false;
          }
        };
        for (let i2 = 0, c; i2 < pattern2.length && (c = pattern2.charAt(i2)); i2++) {
          this.debug("%s	%s %s %j", pattern2, i2, re2, c);
          if (escaping) {
            if (c === "/") {
              return false;
            }
            if (reSpecials[c]) {
              re2 += "\\";
            }
            re2 += c;
            escaping = false;
            continue;
          }
          switch (c) {
            case "/": {
              return false;
            }
            case "\\":
              if (inClass && pattern2.charAt(i2 + 1) === "-") {
                re2 += c;
                continue;
              }
              clearStateChar();
              escaping = true;
              continue;
            case "?":
            case "*":
            case "+":
            case "@":
            case "!":
              this.debug("%s	%s %s %j <-- stateChar", pattern2, i2, re2, c);
              if (inClass) {
                this.debug("  in class");
                if (c === "!" && i2 === classStart + 1)
                  c = "^";
                re2 += c;
                continue;
              }
              this.debug("call clearStateChar %j", stateChar);
              clearStateChar();
              stateChar = c;
              if (options2.noext)
                clearStateChar();
              continue;
            case "(":
              if (inClass) {
                re2 += "(";
                continue;
              }
              if (!stateChar) {
                re2 += "\\(";
                continue;
              }
              patternListStack.push({
                type: stateChar,
                start: i2 - 1,
                reStart: re2.length,
                open: plTypes[stateChar].open,
                close: plTypes[stateChar].close
              });
              re2 += stateChar === "!" ? "(?:(?!(?:" : "(?:";
              this.debug("plType %j %j", stateChar, re2);
              stateChar = false;
              continue;
            case ")":
              if (inClass || !patternListStack.length) {
                re2 += "\\)";
                continue;
              }
              clearStateChar();
              hasMagic = true;
              pl = patternListStack.pop();
              re2 += pl.close;
              if (pl.type === "!") {
                negativeLists.push(pl);
              }
              pl.reEnd = re2.length;
              continue;
            case "|":
              if (inClass || !patternListStack.length) {
                re2 += "\\|";
                continue;
              }
              clearStateChar();
              re2 += "|";
              continue;
            case "[":
              clearStateChar();
              if (inClass) {
                re2 += "\\" + c;
                continue;
              }
              inClass = true;
              classStart = i2;
              reClassStart = re2.length;
              re2 += c;
              continue;
            case "]":
              if (i2 === classStart + 1 || !inClass) {
                re2 += "\\" + c;
                continue;
              }
              cs = pattern2.substring(classStart + 1, i2);
              try {
                RegExp("[" + braExpEscape(charUnescape(cs)) + "]");
                re2 += c;
              } catch (er) {
                re2 = re2.substring(0, reClassStart) + "(?:$.)";
              }
              hasMagic = true;
              inClass = false;
              continue;
            default:
              clearStateChar();
              if (reSpecials[c] && !(c === "^" && inClass)) {
                re2 += "\\";
              }
              re2 += c;
              break;
          }
        }
        if (inClass) {
          cs = pattern2.slice(classStart + 1);
          sp = this.parse(cs, SUBPARSE);
          re2 = re2.substring(0, reClassStart) + "\\[" + sp[0];
          hasMagic = hasMagic || sp[1];
        }
        for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
          let tail;
          tail = re2.slice(pl.reStart + pl.open.length);
          this.debug("setting tail", re2, pl);
          tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_2, $1, $2) => {
            if (!$2) {
              $2 = "\\";
            }
            return $1 + $1 + $2 + "|";
          });
          this.debug("tail=%j\n   %s", tail, tail, pl, re2);
          const t = pl.type === "*" ? star$1 : pl.type === "?" ? qmark : "\\" + pl.type;
          hasMagic = true;
          re2 = re2.slice(0, pl.reStart) + t + "\\(" + tail;
        }
        clearStateChar();
        if (escaping) {
          re2 += "\\\\";
        }
        const addPatternStart = addPatternStartSet[re2.charAt(0)];
        for (let n = negativeLists.length - 1; n > -1; n--) {
          const nl = negativeLists[n];
          const nlBefore = re2.slice(0, nl.reStart);
          const nlFirst = re2.slice(nl.reStart, nl.reEnd - 8);
          let nlAfter = re2.slice(nl.reEnd);
          const nlLast = re2.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
          const openParensBefore = nlBefore.split("(").length - 1;
          let cleanAfter = nlAfter;
          for (let i2 = 0; i2 < openParensBefore; i2++) {
            cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
          }
          nlAfter = cleanAfter;
          const dollar2 = nlAfter === "" && isSub !== SUBPARSE ? "$" : "";
          re2 = nlBefore + nlFirst + nlAfter + dollar2 + nlLast;
        }
        if (re2 !== "" && hasMagic) {
          re2 = "(?=.)" + re2;
        }
        if (addPatternStart) {
          re2 = patternStart + re2;
        }
        if (isSub === SUBPARSE) {
          return [re2, hasMagic];
        }
        if (!hasMagic) {
          return globUnescape(pattern2);
        }
        const flags = options2.nocase ? "i" : "";
        try {
          return Object.assign(new RegExp("^" + re2 + "$", flags), {
            _glob: pattern2,
            _src: re2
          });
        } catch (er) {
          return new RegExp("$.");
        }
      }
      makeRe() {
        if (this.regexp || this.regexp === false)
          return this.regexp;
        const set = this.set;
        if (!set.length) {
          this.regexp = false;
          return this.regexp;
        }
        const options2 = this.options;
        const twoStar = options2.noglobstar ? star$1 : options2.dot ? twoStarDot : twoStarNoDot;
        const flags = options2.nocase ? "i" : "";
        let re2 = set.map((pattern2) => {
          pattern2 = pattern2.map((p) => typeof p === "string" ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set2, p) => {
            if (!(set2[set2.length - 1] === GLOBSTAR && p === GLOBSTAR)) {
              set2.push(p);
            }
            return set2;
          }, []);
          pattern2.forEach((p, i2) => {
            if (p !== GLOBSTAR || pattern2[i2 - 1] === GLOBSTAR) {
              return;
            }
            if (i2 === 0) {
              if (pattern2.length > 1) {
                pattern2[i2 + 1] = "(?:\\/|" + twoStar + "\\/)?" + pattern2[i2 + 1];
              } else {
                pattern2[i2] = twoStar;
              }
            } else if (i2 === pattern2.length - 1) {
              pattern2[i2 - 1] += "(?:\\/|" + twoStar + ")?";
            } else {
              pattern2[i2 - 1] += "(?:\\/|\\/" + twoStar + "\\/)" + pattern2[i2 + 1];
              pattern2[i2 + 1] = GLOBSTAR;
            }
          });
          return pattern2.filter((p) => p !== GLOBSTAR).join("/");
        }).join("|");
        re2 = "^(?:" + re2 + ")$";
        if (this.negate)
          re2 = "^(?!" + re2 + ").*$";
        try {
          this.regexp = new RegExp(re2, flags);
        } catch (ex) {
          this.regexp = false;
        }
        return this.regexp;
      }
      match(f, partial = this.partial) {
        this.debug("match", f, this.pattern);
        if (this.comment)
          return false;
        if (this.empty)
          return f === "";
        if (f === "/" && partial)
          return true;
        const options2 = this.options;
        if (path$1.sep !== "/") {
          f = f.split(path$1.sep).join("/");
        }
        f = f.split(slashSplit);
        this.debug(this.pattern, "split", f);
        const set = this.set;
        this.debug(this.pattern, "set", set);
        let filename;
        for (let i2 = f.length - 1; i2 >= 0; i2--) {
          filename = f[i2];
          if (filename)
            break;
        }
        for (let i2 = 0; i2 < set.length; i2++) {
          const pattern2 = set[i2];
          let file = f;
          if (options2.matchBase && pattern2.length === 1) {
            file = [filename];
          }
          const hit = this.matchOne(file, pattern2, partial);
          if (hit) {
            if (options2.flipNegate)
              return true;
            return !this.negate;
          }
        }
        if (options2.flipNegate)
          return false;
        return this.negate;
      }
      static defaults(def) {
        return minimatch$1.defaults(def).Minimatch;
      }
    };
    minimatch$1.Minimatch = Minimatch$1;
    var inheritsExports = {};
    var inherits = {
      get exports() {
        return inheritsExports;
      },
      set exports(v) {
        inheritsExports = v;
      }
    };
    var inherits_browserExports = {};
    var inherits_browser = {
      get exports() {
        return inherits_browserExports;
      },
      set exports(v) {
        inherits_browserExports = v;
      }
    };
    var hasRequiredInherits_browser;
    function requireInherits_browser() {
      if (hasRequiredInherits_browser)
        return inherits_browserExports;
      hasRequiredInherits_browser = 1;
      if (typeof Object.create === "function") {
        inherits_browser.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            ctor.prototype = Object.create(superCtor.prototype, {
              constructor: {
                value: ctor,
                enumerable: false,
                writable: true,
                configurable: true
              }
            });
          }
        };
      } else {
        inherits_browser.exports = function inherits2(ctor, superCtor) {
          if (superCtor) {
            ctor.super_ = superCtor;
            var TempCtor = function() {
            };
            TempCtor.prototype = superCtor.prototype;
            ctor.prototype = new TempCtor();
            ctor.prototype.constructor = ctor;
          }
        };
      }
      return inherits_browserExports;
    }
    (function(module3) {
      try {
        var util = require("util");
        if (typeof util.inherits !== "function")
          throw "";
        module3.exports = util.inherits;
      } catch (e) {
        module3.exports = requireInherits_browser();
      }
    })(inherits);
    getDefaultExportFromCjs(inheritsExports);
    var common = {};
    common.setopts = setopts;
    common.ownProp = ownProp;
    common.makeAbs = makeAbs;
    common.finish = finish;
    common.mark = mark;
    common.isIgnored = isIgnored;
    common.childrenIgnored = childrenIgnored;
    function ownProp(obj, field) {
      return Object.prototype.hasOwnProperty.call(obj, field);
    }
    var fs = require$$0$1;
    var path = require$$4;
    var minimatch = minimatch_1;
    var isAbsolute = require$$4.isAbsolute;
    var Minimatch = minimatch.Minimatch;
    function alphasort(a, b) {
      return a.localeCompare(b, "en");
    }
    function setupIgnores(self2, options2) {
      self2.ignore = options2.ignore || [];
      if (!Array.isArray(self2.ignore))
        self2.ignore = [self2.ignore];
      if (self2.ignore.length) {
        self2.ignore = self2.ignore.map(ignoreMap);
      }
    }
    function ignoreMap(pattern2) {
      var gmatcher = null;
      if (pattern2.slice(-3) === "/**") {
        var gpattern = pattern2.replace(/(\/\*\*)+$/, "");
        gmatcher = new Minimatch(gpattern, { dot: true });
      }
      return {
        matcher: new Minimatch(pattern2, { dot: true }),
        gmatcher
      };
    }
    function setopts(self2, pattern2, options2) {
      if (!options2)
        options2 = {};
      if (options2.matchBase && pattern2.indexOf("/") === -1) {
        if (options2.noglobstar) {
          throw new Error("base matching requires globstar");
        }
        pattern2 = "**/" + pattern2;
      }
      self2.silent = !!options2.silent;
      self2.pattern = pattern2;
      self2.strict = options2.strict !== false;
      self2.realpath = !!options2.realpath;
      self2.realpathCache = options2.realpathCache || /* @__PURE__ */ Object.create(null);
      self2.follow = !!options2.follow;
      self2.dot = !!options2.dot;
      self2.mark = !!options2.mark;
      self2.nodir = !!options2.nodir;
      if (self2.nodir)
        self2.mark = true;
      self2.sync = !!options2.sync;
      self2.nounique = !!options2.nounique;
      self2.nonull = !!options2.nonull;
      self2.nosort = !!options2.nosort;
      self2.nocase = !!options2.nocase;
      self2.stat = !!options2.stat;
      self2.noprocess = !!options2.noprocess;
      self2.absolute = !!options2.absolute;
      self2.fs = options2.fs || fs;
      self2.maxLength = options2.maxLength || Infinity;
      self2.cache = options2.cache || /* @__PURE__ */ Object.create(null);
      self2.statCache = options2.statCache || /* @__PURE__ */ Object.create(null);
      self2.symlinks = options2.symlinks || /* @__PURE__ */ Object.create(null);
      setupIgnores(self2, options2);
      self2.changedCwd = false;
      var cwd = process.cwd();
      if (!ownProp(options2, "cwd"))
        self2.cwd = path.resolve(cwd);
      else {
        self2.cwd = path.resolve(options2.cwd);
        self2.changedCwd = self2.cwd !== cwd;
      }
      self2.root = options2.root || path.resolve(self2.cwd, "/");
      self2.root = path.resolve(self2.root);
      self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
      self2.nomount = !!options2.nomount;
      if (process.platform === "win32") {
        self2.root = self2.root.replace(/\\/g, "/");
        self2.cwd = self2.cwd.replace(/\\/g, "/");
        self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
      }
      options2.nonegate = true;
      options2.nocomment = true;
      options2.allowWindowsEscape = true;
      self2.minimatch = new Minimatch(pattern2, options2);
      self2.options = self2.minimatch.options;
    }
    function finish(self2) {
      var nou = self2.nounique;
      var all = nou ? [] : /* @__PURE__ */ Object.create(null);
      for (var i2 = 0, l = self2.matches.length; i2 < l; i2++) {
        var matches = self2.matches[i2];
        if (!matches || Object.keys(matches).length === 0) {
          if (self2.nonull) {
            var literal = self2.minimatch.globSet[i2];
            if (nou)
              all.push(literal);
            else
              all[literal] = true;
          }
        } else {
          var m = Object.keys(matches);
          if (nou)
            all.push.apply(all, m);
          else
            m.forEach(function(m2) {
              all[m2] = true;
            });
        }
      }
      if (!nou)
        all = Object.keys(all);
      if (!self2.nosort)
        all = all.sort(alphasort);
      if (self2.mark) {
        for (var i2 = 0; i2 < all.length; i2++) {
          all[i2] = self2._mark(all[i2]);
        }
        if (self2.nodir) {
          all = all.filter(function(e) {
            var notDir = !/\/$/.test(e);
            var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
            if (notDir && c)
              notDir = c !== "DIR" && !Array.isArray(c);
            return notDir;
          });
        }
      }
      if (self2.ignore.length)
        all = all.filter(function(m2) {
          return !isIgnored(self2, m2);
        });
      self2.found = all;
    }
    function mark(self2, p) {
      var abs = makeAbs(self2, p);
      var c = self2.cache[abs];
      var m = p;
      if (c) {
        var isDir = c === "DIR" || Array.isArray(c);
        var slash = p.slice(-1) === "/";
        if (isDir && !slash)
          m += "/";
        else if (!isDir && slash)
          m = m.slice(0, -1);
        if (m !== p) {
          var mabs = makeAbs(self2, m);
          self2.statCache[mabs] = self2.statCache[abs];
          self2.cache[mabs] = self2.cache[abs];
        }
      }
      return m;
    }
    function makeAbs(self2, f) {
      var abs = f;
      if (f.charAt(0) === "/") {
        abs = path.join(self2.root, f);
      } else if (isAbsolute(f) || f === "") {
        abs = f;
      } else if (self2.changedCwd) {
        abs = path.resolve(self2.cwd, f);
      } else {
        abs = path.resolve(f);
      }
      if (process.platform === "win32")
        abs = abs.replace(/\\/g, "/");
      return abs;
    }
    function isIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    function childrenIgnored(self2, path2) {
      if (!self2.ignore.length)
        return false;
      return self2.ignore.some(function(item) {
        return !!(item.gmatcher && item.gmatcher.match(path2));
      });
    }
    var sync;
    var hasRequiredSync;
    function requireSync() {
      if (hasRequiredSync)
        return sync;
      hasRequiredSync = 1;
      sync = globSync;
      globSync.GlobSync = GlobSync;
      var rp = fs_realpath;
      var minimatch2 = minimatch_1;
      minimatch2.Minimatch;
      requireGlob().Glob;
      var path2 = require$$4;
      var assert = require$$5;
      var isAbsolute2 = require$$4.isAbsolute;
      var common$1 = common;
      var setopts2 = common$1.setopts;
      var ownProp2 = common$1.ownProp;
      var childrenIgnored2 = common$1.childrenIgnored;
      var isIgnored2 = common$1.isIgnored;
      function globSync(pattern2, options2) {
        if (typeof options2 === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        return new GlobSync(pattern2, options2).found;
      }
      function GlobSync(pattern2, options2) {
        if (!pattern2)
          throw new Error("must provide pattern");
        if (typeof options2 === "function" || arguments.length === 3)
          throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
        if (!(this instanceof GlobSync))
          return new GlobSync(pattern2, options2);
        setopts2(this, pattern2, options2);
        if (this.noprocess)
          return this;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        for (var i2 = 0; i2 < n; i2++) {
          this._process(this.minimatch.set[i2], i2, false);
        }
        this._finish();
      }
      GlobSync.prototype._finish = function() {
        assert.ok(this instanceof GlobSync);
        if (this.realpath) {
          var self2 = this;
          this.matches.forEach(function(matchset, index) {
            var set = self2.matches[index] = /* @__PURE__ */ Object.create(null);
            for (var p in matchset) {
              try {
                p = self2._makeAbs(p);
                var real2 = rp.realpathSync(p, self2.realpathCache);
                set[real2] = true;
              } catch (er) {
                if (er.syscall === "stat")
                  set[self2._makeAbs(p)] = true;
                else
                  throw er;
              }
            }
          });
        }
        common$1.finish(this);
      };
      GlobSync.prototype._process = function(pattern2, index, inGlobStar) {
        assert.ok(this instanceof GlobSync);
        var n = 0;
        while (typeof pattern2[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern2.length:
            this._processSimple(pattern2.join("/"), index);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern2.slice(0, n).join("/");
            break;
        }
        var remain = pattern2.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute2(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored2(this, read))
          return;
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
      };
      GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e = entries[i2];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return;
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i2 = 0; i2 < len; i2++) {
            var e = matchedEntries[i2];
            if (prefix) {
              if (prefix.slice(-1) !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path2.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return;
        }
        remain.shift();
        for (var i2 = 0; i2 < len; i2++) {
          var e = matchedEntries[i2];
          var newPattern;
          if (prefix)
            newPattern = [prefix, e];
          else
            newPattern = [e];
          this._process(newPattern.concat(remain), index, inGlobStar);
        }
      };
      GlobSync.prototype._emitMatch = function(index, e) {
        if (isIgnored2(this, e))
          return;
        var abs = this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute) {
          e = abs;
        }
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        if (this.stat)
          this._stat(e);
      };
      GlobSync.prototype._readdirInGlobStar = function(abs) {
        if (this.follow)
          return this._readdir(abs, false);
        var entries;
        var lstat;
        try {
          lstat = this.fs.lstatSync(abs);
        } catch (er) {
          if (er.code === "ENOENT") {
            return null;
          }
        }
        var isSym = lstat && lstat.isSymbolicLink();
        this.symlinks[abs] = isSym;
        if (!isSym && lstat && !lstat.isDirectory())
          this.cache[abs] = "FILE";
        else
          entries = this._readdir(abs, false);
        return entries;
      };
      GlobSync.prototype._readdir = function(abs, inGlobStar) {
        if (inGlobStar && !ownProp2(this.symlinks, abs))
          return this._readdirInGlobStar(abs);
        if (ownProp2(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return null;
          if (Array.isArray(c))
            return c;
        }
        try {
          return this._readdirEntries(abs, this.fs.readdirSync(abs));
        } catch (er) {
          this._readdirError(abs, er);
          return null;
        }
      };
      GlobSync.prototype._readdirEntries = function(abs, entries) {
        if (!this.mark && !this.stat) {
          for (var i2 = 0; i2 < entries.length; i2++) {
            var e = entries[i2];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return entries;
      };
      GlobSync.prototype._readdirError = function(f, er) {
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error = new Error(er.code + " invalid cwd " + this.cwd);
              error.path = this.cwd;
              error.code = er.code;
              throw error;
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict)
              throw er;
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
      };
      GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
        var entries = this._readdir(abs, inGlobStar);
        if (!entries)
          return;
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false);
        var len = entries.length;
        var isSym = this.symlinks[abs];
        if (isSym && inGlobStar)
          return;
        for (var i2 = 0; i2 < len; i2++) {
          var e = entries[i2];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
          this._process(instead, index, true);
          var below = gspref.concat(entries[i2], remain);
          this._process(below, index, true);
        }
      };
      GlobSync.prototype._processSimple = function(prefix, index) {
        var exists = this._stat(prefix);
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists)
          return;
        if (prefix && isAbsolute2(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path2.join(this.root, prefix);
          } else {
            prefix = path2.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
      };
      GlobSync.prototype._stat = function(f) {
        var abs = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return false;
        if (!this.stat && ownProp2(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return c;
          if (needDir && c === "FILE")
            return false;
        }
        var stat = this.statCache[abs];
        if (!stat) {
          var lstat;
          try {
            lstat = this.fs.lstatSync(abs);
          } catch (er) {
            if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
              this.statCache[abs] = false;
              return false;
            }
          }
          if (lstat && lstat.isSymbolicLink()) {
            try {
              stat = this.fs.statSync(abs);
            } catch (er) {
              stat = lstat;
            }
          } else {
            stat = lstat;
          }
        }
        this.statCache[abs] = stat;
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return false;
        return c;
      };
      GlobSync.prototype._mark = function(p) {
        return common$1.mark(this, p);
      };
      GlobSync.prototype._makeAbs = function(f) {
        return common$1.makeAbs(this, f);
      };
      return sync;
    }
    var wrappy_1 = wrappy$2;
    function wrappy$2(fn, cb) {
      if (fn && cb)
        return wrappy$2(fn)(cb);
      if (typeof fn !== "function")
        throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i2 = 0; i2 < args.length; i2++) {
          args[i2] = arguments[i2];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
    }
    var onceExports = {};
    var once$2 = {
      get exports() {
        return onceExports;
      },
      set exports(v) {
        onceExports = v;
      }
    };
    var wrappy$1 = wrappy_1;
    once$2.exports = wrappy$1(once$1);
    onceExports.strict = wrappy$1(onceStrict);
    once$1.proto = once$1(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: function() {
          return once$1(this);
        },
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function() {
          return onceStrict(this);
        },
        configurable: true
      });
    });
    function once$1(fn) {
      var f = function() {
        if (f.called)
          return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      f.called = false;
      return f;
    }
    function onceStrict(fn) {
      var f = function() {
        if (f.called)
          throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      };
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
    var wrappy = wrappy_1;
    var reqs = /* @__PURE__ */ Object.create(null);
    var once = onceExports;
    var inflight_1 = wrappy(inflight);
    function inflight(key, cb) {
      if (reqs[key]) {
        reqs[key].push(cb);
        return null;
      } else {
        reqs[key] = [cb];
        return makeres(key);
      }
    }
    function makeres(key) {
      return once(function RES() {
        var cbs = reqs[key];
        var len = cbs.length;
        var args = slice(arguments);
        try {
          for (var i2 = 0; i2 < len; i2++) {
            cbs[i2].apply(null, args);
          }
        } finally {
          if (cbs.length > len) {
            cbs.splice(0, len);
            process.nextTick(function() {
              RES.apply(null, args);
            });
          } else {
            delete reqs[key];
          }
        }
      });
    }
    function slice(args) {
      var length = args.length;
      var array = [];
      for (var i2 = 0; i2 < length; i2++)
        array[i2] = args[i2];
      return array;
    }
    var glob_1;
    var hasRequiredGlob;
    function requireGlob() {
      if (hasRequiredGlob)
        return glob_1;
      hasRequiredGlob = 1;
      glob_1 = glob2;
      var rp = fs_realpath;
      var minimatch2 = minimatch_1;
      minimatch2.Minimatch;
      var inherits2 = inheritsExports;
      var EE = require$$3.EventEmitter;
      var path2 = require$$4;
      var assert = require$$5;
      var isAbsolute2 = require$$4.isAbsolute;
      var globSync = requireSync();
      var common$1 = common;
      var setopts2 = common$1.setopts;
      var ownProp2 = common$1.ownProp;
      var inflight2 = inflight_1;
      var childrenIgnored2 = common$1.childrenIgnored;
      var isIgnored2 = common$1.isIgnored;
      var once2 = onceExports;
      function glob2(pattern2, options2, cb) {
        if (typeof options2 === "function")
          cb = options2, options2 = {};
        if (!options2)
          options2 = {};
        if (options2.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return globSync(pattern2, options2);
        }
        return new Glob2(pattern2, options2, cb);
      }
      glob2.sync = globSync;
      var GlobSync = glob2.GlobSync = globSync.GlobSync;
      glob2.glob = glob2;
      function extend(origin, add) {
        if (add === null || typeof add !== "object") {
          return origin;
        }
        var keys = Object.keys(add);
        var i2 = keys.length;
        while (i2--) {
          origin[keys[i2]] = add[keys[i2]];
        }
        return origin;
      }
      glob2.hasMagic = function(pattern2, options_) {
        var options2 = extend({}, options_);
        options2.noprocess = true;
        var g = new Glob2(pattern2, options2);
        var set = g.minimatch.set;
        if (!pattern2)
          return false;
        if (set.length > 1)
          return true;
        for (var j = 0; j < set[0].length; j++) {
          if (typeof set[0][j] !== "string")
            return true;
        }
        return false;
      };
      glob2.Glob = Glob2;
      inherits2(Glob2, EE);
      function Glob2(pattern2, options2, cb) {
        if (typeof options2 === "function") {
          cb = options2;
          options2 = null;
        }
        if (options2 && options2.sync) {
          if (cb)
            throw new TypeError("callback provided to sync glob");
          return new GlobSync(pattern2, options2);
        }
        if (!(this instanceof Glob2))
          return new Glob2(pattern2, options2, cb);
        setopts2(this, pattern2, options2);
        this._didRealPath = false;
        var n = this.minimatch.set.length;
        this.matches = new Array(n);
        if (typeof cb === "function") {
          cb = once2(cb);
          this.on("error", cb);
          this.on("end", function(matches) {
            cb(null, matches);
          });
        }
        var self2 = this;
        this._processing = 0;
        this._emitQueue = [];
        this._processQueue = [];
        this.paused = false;
        if (this.noprocess)
          return this;
        if (n === 0)
          return done();
        var sync2 = true;
        for (var i2 = 0; i2 < n; i2++) {
          this._process(this.minimatch.set[i2], i2, false, done);
        }
        sync2 = false;
        function done() {
          --self2._processing;
          if (self2._processing <= 0) {
            if (sync2) {
              process.nextTick(function() {
                self2._finish();
              });
            } else {
              self2._finish();
            }
          }
        }
      }
      Glob2.prototype._finish = function() {
        assert(this instanceof Glob2);
        if (this.aborted)
          return;
        if (this.realpath && !this._didRealpath)
          return this._realpath();
        common$1.finish(this);
        this.emit("end", this.found);
      };
      Glob2.prototype._realpath = function() {
        if (this._didRealpath)
          return;
        this._didRealpath = true;
        var n = this.matches.length;
        if (n === 0)
          return this._finish();
        var self2 = this;
        for (var i2 = 0; i2 < this.matches.length; i2++)
          this._realpathSet(i2, next);
        function next() {
          if (--n === 0)
            self2._finish();
        }
      };
      Glob2.prototype._realpathSet = function(index, cb) {
        var matchset = this.matches[index];
        if (!matchset)
          return cb();
        var found = Object.keys(matchset);
        var self2 = this;
        var n = found.length;
        if (n === 0)
          return cb();
        var set = this.matches[index] = /* @__PURE__ */ Object.create(null);
        found.forEach(function(p, i2) {
          p = self2._makeAbs(p);
          rp.realpath(p, self2.realpathCache, function(er, real2) {
            if (!er)
              set[real2] = true;
            else if (er.syscall === "stat")
              set[p] = true;
            else
              self2.emit("error", er);
            if (--n === 0) {
              self2.matches[index] = set;
              cb();
            }
          });
        });
      };
      Glob2.prototype._mark = function(p) {
        return common$1.mark(this, p);
      };
      Glob2.prototype._makeAbs = function(f) {
        return common$1.makeAbs(this, f);
      };
      Glob2.prototype.abort = function() {
        this.aborted = true;
        this.emit("abort");
      };
      Glob2.prototype.pause = function() {
        if (!this.paused) {
          this.paused = true;
          this.emit("pause");
        }
      };
      Glob2.prototype.resume = function() {
        if (this.paused) {
          this.emit("resume");
          this.paused = false;
          if (this._emitQueue.length) {
            var eq = this._emitQueue.slice(0);
            this._emitQueue.length = 0;
            for (var i2 = 0; i2 < eq.length; i2++) {
              var e = eq[i2];
              this._emitMatch(e[0], e[1]);
            }
          }
          if (this._processQueue.length) {
            var pq = this._processQueue.slice(0);
            this._processQueue.length = 0;
            for (var i2 = 0; i2 < pq.length; i2++) {
              var p = pq[i2];
              this._processing--;
              this._process(p[0], p[1], p[2], p[3]);
            }
          }
        }
      };
      Glob2.prototype._process = function(pattern2, index, inGlobStar, cb) {
        assert(this instanceof Glob2);
        assert(typeof cb === "function");
        if (this.aborted)
          return;
        this._processing++;
        if (this.paused) {
          this._processQueue.push([pattern2, index, inGlobStar, cb]);
          return;
        }
        var n = 0;
        while (typeof pattern2[n] === "string") {
          n++;
        }
        var prefix;
        switch (n) {
          case pattern2.length:
            this._processSimple(pattern2.join("/"), index, cb);
            return;
          case 0:
            prefix = null;
            break;
          default:
            prefix = pattern2.slice(0, n).join("/");
            break;
        }
        var remain = pattern2.slice(n);
        var read;
        if (prefix === null)
          read = ".";
        else if (isAbsolute2(prefix) || isAbsolute2(pattern2.map(function(p) {
          return typeof p === "string" ? p : "[*]";
        }).join("/"))) {
          if (!prefix || !isAbsolute2(prefix))
            prefix = "/" + prefix;
          read = prefix;
        } else
          read = prefix;
        var abs = this._makeAbs(read);
        if (childrenIgnored2(this, read))
          return cb();
        var isGlobStar = remain[0] === minimatch2.GLOBSTAR;
        if (isGlobStar)
          this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
        else
          this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
      };
      Glob2.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var pn = remain[0];
        var negate = !!this.minimatch.negate;
        var rawGlob = pn._glob;
        var dotOk = this.dot || rawGlob.charAt(0) === ".";
        var matchedEntries = [];
        for (var i2 = 0; i2 < entries.length; i2++) {
          var e = entries[i2];
          if (e.charAt(0) !== "." || dotOk) {
            var m;
            if (negate && !prefix) {
              m = !e.match(pn);
            } else {
              m = e.match(pn);
            }
            if (m)
              matchedEntries.push(e);
          }
        }
        var len = matchedEntries.length;
        if (len === 0)
          return cb();
        if (remain.length === 1 && !this.mark && !this.stat) {
          if (!this.matches[index])
            this.matches[index] = /* @__PURE__ */ Object.create(null);
          for (var i2 = 0; i2 < len; i2++) {
            var e = matchedEntries[i2];
            if (prefix) {
              if (prefix !== "/")
                e = prefix + "/" + e;
              else
                e = prefix + e;
            }
            if (e.charAt(0) === "/" && !this.nomount) {
              e = path2.join(this.root, e);
            }
            this._emitMatch(index, e);
          }
          return cb();
        }
        remain.shift();
        for (var i2 = 0; i2 < len; i2++) {
          var e = matchedEntries[i2];
          if (prefix) {
            if (prefix !== "/")
              e = prefix + "/" + e;
            else
              e = prefix + e;
          }
          this._process([e].concat(remain), index, inGlobStar, cb);
        }
        cb();
      };
      Glob2.prototype._emitMatch = function(index, e) {
        if (this.aborted)
          return;
        if (isIgnored2(this, e))
          return;
        if (this.paused) {
          this._emitQueue.push([index, e]);
          return;
        }
        var abs = isAbsolute2(e) ? e : this._makeAbs(e);
        if (this.mark)
          e = this._mark(e);
        if (this.absolute)
          e = abs;
        if (this.matches[index][e])
          return;
        if (this.nodir) {
          var c = this.cache[abs];
          if (c === "DIR" || Array.isArray(c))
            return;
        }
        this.matches[index][e] = true;
        var st = this.statCache[abs];
        if (st)
          this.emit("stat", e, st);
        this.emit("match", e);
      };
      Glob2.prototype._readdirInGlobStar = function(abs, cb) {
        if (this.aborted)
          return;
        if (this.follow)
          return this._readdir(abs, false, cb);
        var lstatkey = "lstat\0" + abs;
        var self2 = this;
        var lstatcb = inflight2(lstatkey, lstatcb_);
        if (lstatcb)
          self2.fs.lstat(abs, lstatcb);
        function lstatcb_(er, lstat) {
          if (er && er.code === "ENOENT")
            return cb();
          var isSym = lstat && lstat.isSymbolicLink();
          self2.symlinks[abs] = isSym;
          if (!isSym && lstat && !lstat.isDirectory()) {
            self2.cache[abs] = "FILE";
            cb();
          } else
            self2._readdir(abs, false, cb);
        }
      };
      Glob2.prototype._readdir = function(abs, inGlobStar, cb) {
        if (this.aborted)
          return;
        cb = inflight2("readdir\0" + abs + "\0" + inGlobStar, cb);
        if (!cb)
          return;
        if (inGlobStar && !ownProp2(this.symlinks, abs))
          return this._readdirInGlobStar(abs, cb);
        if (ownProp2(this.cache, abs)) {
          var c = this.cache[abs];
          if (!c || c === "FILE")
            return cb();
          if (Array.isArray(c))
            return cb(null, c);
        }
        var self2 = this;
        self2.fs.readdir(abs, readdirCb(this, abs, cb));
      };
      function readdirCb(self2, abs, cb) {
        return function(er, entries) {
          if (er)
            self2._readdirError(abs, er, cb);
          else
            self2._readdirEntries(abs, entries, cb);
        };
      }
      Glob2.prototype._readdirEntries = function(abs, entries, cb) {
        if (this.aborted)
          return;
        if (!this.mark && !this.stat) {
          for (var i2 = 0; i2 < entries.length; i2++) {
            var e = entries[i2];
            if (abs === "/")
              e = abs + e;
            else
              e = abs + "/" + e;
            this.cache[e] = true;
          }
        }
        this.cache[abs] = entries;
        return cb(null, entries);
      };
      Glob2.prototype._readdirError = function(f, er, cb) {
        if (this.aborted)
          return;
        switch (er.code) {
          case "ENOTSUP":
          case "ENOTDIR":
            var abs = this._makeAbs(f);
            this.cache[abs] = "FILE";
            if (abs === this.cwdAbs) {
              var error = new Error(er.code + " invalid cwd " + this.cwd);
              error.path = this.cwd;
              error.code = er.code;
              this.emit("error", error);
              this.abort();
            }
            break;
          case "ENOENT":
          case "ELOOP":
          case "ENAMETOOLONG":
          case "UNKNOWN":
            this.cache[this._makeAbs(f)] = false;
            break;
          default:
            this.cache[this._makeAbs(f)] = false;
            if (this.strict) {
              this.emit("error", er);
              this.abort();
            }
            if (!this.silent)
              console.error("glob error", er);
            break;
        }
        return cb();
      };
      Glob2.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
        var self2 = this;
        this._readdir(abs, inGlobStar, function(er, entries) {
          self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
        });
      };
      Glob2.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
        if (!entries)
          return cb();
        var remainWithoutGlobStar = remain.slice(1);
        var gspref = prefix ? [prefix] : [];
        var noGlobStar = gspref.concat(remainWithoutGlobStar);
        this._process(noGlobStar, index, false, cb);
        var isSym = this.symlinks[abs];
        var len = entries.length;
        if (isSym && inGlobStar)
          return cb();
        for (var i2 = 0; i2 < len; i2++) {
          var e = entries[i2];
          if (e.charAt(0) === "." && !this.dot)
            continue;
          var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
          this._process(instead, index, true, cb);
          var below = gspref.concat(entries[i2], remain);
          this._process(below, index, true, cb);
        }
        cb();
      };
      Glob2.prototype._processSimple = function(prefix, index, cb) {
        var self2 = this;
        this._stat(prefix, function(er, exists) {
          self2._processSimple2(prefix, index, er, exists, cb);
        });
      };
      Glob2.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
        if (!this.matches[index])
          this.matches[index] = /* @__PURE__ */ Object.create(null);
        if (!exists)
          return cb();
        if (prefix && isAbsolute2(prefix) && !this.nomount) {
          var trail = /[\/\\]$/.test(prefix);
          if (prefix.charAt(0) === "/") {
            prefix = path2.join(this.root, prefix);
          } else {
            prefix = path2.resolve(this.root, prefix);
            if (trail)
              prefix += "/";
          }
        }
        if (process.platform === "win32")
          prefix = prefix.replace(/\\/g, "/");
        this._emitMatch(index, prefix);
        cb();
      };
      Glob2.prototype._stat = function(f, cb) {
        var abs = this._makeAbs(f);
        var needDir = f.slice(-1) === "/";
        if (f.length > this.maxLength)
          return cb();
        if (!this.stat && ownProp2(this.cache, abs)) {
          var c = this.cache[abs];
          if (Array.isArray(c))
            c = "DIR";
          if (!needDir || c === "DIR")
            return cb(null, c);
          if (needDir && c === "FILE")
            return cb();
        }
        var stat = this.statCache[abs];
        if (stat !== void 0) {
          if (stat === false)
            return cb(null, stat);
          else {
            var type = stat.isDirectory() ? "DIR" : "FILE";
            if (needDir && type === "FILE")
              return cb();
            else
              return cb(null, type, stat);
          }
        }
        var self2 = this;
        var statcb = inflight2("stat\0" + abs, lstatcb_);
        if (statcb)
          self2.fs.lstat(abs, statcb);
        function lstatcb_(er, lstat) {
          if (lstat && lstat.isSymbolicLink()) {
            return self2.fs.stat(abs, function(er2, stat2) {
              if (er2)
                self2._stat2(f, abs, null, lstat, cb);
              else
                self2._stat2(f, abs, er2, stat2, cb);
            });
          } else {
            self2._stat2(f, abs, er, lstat, cb);
          }
        }
      };
      Glob2.prototype._stat2 = function(f, abs, er, stat, cb) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return cb();
        }
        var needDir = f.slice(-1) === "/";
        this.statCache[abs] = stat;
        if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
          return cb(null, false, stat);
        var c = true;
        if (stat)
          c = stat.isDirectory() ? "DIR" : "FILE";
        this.cache[abs] = this.cache[abs] || c;
        if (needDir && c === "FILE")
          return cb();
        return cb(null, c, stat);
      };
      return glob_1;
    }
    var globExports = requireGlob();
    var Glob = /* @__PURE__ */ getDefaultExportFromCjs(globExports);
    var glob = (regex2, opt) => new Promise((solve, reject) => {
      Glob(regex2, opt, (err, files) => {
        if (err)
          reject(err);
        else
          solve(files);
      });
    });
    var prettySize = (s) => Filesize__namespace.filesize(s, { base: 2, standard: "jedec" });
    var buildIndex = async (path2, { cwd } = {}, tree = []) => {
      const files = await glob(path2, { cwd });
      files.map((file) => {
        const stat = fs$3.statSync(cwd + "/" + file);
        tree.push([
          file,
          stat.birthtime,
          stat.size,
          prettySize(stat.size),
          file.split(".").pop()
        ]);
      });
      return tree.sort((a, b) => new Date(b[1]) - new Date(a[1]));
    };
    var File = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      glob,
      prettySize,
      buildIndex
    });
    var isBrowser = new Function("try {return this===window;}catch(e){ return false;}");
    var isNode = new Function("try {return this===global;}catch(e){return false;}");
    var isElectron = () => {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    };
    var Node = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isBrowser,
      isNode,
      isElectron
    });
    var parseFrontmatter = (s) => {
      const parse2 = frontMatter(s);
      const frontmatter = parse2.attributes;
      const body2 = parse2.body;
      return { frontmatter, body: body2 };
    };
    var MarkDown = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      parseFrontmatter
    });
    var isDark = () => window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "";
    var isMac = () => navigator.platform.indexOf("Mac") > -1;
    var isWindows = () => navigator.platform.indexOf("Win") > -1;
    var scrollTo = (el2, offset = 0, timeout2) => $("html, body").animate({ scrollTop: $(el2).offset().top - offset }, timeout2);
    var pageHeight = () => {
      const body2 = document.body, html2 = document.documentElement;
      return Math.max(body2.scrollHeight, body2.offsetHeight, html2.clientHeight, html2.scrollHeight, html2.offsetHeight);
    };
    var ls = function(key, value) {
      if (localStorage == null)
        return console.log("Local storage not supported!");
      else {
        try {
          let result = "";
          if (typeof value != "undefined") {
            localStorage.setItem(key, value);
            result = value;
          } else {
            result = value === null ? localStorage.removeItem(key) : localStorage.getItem(key);
          }
          return result ? result.replace(/(\r\n|\n|\r)/gm, "") : result;
        } catch (err) {
          const private_browsing_error = "Unable to store local data. Are you using Private Browsing?";
          console.log(/QUOTA_EXCEEDED_ERR/.test(err) ? private_browsing_error : err);
        }
      }
    };
    var Web = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      isDark,
      isMac,
      isWindows,
      scrollTo,
      pageHeight,
      ls
    });
    var utils$2 = {
      g: Global,
      c: Crypto$1,
      o: Object$1,
      a: Array$1,
      s: String$1,
      dom: Dom,
      fs: fs$3,
      file: File,
      node: Node,
      md: MarkDown
    };
    if (isBrowser())
      utils$2.w = Web;
    var Folder = class {
      constructor(pklib, type) {
        __publicField(this, "type");
        __publicField(this, "pklib");
        __publicField(this, "base");
        __publicField(this, "customWrite");
        __publicField(this, "lsFiles", async (ext2 = "md") => {
          const { utils: utils2, cfg } = this.pklib;
          const regex2 = `${this.base}/**/*.${ext2}`;
          let list2 = await utils2.file.glob(regex2);
          list2 = list2.map((f) => f.replace(`${this.base}/`, ""));
          const includesExps = utils2.a.asArray(cfg(`${this.type}.include`) || []);
          const excludeExps = utils2.a.asArray(cfg(`${this.type}.exclude`) || []);
          const files = list2.filter((k) => {
            const include = !includesExps.length ? true : includesExps.find((exp) => {
              return k.search(new RegExp(exp)) >= 0 ? exp : false;
            });
            const exclude = excludeExps.find((exp) => {
              return k.search(new RegExp(exp)) >= 0 ? exp : false;
            });
            return include && !exclude;
          });
          return files;
        });
        this.pklib = pklib;
        this.type = type;
      }
      setBase(path2) {
        this.base = path2 || this.base;
      }
      toPath(path2) {
        if (!this.base)
          throw new Error("folder has no base");
        path2 = `${this.base}/${path2[0] == "/" ? path2.slice(1) : path2}`;
        return path2;
      }
      async write(path2, data, options2) {
        if (this.customWrite)
          return this.customWrite(path2, data, options2);
        await fs$3.outputFile(this.toPath(path2), data, options2);
        return path2;
      }
      async read(path2, options2) {
        return fs$3.readFile(this.toPath(path2), options2);
      }
      async fileExist(path2) {
        return await fs$3.existsSync(this.toPath(path2));
      }
      async dumpAssets(index, encoding) {
        const assets = Object.values(index);
        return Promise.all(assets.map(async (asset) => {
          try {
            const source = this.pklib.vault.toPath(asset.path);
            const destination = asset.url;
            if (!asset.url)
              throw new Error("asset is missing an url");
            if (await this.fileExist(asset.url))
              return;
            const img = fs$3.readFileSync(source, { encoding });
            await this.write(asset.url, img, { encoding });
            return asset.url;
          } catch (e) {
            asset.type = "error";
            asset.err = e.message || e;
            this.pklib.parser.index(asset);
          }
        }));
      }
      async dumpNotes(index, encoding) {
        const notes = Object.values(index);
        return Promise.all(notes.map(async (asset) => {
          try {
            const { content, url } = asset;
            if (!url || !content)
              throw new Error("asset has no url or content");
            await this.write(url, content);
            return url;
          } catch (e) {
            asset.type = "error";
            asset.err = e.message || e;
            this.pklib.parser.index(asset);
          }
        }));
      }
    };
    var markdownItExports = {};
    var markdownIt = {
      get exports() {
        return markdownItExports;
      },
      set exports(v) {
        markdownItExports = v;
      }
    };
    var utils$1 = {};
    var entitiesExports = {};
    var entities$1 = {
      get exports() {
        return entitiesExports;
      },
      set exports(v) {
        entitiesExports = v;
      }
    };
    var Aacute = "\xC1";
    var aacute = "\xE1";
    var Abreve = "\u0102";
    var abreve = "\u0103";
    var ac = "\u223E";
    var acd = "\u223F";
    var acE = "\u223E\u0333";
    var Acirc = "\xC2";
    var acirc = "\xE2";
    var acute = "\xB4";
    var Acy = "\u0410";
    var acy = "\u0430";
    var AElig = "\xC6";
    var aelig = "\xE6";
    var af = "\u2061";
    var Afr = "\u{1D504}";
    var afr = "\u{1D51E}";
    var Agrave = "\xC0";
    var agrave = "\xE0";
    var alefsym = "\u2135";
    var aleph = "\u2135";
    var Alpha = "\u0391";
    var alpha = "\u03B1";
    var Amacr = "\u0100";
    var amacr = "\u0101";
    var amalg = "\u2A3F";
    var amp = "&";
    var AMP = "&";
    var andand = "\u2A55";
    var And = "\u2A53";
    var and = "\u2227";
    var andd = "\u2A5C";
    var andslope = "\u2A58";
    var andv = "\u2A5A";
    var ang = "\u2220";
    var ange = "\u29A4";
    var angle = "\u2220";
    var angmsdaa = "\u29A8";
    var angmsdab = "\u29A9";
    var angmsdac = "\u29AA";
    var angmsdad = "\u29AB";
    var angmsdae = "\u29AC";
    var angmsdaf = "\u29AD";
    var angmsdag = "\u29AE";
    var angmsdah = "\u29AF";
    var angmsd = "\u2221";
    var angrt = "\u221F";
    var angrtvb = "\u22BE";
    var angrtvbd = "\u299D";
    var angsph = "\u2222";
    var angst = "\xC5";
    var angzarr = "\u237C";
    var Aogon = "\u0104";
    var aogon = "\u0105";
    var Aopf = "\u{1D538}";
    var aopf = "\u{1D552}";
    var apacir = "\u2A6F";
    var ap = "\u2248";
    var apE = "\u2A70";
    var ape = "\u224A";
    var apid = "\u224B";
    var apos = "'";
    var ApplyFunction = "\u2061";
    var approx = "\u2248";
    var approxeq = "\u224A";
    var Aring = "\xC5";
    var aring = "\xE5";
    var Ascr = "\u{1D49C}";
    var ascr = "\u{1D4B6}";
    var Assign = "\u2254";
    var ast = "*";
    var asymp = "\u2248";
    var asympeq = "\u224D";
    var Atilde = "\xC3";
    var atilde = "\xE3";
    var Auml = "\xC4";
    var auml = "\xE4";
    var awconint = "\u2233";
    var awint = "\u2A11";
    var backcong = "\u224C";
    var backepsilon = "\u03F6";
    var backprime = "\u2035";
    var backsim = "\u223D";
    var backsimeq = "\u22CD";
    var Backslash = "\u2216";
    var Barv = "\u2AE7";
    var barvee = "\u22BD";
    var barwed = "\u2305";
    var Barwed = "\u2306";
    var barwedge = "\u2305";
    var bbrk = "\u23B5";
    var bbrktbrk = "\u23B6";
    var bcong = "\u224C";
    var Bcy = "\u0411";
    var bcy = "\u0431";
    var bdquo = "\u201E";
    var becaus = "\u2235";
    var because = "\u2235";
    var Because = "\u2235";
    var bemptyv = "\u29B0";
    var bepsi = "\u03F6";
    var bernou = "\u212C";
    var Bernoullis = "\u212C";
    var Beta = "\u0392";
    var beta = "\u03B2";
    var beth = "\u2136";
    var between = "\u226C";
    var Bfr = "\u{1D505}";
    var bfr = "\u{1D51F}";
    var bigcap = "\u22C2";
    var bigcirc = "\u25EF";
    var bigcup = "\u22C3";
    var bigodot = "\u2A00";
    var bigoplus = "\u2A01";
    var bigotimes = "\u2A02";
    var bigsqcup = "\u2A06";
    var bigstar = "\u2605";
    var bigtriangledown = "\u25BD";
    var bigtriangleup = "\u25B3";
    var biguplus = "\u2A04";
    var bigvee = "\u22C1";
    var bigwedge = "\u22C0";
    var bkarow = "\u290D";
    var blacklozenge = "\u29EB";
    var blacksquare = "\u25AA";
    var blacktriangle = "\u25B4";
    var blacktriangledown = "\u25BE";
    var blacktriangleleft = "\u25C2";
    var blacktriangleright = "\u25B8";
    var blank = "\u2423";
    var blk12 = "\u2592";
    var blk14 = "\u2591";
    var blk34 = "\u2593";
    var block$1 = "\u2588";
    var bne = "=\u20E5";
    var bnequiv = "\u2261\u20E5";
    var bNot = "\u2AED";
    var bnot = "\u2310";
    var Bopf = "\u{1D539}";
    var bopf = "\u{1D553}";
    var bot = "\u22A5";
    var bottom = "\u22A5";
    var bowtie = "\u22C8";
    var boxbox = "\u29C9";
    var boxdl = "\u2510";
    var boxdL = "\u2555";
    var boxDl = "\u2556";
    var boxDL = "\u2557";
    var boxdr = "\u250C";
    var boxdR = "\u2552";
    var boxDr = "\u2553";
    var boxDR = "\u2554";
    var boxh = "\u2500";
    var boxH = "\u2550";
    var boxhd = "\u252C";
    var boxHd = "\u2564";
    var boxhD = "\u2565";
    var boxHD = "\u2566";
    var boxhu = "\u2534";
    var boxHu = "\u2567";
    var boxhU = "\u2568";
    var boxHU = "\u2569";
    var boxminus = "\u229F";
    var boxplus = "\u229E";
    var boxtimes = "\u22A0";
    var boxul = "\u2518";
    var boxuL = "\u255B";
    var boxUl = "\u255C";
    var boxUL = "\u255D";
    var boxur = "\u2514";
    var boxuR = "\u2558";
    var boxUr = "\u2559";
    var boxUR = "\u255A";
    var boxv = "\u2502";
    var boxV = "\u2551";
    var boxvh = "\u253C";
    var boxvH = "\u256A";
    var boxVh = "\u256B";
    var boxVH = "\u256C";
    var boxvl = "\u2524";
    var boxvL = "\u2561";
    var boxVl = "\u2562";
    var boxVL = "\u2563";
    var boxvr = "\u251C";
    var boxvR = "\u255E";
    var boxVr = "\u255F";
    var boxVR = "\u2560";
    var bprime = "\u2035";
    var breve = "\u02D8";
    var Breve = "\u02D8";
    var brvbar = "\xA6";
    var bscr = "\u{1D4B7}";
    var Bscr = "\u212C";
    var bsemi = "\u204F";
    var bsim = "\u223D";
    var bsime = "\u22CD";
    var bsolb = "\u29C5";
    var bsol = "\\";
    var bsolhsub = "\u27C8";
    var bull = "\u2022";
    var bullet = "\u2022";
    var bump = "\u224E";
    var bumpE = "\u2AAE";
    var bumpe = "\u224F";
    var Bumpeq = "\u224E";
    var bumpeq = "\u224F";
    var Cacute = "\u0106";
    var cacute = "\u0107";
    var capand = "\u2A44";
    var capbrcup = "\u2A49";
    var capcap = "\u2A4B";
    var cap = "\u2229";
    var Cap = "\u22D2";
    var capcup = "\u2A47";
    var capdot = "\u2A40";
    var CapitalDifferentialD = "\u2145";
    var caps = "\u2229\uFE00";
    var caret = "\u2041";
    var caron = "\u02C7";
    var Cayleys = "\u212D";
    var ccaps = "\u2A4D";
    var Ccaron = "\u010C";
    var ccaron = "\u010D";
    var Ccedil = "\xC7";
    var ccedil = "\xE7";
    var Ccirc = "\u0108";
    var ccirc = "\u0109";
    var Cconint = "\u2230";
    var ccups = "\u2A4C";
    var ccupssm = "\u2A50";
    var Cdot = "\u010A";
    var cdot = "\u010B";
    var cedil = "\xB8";
    var Cedilla = "\xB8";
    var cemptyv = "\u29B2";
    var cent = "\xA2";
    var centerdot = "\xB7";
    var CenterDot = "\xB7";
    var cfr = "\u{1D520}";
    var Cfr = "\u212D";
    var CHcy = "\u0427";
    var chcy = "\u0447";
    var check = "\u2713";
    var checkmark = "\u2713";
    var Chi = "\u03A7";
    var chi = "\u03C7";
    var circ = "\u02C6";
    var circeq = "\u2257";
    var circlearrowleft = "\u21BA";
    var circlearrowright = "\u21BB";
    var circledast = "\u229B";
    var circledcirc = "\u229A";
    var circleddash = "\u229D";
    var CircleDot = "\u2299";
    var circledR = "\xAE";
    var circledS = "\u24C8";
    var CircleMinus = "\u2296";
    var CirclePlus = "\u2295";
    var CircleTimes = "\u2297";
    var cir = "\u25CB";
    var cirE = "\u29C3";
    var cire = "\u2257";
    var cirfnint = "\u2A10";
    var cirmid = "\u2AEF";
    var cirscir = "\u29C2";
    var ClockwiseContourIntegral = "\u2232";
    var CloseCurlyDoubleQuote = "\u201D";
    var CloseCurlyQuote = "\u2019";
    var clubs = "\u2663";
    var clubsuit = "\u2663";
    var colon = ":";
    var Colon = "\u2237";
    var Colone = "\u2A74";
    var colone = "\u2254";
    var coloneq = "\u2254";
    var comma = ",";
    var commat = "@";
    var comp = "\u2201";
    var compfn = "\u2218";
    var complement = "\u2201";
    var complexes = "\u2102";
    var cong = "\u2245";
    var congdot = "\u2A6D";
    var Congruent = "\u2261";
    var conint = "\u222E";
    var Conint = "\u222F";
    var ContourIntegral = "\u222E";
    var copf = "\u{1D554}";
    var Copf = "\u2102";
    var coprod = "\u2210";
    var Coproduct = "\u2210";
    var copy = "\xA9";
    var COPY = "\xA9";
    var copysr = "\u2117";
    var CounterClockwiseContourIntegral = "\u2233";
    var crarr = "\u21B5";
    var cross = "\u2717";
    var Cross = "\u2A2F";
    var Cscr = "\u{1D49E}";
    var cscr = "\u{1D4B8}";
    var csub = "\u2ACF";
    var csube = "\u2AD1";
    var csup = "\u2AD0";
    var csupe = "\u2AD2";
    var ctdot = "\u22EF";
    var cudarrl = "\u2938";
    var cudarrr = "\u2935";
    var cuepr = "\u22DE";
    var cuesc = "\u22DF";
    var cularr = "\u21B6";
    var cularrp = "\u293D";
    var cupbrcap = "\u2A48";
    var cupcap = "\u2A46";
    var CupCap = "\u224D";
    var cup = "\u222A";
    var Cup = "\u22D3";
    var cupcup = "\u2A4A";
    var cupdot = "\u228D";
    var cupor = "\u2A45";
    var cups = "\u222A\uFE00";
    var curarr = "\u21B7";
    var curarrm = "\u293C";
    var curlyeqprec = "\u22DE";
    var curlyeqsucc = "\u22DF";
    var curlyvee = "\u22CE";
    var curlywedge = "\u22CF";
    var curren = "\xA4";
    var curvearrowleft = "\u21B6";
    var curvearrowright = "\u21B7";
    var cuvee = "\u22CE";
    var cuwed = "\u22CF";
    var cwconint = "\u2232";
    var cwint = "\u2231";
    var cylcty = "\u232D";
    var dagger = "\u2020";
    var Dagger = "\u2021";
    var daleth = "\u2138";
    var darr = "\u2193";
    var Darr = "\u21A1";
    var dArr = "\u21D3";
    var dash = "\u2010";
    var Dashv = "\u2AE4";
    var dashv = "\u22A3";
    var dbkarow = "\u290F";
    var dblac = "\u02DD";
    var Dcaron = "\u010E";
    var dcaron = "\u010F";
    var Dcy = "\u0414";
    var dcy = "\u0434";
    var ddagger = "\u2021";
    var ddarr = "\u21CA";
    var DD = "\u2145";
    var dd = "\u2146";
    var DDotrahd = "\u2911";
    var ddotseq = "\u2A77";
    var deg = "\xB0";
    var Del = "\u2207";
    var Delta = "\u0394";
    var delta = "\u03B4";
    var demptyv = "\u29B1";
    var dfisht = "\u297F";
    var Dfr = "\u{1D507}";
    var dfr = "\u{1D521}";
    var dHar = "\u2965";
    var dharl = "\u21C3";
    var dharr = "\u21C2";
    var DiacriticalAcute = "\xB4";
    var DiacriticalDot = "\u02D9";
    var DiacriticalDoubleAcute = "\u02DD";
    var DiacriticalGrave = "`";
    var DiacriticalTilde = "\u02DC";
    var diam = "\u22C4";
    var diamond = "\u22C4";
    var Diamond = "\u22C4";
    var diamondsuit = "\u2666";
    var diams = "\u2666";
    var die = "\xA8";
    var DifferentialD = "\u2146";
    var digamma = "\u03DD";
    var disin = "\u22F2";
    var div = "\xF7";
    var divide = "\xF7";
    var divideontimes = "\u22C7";
    var divonx = "\u22C7";
    var DJcy = "\u0402";
    var djcy = "\u0452";
    var dlcorn = "\u231E";
    var dlcrop = "\u230D";
    var dollar = "$";
    var Dopf = "\u{1D53B}";
    var dopf = "\u{1D555}";
    var Dot = "\xA8";
    var dot = "\u02D9";
    var DotDot = "\u20DC";
    var doteq = "\u2250";
    var doteqdot = "\u2251";
    var DotEqual = "\u2250";
    var dotminus = "\u2238";
    var dotplus = "\u2214";
    var dotsquare = "\u22A1";
    var doublebarwedge = "\u2306";
    var DoubleContourIntegral = "\u222F";
    var DoubleDot = "\xA8";
    var DoubleDownArrow = "\u21D3";
    var DoubleLeftArrow = "\u21D0";
    var DoubleLeftRightArrow = "\u21D4";
    var DoubleLeftTee = "\u2AE4";
    var DoubleLongLeftArrow = "\u27F8";
    var DoubleLongLeftRightArrow = "\u27FA";
    var DoubleLongRightArrow = "\u27F9";
    var DoubleRightArrow = "\u21D2";
    var DoubleRightTee = "\u22A8";
    var DoubleUpArrow = "\u21D1";
    var DoubleUpDownArrow = "\u21D5";
    var DoubleVerticalBar = "\u2225";
    var DownArrowBar = "\u2913";
    var downarrow = "\u2193";
    var DownArrow = "\u2193";
    var Downarrow = "\u21D3";
    var DownArrowUpArrow = "\u21F5";
    var DownBreve = "\u0311";
    var downdownarrows = "\u21CA";
    var downharpoonleft = "\u21C3";
    var downharpoonright = "\u21C2";
    var DownLeftRightVector = "\u2950";
    var DownLeftTeeVector = "\u295E";
    var DownLeftVectorBar = "\u2956";
    var DownLeftVector = "\u21BD";
    var DownRightTeeVector = "\u295F";
    var DownRightVectorBar = "\u2957";
    var DownRightVector = "\u21C1";
    var DownTeeArrow = "\u21A7";
    var DownTee = "\u22A4";
    var drbkarow = "\u2910";
    var drcorn = "\u231F";
    var drcrop = "\u230C";
    var Dscr = "\u{1D49F}";
    var dscr = "\u{1D4B9}";
    var DScy = "\u0405";
    var dscy = "\u0455";
    var dsol = "\u29F6";
    var Dstrok = "\u0110";
    var dstrok = "\u0111";
    var dtdot = "\u22F1";
    var dtri = "\u25BF";
    var dtrif = "\u25BE";
    var duarr = "\u21F5";
    var duhar = "\u296F";
    var dwangle = "\u29A6";
    var DZcy = "\u040F";
    var dzcy = "\u045F";
    var dzigrarr = "\u27FF";
    var Eacute = "\xC9";
    var eacute = "\xE9";
    var easter = "\u2A6E";
    var Ecaron = "\u011A";
    var ecaron = "\u011B";
    var Ecirc = "\xCA";
    var ecirc = "\xEA";
    var ecir = "\u2256";
    var ecolon = "\u2255";
    var Ecy = "\u042D";
    var ecy = "\u044D";
    var eDDot = "\u2A77";
    var Edot = "\u0116";
    var edot = "\u0117";
    var eDot = "\u2251";
    var ee = "\u2147";
    var efDot = "\u2252";
    var Efr = "\u{1D508}";
    var efr = "\u{1D522}";
    var eg = "\u2A9A";
    var Egrave = "\xC8";
    var egrave = "\xE8";
    var egs = "\u2A96";
    var egsdot = "\u2A98";
    var el = "\u2A99";
    var Element = "\u2208";
    var elinters = "\u23E7";
    var ell = "\u2113";
    var els = "\u2A95";
    var elsdot = "\u2A97";
    var Emacr = "\u0112";
    var emacr = "\u0113";
    var empty = "\u2205";
    var emptyset = "\u2205";
    var EmptySmallSquare = "\u25FB";
    var emptyv = "\u2205";
    var EmptyVerySmallSquare = "\u25AB";
    var emsp13 = "\u2004";
    var emsp14 = "\u2005";
    var emsp = "\u2003";
    var ENG = "\u014A";
    var eng = "\u014B";
    var ensp = "\u2002";
    var Eogon = "\u0118";
    var eogon = "\u0119";
    var Eopf = "\u{1D53C}";
    var eopf = "\u{1D556}";
    var epar = "\u22D5";
    var eparsl = "\u29E3";
    var eplus = "\u2A71";
    var epsi = "\u03B5";
    var Epsilon = "\u0395";
    var epsilon = "\u03B5";
    var epsiv = "\u03F5";
    var eqcirc = "\u2256";
    var eqcolon = "\u2255";
    var eqsim = "\u2242";
    var eqslantgtr = "\u2A96";
    var eqslantless = "\u2A95";
    var Equal = "\u2A75";
    var equals = "=";
    var EqualTilde = "\u2242";
    var equest = "\u225F";
    var Equilibrium = "\u21CC";
    var equiv = "\u2261";
    var equivDD = "\u2A78";
    var eqvparsl = "\u29E5";
    var erarr = "\u2971";
    var erDot = "\u2253";
    var escr = "\u212F";
    var Escr = "\u2130";
    var esdot = "\u2250";
    var Esim = "\u2A73";
    var esim = "\u2242";
    var Eta = "\u0397";
    var eta = "\u03B7";
    var ETH = "\xD0";
    var eth = "\xF0";
    var Euml = "\xCB";
    var euml = "\xEB";
    var euro = "\u20AC";
    var excl = "!";
    var exist = "\u2203";
    var Exists = "\u2203";
    var expectation = "\u2130";
    var exponentiale = "\u2147";
    var ExponentialE = "\u2147";
    var fallingdotseq = "\u2252";
    var Fcy = "\u0424";
    var fcy = "\u0444";
    var female = "\u2640";
    var ffilig = "\uFB03";
    var fflig = "\uFB00";
    var ffllig = "\uFB04";
    var Ffr = "\u{1D509}";
    var ffr = "\u{1D523}";
    var filig = "\uFB01";
    var FilledSmallSquare = "\u25FC";
    var FilledVerySmallSquare = "\u25AA";
    var fjlig = "fj";
    var flat = "\u266D";
    var fllig = "\uFB02";
    var fltns = "\u25B1";
    var fnof = "\u0192";
    var Fopf = "\u{1D53D}";
    var fopf = "\u{1D557}";
    var forall = "\u2200";
    var ForAll = "\u2200";
    var fork = "\u22D4";
    var forkv = "\u2AD9";
    var Fouriertrf = "\u2131";
    var fpartint = "\u2A0D";
    var frac12 = "\xBD";
    var frac13 = "\u2153";
    var frac14 = "\xBC";
    var frac15 = "\u2155";
    var frac16 = "\u2159";
    var frac18 = "\u215B";
    var frac23 = "\u2154";
    var frac25 = "\u2156";
    var frac34 = "\xBE";
    var frac35 = "\u2157";
    var frac38 = "\u215C";
    var frac45 = "\u2158";
    var frac56 = "\u215A";
    var frac58 = "\u215D";
    var frac78 = "\u215E";
    var frasl = "\u2044";
    var frown = "\u2322";
    var fscr = "\u{1D4BB}";
    var Fscr = "\u2131";
    var gacute = "\u01F5";
    var Gamma = "\u0393";
    var gamma = "\u03B3";
    var Gammad = "\u03DC";
    var gammad = "\u03DD";
    var gap = "\u2A86";
    var Gbreve = "\u011E";
    var gbreve = "\u011F";
    var Gcedil = "\u0122";
    var Gcirc = "\u011C";
    var gcirc = "\u011D";
    var Gcy = "\u0413";
    var gcy = "\u0433";
    var Gdot = "\u0120";
    var gdot = "\u0121";
    var ge = "\u2265";
    var gE = "\u2267";
    var gEl = "\u2A8C";
    var gel = "\u22DB";
    var geq = "\u2265";
    var geqq = "\u2267";
    var geqslant = "\u2A7E";
    var gescc = "\u2AA9";
    var ges = "\u2A7E";
    var gesdot = "\u2A80";
    var gesdoto = "\u2A82";
    var gesdotol = "\u2A84";
    var gesl = "\u22DB\uFE00";
    var gesles = "\u2A94";
    var Gfr = "\u{1D50A}";
    var gfr = "\u{1D524}";
    var gg = "\u226B";
    var Gg = "\u22D9";
    var ggg = "\u22D9";
    var gimel = "\u2137";
    var GJcy = "\u0403";
    var gjcy = "\u0453";
    var gla = "\u2AA5";
    var gl = "\u2277";
    var glE = "\u2A92";
    var glj = "\u2AA4";
    var gnap = "\u2A8A";
    var gnapprox = "\u2A8A";
    var gne = "\u2A88";
    var gnE = "\u2269";
    var gneq = "\u2A88";
    var gneqq = "\u2269";
    var gnsim = "\u22E7";
    var Gopf = "\u{1D53E}";
    var gopf = "\u{1D558}";
    var grave = "`";
    var GreaterEqual = "\u2265";
    var GreaterEqualLess = "\u22DB";
    var GreaterFullEqual = "\u2267";
    var GreaterGreater = "\u2AA2";
    var GreaterLess = "\u2277";
    var GreaterSlantEqual = "\u2A7E";
    var GreaterTilde = "\u2273";
    var Gscr = "\u{1D4A2}";
    var gscr = "\u210A";
    var gsim = "\u2273";
    var gsime = "\u2A8E";
    var gsiml = "\u2A90";
    var gtcc = "\u2AA7";
    var gtcir = "\u2A7A";
    var gt = ">";
    var GT = ">";
    var Gt = "\u226B";
    var gtdot = "\u22D7";
    var gtlPar = "\u2995";
    var gtquest = "\u2A7C";
    var gtrapprox = "\u2A86";
    var gtrarr = "\u2978";
    var gtrdot = "\u22D7";
    var gtreqless = "\u22DB";
    var gtreqqless = "\u2A8C";
    var gtrless = "\u2277";
    var gtrsim = "\u2273";
    var gvertneqq = "\u2269\uFE00";
    var gvnE = "\u2269\uFE00";
    var Hacek = "\u02C7";
    var hairsp = "\u200A";
    var half = "\xBD";
    var hamilt = "\u210B";
    var HARDcy = "\u042A";
    var hardcy = "\u044A";
    var harrcir = "\u2948";
    var harr = "\u2194";
    var hArr = "\u21D4";
    var harrw = "\u21AD";
    var Hat = "^";
    var hbar = "\u210F";
    var Hcirc = "\u0124";
    var hcirc = "\u0125";
    var hearts = "\u2665";
    var heartsuit = "\u2665";
    var hellip = "\u2026";
    var hercon = "\u22B9";
    var hfr = "\u{1D525}";
    var Hfr = "\u210C";
    var HilbertSpace = "\u210B";
    var hksearow = "\u2925";
    var hkswarow = "\u2926";
    var hoarr = "\u21FF";
    var homtht = "\u223B";
    var hookleftarrow = "\u21A9";
    var hookrightarrow = "\u21AA";
    var hopf = "\u{1D559}";
    var Hopf = "\u210D";
    var horbar = "\u2015";
    var HorizontalLine = "\u2500";
    var hscr = "\u{1D4BD}";
    var Hscr = "\u210B";
    var hslash = "\u210F";
    var Hstrok = "\u0126";
    var hstrok = "\u0127";
    var HumpDownHump = "\u224E";
    var HumpEqual = "\u224F";
    var hybull = "\u2043";
    var hyphen = "\u2010";
    var Iacute = "\xCD";
    var iacute = "\xED";
    var ic = "\u2063";
    var Icirc = "\xCE";
    var icirc = "\xEE";
    var Icy = "\u0418";
    var icy = "\u0438";
    var Idot = "\u0130";
    var IEcy = "\u0415";
    var iecy = "\u0435";
    var iexcl = "\xA1";
    var iff = "\u21D4";
    var ifr = "\u{1D526}";
    var Ifr = "\u2111";
    var Igrave = "\xCC";
    var igrave = "\xEC";
    var ii = "\u2148";
    var iiiint = "\u2A0C";
    var iiint = "\u222D";
    var iinfin = "\u29DC";
    var iiota = "\u2129";
    var IJlig = "\u0132";
    var ijlig = "\u0133";
    var Imacr = "\u012A";
    var imacr = "\u012B";
    var image$1 = "\u2111";
    var ImaginaryI = "\u2148";
    var imagline = "\u2110";
    var imagpart = "\u2111";
    var imath = "\u0131";
    var Im = "\u2111";
    var imof = "\u22B7";
    var imped = "\u01B5";
    var Implies = "\u21D2";
    var incare = "\u2105";
    var infin = "\u221E";
    var infintie = "\u29DD";
    var inodot = "\u0131";
    var intcal = "\u22BA";
    var int = "\u222B";
    var Int = "\u222C";
    var integers = "\u2124";
    var Integral = "\u222B";
    var intercal = "\u22BA";
    var Intersection = "\u22C2";
    var intlarhk = "\u2A17";
    var intprod = "\u2A3C";
    var InvisibleComma = "\u2063";
    var InvisibleTimes = "\u2062";
    var IOcy = "\u0401";
    var iocy = "\u0451";
    var Iogon = "\u012E";
    var iogon = "\u012F";
    var Iopf = "\u{1D540}";
    var iopf = "\u{1D55A}";
    var Iota = "\u0399";
    var iota = "\u03B9";
    var iprod = "\u2A3C";
    var iquest = "\xBF";
    var iscr = "\u{1D4BE}";
    var Iscr = "\u2110";
    var isin = "\u2208";
    var isindot = "\u22F5";
    var isinE = "\u22F9";
    var isins = "\u22F4";
    var isinsv = "\u22F3";
    var isinv = "\u2208";
    var it = "\u2062";
    var Itilde = "\u0128";
    var itilde = "\u0129";
    var Iukcy = "\u0406";
    var iukcy = "\u0456";
    var Iuml = "\xCF";
    var iuml = "\xEF";
    var Jcirc = "\u0134";
    var jcirc = "\u0135";
    var Jcy = "\u0419";
    var jcy = "\u0439";
    var Jfr = "\u{1D50D}";
    var jfr = "\u{1D527}";
    var jmath = "\u0237";
    var Jopf = "\u{1D541}";
    var jopf = "\u{1D55B}";
    var Jscr = "\u{1D4A5}";
    var jscr = "\u{1D4BF}";
    var Jsercy = "\u0408";
    var jsercy = "\u0458";
    var Jukcy = "\u0404";
    var jukcy = "\u0454";
    var Kappa = "\u039A";
    var kappa = "\u03BA";
    var kappav = "\u03F0";
    var Kcedil = "\u0136";
    var kcedil = "\u0137";
    var Kcy = "\u041A";
    var kcy = "\u043A";
    var Kfr = "\u{1D50E}";
    var kfr = "\u{1D528}";
    var kgreen = "\u0138";
    var KHcy = "\u0425";
    var khcy = "\u0445";
    var KJcy = "\u040C";
    var kjcy = "\u045C";
    var Kopf = "\u{1D542}";
    var kopf = "\u{1D55C}";
    var Kscr = "\u{1D4A6}";
    var kscr = "\u{1D4C0}";
    var lAarr = "\u21DA";
    var Lacute = "\u0139";
    var lacute = "\u013A";
    var laemptyv = "\u29B4";
    var lagran = "\u2112";
    var Lambda = "\u039B";
    var lambda = "\u03BB";
    var lang = "\u27E8";
    var Lang = "\u27EA";
    var langd = "\u2991";
    var langle = "\u27E8";
    var lap = "\u2A85";
    var Laplacetrf = "\u2112";
    var laquo = "\xAB";
    var larrb = "\u21E4";
    var larrbfs = "\u291F";
    var larr = "\u2190";
    var Larr = "\u219E";
    var lArr = "\u21D0";
    var larrfs = "\u291D";
    var larrhk = "\u21A9";
    var larrlp = "\u21AB";
    var larrpl = "\u2939";
    var larrsim = "\u2973";
    var larrtl = "\u21A2";
    var latail = "\u2919";
    var lAtail = "\u291B";
    var lat = "\u2AAB";
    var late = "\u2AAD";
    var lates = "\u2AAD\uFE00";
    var lbarr = "\u290C";
    var lBarr = "\u290E";
    var lbbrk = "\u2772";
    var lbrace = "{";
    var lbrack = "[";
    var lbrke = "\u298B";
    var lbrksld = "\u298F";
    var lbrkslu = "\u298D";
    var Lcaron = "\u013D";
    var lcaron = "\u013E";
    var Lcedil = "\u013B";
    var lcedil = "\u013C";
    var lceil = "\u2308";
    var lcub = "{";
    var Lcy = "\u041B";
    var lcy = "\u043B";
    var ldca = "\u2936";
    var ldquo = "\u201C";
    var ldquor = "\u201E";
    var ldrdhar = "\u2967";
    var ldrushar = "\u294B";
    var ldsh = "\u21B2";
    var le = "\u2264";
    var lE = "\u2266";
    var LeftAngleBracket = "\u27E8";
    var LeftArrowBar = "\u21E4";
    var leftarrow = "\u2190";
    var LeftArrow = "\u2190";
    var Leftarrow = "\u21D0";
    var LeftArrowRightArrow = "\u21C6";
    var leftarrowtail = "\u21A2";
    var LeftCeiling = "\u2308";
    var LeftDoubleBracket = "\u27E6";
    var LeftDownTeeVector = "\u2961";
    var LeftDownVectorBar = "\u2959";
    var LeftDownVector = "\u21C3";
    var LeftFloor = "\u230A";
    var leftharpoondown = "\u21BD";
    var leftharpoonup = "\u21BC";
    var leftleftarrows = "\u21C7";
    var leftrightarrow = "\u2194";
    var LeftRightArrow = "\u2194";
    var Leftrightarrow = "\u21D4";
    var leftrightarrows = "\u21C6";
    var leftrightharpoons = "\u21CB";
    var leftrightsquigarrow = "\u21AD";
    var LeftRightVector = "\u294E";
    var LeftTeeArrow = "\u21A4";
    var LeftTee = "\u22A3";
    var LeftTeeVector = "\u295A";
    var leftthreetimes = "\u22CB";
    var LeftTriangleBar = "\u29CF";
    var LeftTriangle = "\u22B2";
    var LeftTriangleEqual = "\u22B4";
    var LeftUpDownVector = "\u2951";
    var LeftUpTeeVector = "\u2960";
    var LeftUpVectorBar = "\u2958";
    var LeftUpVector = "\u21BF";
    var LeftVectorBar = "\u2952";
    var LeftVector = "\u21BC";
    var lEg = "\u2A8B";
    var leg = "\u22DA";
    var leq = "\u2264";
    var leqq = "\u2266";
    var leqslant = "\u2A7D";
    var lescc = "\u2AA8";
    var les = "\u2A7D";
    var lesdot = "\u2A7F";
    var lesdoto = "\u2A81";
    var lesdotor = "\u2A83";
    var lesg = "\u22DA\uFE00";
    var lesges = "\u2A93";
    var lessapprox = "\u2A85";
    var lessdot = "\u22D6";
    var lesseqgtr = "\u22DA";
    var lesseqqgtr = "\u2A8B";
    var LessEqualGreater = "\u22DA";
    var LessFullEqual = "\u2266";
    var LessGreater = "\u2276";
    var lessgtr = "\u2276";
    var LessLess = "\u2AA1";
    var lesssim = "\u2272";
    var LessSlantEqual = "\u2A7D";
    var LessTilde = "\u2272";
    var lfisht = "\u297C";
    var lfloor = "\u230A";
    var Lfr = "\u{1D50F}";
    var lfr = "\u{1D529}";
    var lg = "\u2276";
    var lgE = "\u2A91";
    var lHar = "\u2962";
    var lhard = "\u21BD";
    var lharu = "\u21BC";
    var lharul = "\u296A";
    var lhblk = "\u2584";
    var LJcy = "\u0409";
    var ljcy = "\u0459";
    var llarr = "\u21C7";
    var ll = "\u226A";
    var Ll = "\u22D8";
    var llcorner = "\u231E";
    var Lleftarrow = "\u21DA";
    var llhard = "\u296B";
    var lltri = "\u25FA";
    var Lmidot = "\u013F";
    var lmidot = "\u0140";
    var lmoustache = "\u23B0";
    var lmoust = "\u23B0";
    var lnap = "\u2A89";
    var lnapprox = "\u2A89";
    var lne = "\u2A87";
    var lnE = "\u2268";
    var lneq = "\u2A87";
    var lneqq = "\u2268";
    var lnsim = "\u22E6";
    var loang = "\u27EC";
    var loarr = "\u21FD";
    var lobrk = "\u27E6";
    var longleftarrow = "\u27F5";
    var LongLeftArrow = "\u27F5";
    var Longleftarrow = "\u27F8";
    var longleftrightarrow = "\u27F7";
    var LongLeftRightArrow = "\u27F7";
    var Longleftrightarrow = "\u27FA";
    var longmapsto = "\u27FC";
    var longrightarrow = "\u27F6";
    var LongRightArrow = "\u27F6";
    var Longrightarrow = "\u27F9";
    var looparrowleft = "\u21AB";
    var looparrowright = "\u21AC";
    var lopar = "\u2985";
    var Lopf = "\u{1D543}";
    var lopf = "\u{1D55D}";
    var loplus = "\u2A2D";
    var lotimes = "\u2A34";
    var lowast = "\u2217";
    var lowbar = "_";
    var LowerLeftArrow = "\u2199";
    var LowerRightArrow = "\u2198";
    var loz = "\u25CA";
    var lozenge = "\u25CA";
    var lozf = "\u29EB";
    var lpar = "(";
    var lparlt = "\u2993";
    var lrarr = "\u21C6";
    var lrcorner = "\u231F";
    var lrhar = "\u21CB";
    var lrhard = "\u296D";
    var lrm = "\u200E";
    var lrtri = "\u22BF";
    var lsaquo = "\u2039";
    var lscr = "\u{1D4C1}";
    var Lscr = "\u2112";
    var lsh = "\u21B0";
    var Lsh = "\u21B0";
    var lsim = "\u2272";
    var lsime = "\u2A8D";
    var lsimg = "\u2A8F";
    var lsqb = "[";
    var lsquo = "\u2018";
    var lsquor = "\u201A";
    var Lstrok = "\u0141";
    var lstrok = "\u0142";
    var ltcc = "\u2AA6";
    var ltcir = "\u2A79";
    var lt = "<";
    var LT = "<";
    var Lt = "\u226A";
    var ltdot = "\u22D6";
    var lthree = "\u22CB";
    var ltimes = "\u22C9";
    var ltlarr = "\u2976";
    var ltquest = "\u2A7B";
    var ltri = "\u25C3";
    var ltrie = "\u22B4";
    var ltrif = "\u25C2";
    var ltrPar = "\u2996";
    var lurdshar = "\u294A";
    var luruhar = "\u2966";
    var lvertneqq = "\u2268\uFE00";
    var lvnE = "\u2268\uFE00";
    var macr = "\xAF";
    var male = "\u2642";
    var malt = "\u2720";
    var maltese = "\u2720";
    var map = "\u21A6";
    var mapsto = "\u21A6";
    var mapstodown = "\u21A7";
    var mapstoleft = "\u21A4";
    var mapstoup = "\u21A5";
    var marker = "\u25AE";
    var mcomma = "\u2A29";
    var Mcy = "\u041C";
    var mcy = "\u043C";
    var mdash = "\u2014";
    var mDDot = "\u223A";
    var measuredangle = "\u2221";
    var MediumSpace = "\u205F";
    var Mellintrf = "\u2133";
    var Mfr = "\u{1D510}";
    var mfr = "\u{1D52A}";
    var mho = "\u2127";
    var micro = "\xB5";
    var midast = "*";
    var midcir = "\u2AF0";
    var mid = "\u2223";
    var middot = "\xB7";
    var minusb = "\u229F";
    var minus = "\u2212";
    var minusd = "\u2238";
    var minusdu = "\u2A2A";
    var MinusPlus = "\u2213";
    var mlcp = "\u2ADB";
    var mldr = "\u2026";
    var mnplus = "\u2213";
    var models = "\u22A7";
    var Mopf = "\u{1D544}";
    var mopf = "\u{1D55E}";
    var mp = "\u2213";
    var mscr = "\u{1D4C2}";
    var Mscr = "\u2133";
    var mstpos = "\u223E";
    var Mu = "\u039C";
    var mu = "\u03BC";
    var multimap = "\u22B8";
    var mumap = "\u22B8";
    var nabla = "\u2207";
    var Nacute = "\u0143";
    var nacute = "\u0144";
    var nang = "\u2220\u20D2";
    var nap = "\u2249";
    var napE = "\u2A70\u0338";
    var napid = "\u224B\u0338";
    var napos = "\u0149";
    var napprox = "\u2249";
    var natural = "\u266E";
    var naturals = "\u2115";
    var natur = "\u266E";
    var nbsp = "\xA0";
    var nbump = "\u224E\u0338";
    var nbumpe = "\u224F\u0338";
    var ncap = "\u2A43";
    var Ncaron = "\u0147";
    var ncaron = "\u0148";
    var Ncedil = "\u0145";
    var ncedil = "\u0146";
    var ncong = "\u2247";
    var ncongdot = "\u2A6D\u0338";
    var ncup = "\u2A42";
    var Ncy = "\u041D";
    var ncy = "\u043D";
    var ndash = "\u2013";
    var nearhk = "\u2924";
    var nearr = "\u2197";
    var neArr = "\u21D7";
    var nearrow = "\u2197";
    var ne = "\u2260";
    var nedot = "\u2250\u0338";
    var NegativeMediumSpace = "\u200B";
    var NegativeThickSpace = "\u200B";
    var NegativeThinSpace = "\u200B";
    var NegativeVeryThinSpace = "\u200B";
    var nequiv = "\u2262";
    var nesear = "\u2928";
    var nesim = "\u2242\u0338";
    var NestedGreaterGreater = "\u226B";
    var NestedLessLess = "\u226A";
    var NewLine = "\n";
    var nexist = "\u2204";
    var nexists = "\u2204";
    var Nfr = "\u{1D511}";
    var nfr = "\u{1D52B}";
    var ngE = "\u2267\u0338";
    var nge = "\u2271";
    var ngeq = "\u2271";
    var ngeqq = "\u2267\u0338";
    var ngeqslant = "\u2A7E\u0338";
    var nges = "\u2A7E\u0338";
    var nGg = "\u22D9\u0338";
    var ngsim = "\u2275";
    var nGt = "\u226B\u20D2";
    var ngt = "\u226F";
    var ngtr = "\u226F";
    var nGtv = "\u226B\u0338";
    var nharr = "\u21AE";
    var nhArr = "\u21CE";
    var nhpar = "\u2AF2";
    var ni = "\u220B";
    var nis = "\u22FC";
    var nisd = "\u22FA";
    var niv = "\u220B";
    var NJcy = "\u040A";
    var njcy = "\u045A";
    var nlarr = "\u219A";
    var nlArr = "\u21CD";
    var nldr = "\u2025";
    var nlE = "\u2266\u0338";
    var nle = "\u2270";
    var nleftarrow = "\u219A";
    var nLeftarrow = "\u21CD";
    var nleftrightarrow = "\u21AE";
    var nLeftrightarrow = "\u21CE";
    var nleq = "\u2270";
    var nleqq = "\u2266\u0338";
    var nleqslant = "\u2A7D\u0338";
    var nles = "\u2A7D\u0338";
    var nless = "\u226E";
    var nLl = "\u22D8\u0338";
    var nlsim = "\u2274";
    var nLt = "\u226A\u20D2";
    var nlt = "\u226E";
    var nltri = "\u22EA";
    var nltrie = "\u22EC";
    var nLtv = "\u226A\u0338";
    var nmid = "\u2224";
    var NoBreak = "\u2060";
    var NonBreakingSpace = "\xA0";
    var nopf = "\u{1D55F}";
    var Nopf = "\u2115";
    var Not = "\u2AEC";
    var not = "\xAC";
    var NotCongruent = "\u2262";
    var NotCupCap = "\u226D";
    var NotDoubleVerticalBar = "\u2226";
    var NotElement = "\u2209";
    var NotEqual = "\u2260";
    var NotEqualTilde = "\u2242\u0338";
    var NotExists = "\u2204";
    var NotGreater = "\u226F";
    var NotGreaterEqual = "\u2271";
    var NotGreaterFullEqual = "\u2267\u0338";
    var NotGreaterGreater = "\u226B\u0338";
    var NotGreaterLess = "\u2279";
    var NotGreaterSlantEqual = "\u2A7E\u0338";
    var NotGreaterTilde = "\u2275";
    var NotHumpDownHump = "\u224E\u0338";
    var NotHumpEqual = "\u224F\u0338";
    var notin = "\u2209";
    var notindot = "\u22F5\u0338";
    var notinE = "\u22F9\u0338";
    var notinva = "\u2209";
    var notinvb = "\u22F7";
    var notinvc = "\u22F6";
    var NotLeftTriangleBar = "\u29CF\u0338";
    var NotLeftTriangle = "\u22EA";
    var NotLeftTriangleEqual = "\u22EC";
    var NotLess = "\u226E";
    var NotLessEqual = "\u2270";
    var NotLessGreater = "\u2278";
    var NotLessLess = "\u226A\u0338";
    var NotLessSlantEqual = "\u2A7D\u0338";
    var NotLessTilde = "\u2274";
    var NotNestedGreaterGreater = "\u2AA2\u0338";
    var NotNestedLessLess = "\u2AA1\u0338";
    var notni = "\u220C";
    var notniva = "\u220C";
    var notnivb = "\u22FE";
    var notnivc = "\u22FD";
    var NotPrecedes = "\u2280";
    var NotPrecedesEqual = "\u2AAF\u0338";
    var NotPrecedesSlantEqual = "\u22E0";
    var NotReverseElement = "\u220C";
    var NotRightTriangleBar = "\u29D0\u0338";
    var NotRightTriangle = "\u22EB";
    var NotRightTriangleEqual = "\u22ED";
    var NotSquareSubset = "\u228F\u0338";
    var NotSquareSubsetEqual = "\u22E2";
    var NotSquareSuperset = "\u2290\u0338";
    var NotSquareSupersetEqual = "\u22E3";
    var NotSubset = "\u2282\u20D2";
    var NotSubsetEqual = "\u2288";
    var NotSucceeds = "\u2281";
    var NotSucceedsEqual = "\u2AB0\u0338";
    var NotSucceedsSlantEqual = "\u22E1";
    var NotSucceedsTilde = "\u227F\u0338";
    var NotSuperset = "\u2283\u20D2";
    var NotSupersetEqual = "\u2289";
    var NotTilde = "\u2241";
    var NotTildeEqual = "\u2244";
    var NotTildeFullEqual = "\u2247";
    var NotTildeTilde = "\u2249";
    var NotVerticalBar = "\u2224";
    var nparallel = "\u2226";
    var npar = "\u2226";
    var nparsl = "\u2AFD\u20E5";
    var npart = "\u2202\u0338";
    var npolint = "\u2A14";
    var npr = "\u2280";
    var nprcue = "\u22E0";
    var nprec = "\u2280";
    var npreceq = "\u2AAF\u0338";
    var npre = "\u2AAF\u0338";
    var nrarrc = "\u2933\u0338";
    var nrarr = "\u219B";
    var nrArr = "\u21CF";
    var nrarrw = "\u219D\u0338";
    var nrightarrow = "\u219B";
    var nRightarrow = "\u21CF";
    var nrtri = "\u22EB";
    var nrtrie = "\u22ED";
    var nsc = "\u2281";
    var nsccue = "\u22E1";
    var nsce = "\u2AB0\u0338";
    var Nscr = "\u{1D4A9}";
    var nscr = "\u{1D4C3}";
    var nshortmid = "\u2224";
    var nshortparallel = "\u2226";
    var nsim = "\u2241";
    var nsime = "\u2244";
    var nsimeq = "\u2244";
    var nsmid = "\u2224";
    var nspar = "\u2226";
    var nsqsube = "\u22E2";
    var nsqsupe = "\u22E3";
    var nsub = "\u2284";
    var nsubE = "\u2AC5\u0338";
    var nsube = "\u2288";
    var nsubset = "\u2282\u20D2";
    var nsubseteq = "\u2288";
    var nsubseteqq = "\u2AC5\u0338";
    var nsucc = "\u2281";
    var nsucceq = "\u2AB0\u0338";
    var nsup = "\u2285";
    var nsupE = "\u2AC6\u0338";
    var nsupe = "\u2289";
    var nsupset = "\u2283\u20D2";
    var nsupseteq = "\u2289";
    var nsupseteqq = "\u2AC6\u0338";
    var ntgl = "\u2279";
    var Ntilde = "\xD1";
    var ntilde = "\xF1";
    var ntlg = "\u2278";
    var ntriangleleft = "\u22EA";
    var ntrianglelefteq = "\u22EC";
    var ntriangleright = "\u22EB";
    var ntrianglerighteq = "\u22ED";
    var Nu = "\u039D";
    var nu = "\u03BD";
    var num = "#";
    var numero = "\u2116";
    var numsp = "\u2007";
    var nvap = "\u224D\u20D2";
    var nvdash = "\u22AC";
    var nvDash = "\u22AD";
    var nVdash = "\u22AE";
    var nVDash = "\u22AF";
    var nvge = "\u2265\u20D2";
    var nvgt = ">\u20D2";
    var nvHarr = "\u2904";
    var nvinfin = "\u29DE";
    var nvlArr = "\u2902";
    var nvle = "\u2264\u20D2";
    var nvlt = "<\u20D2";
    var nvltrie = "\u22B4\u20D2";
    var nvrArr = "\u2903";
    var nvrtrie = "\u22B5\u20D2";
    var nvsim = "\u223C\u20D2";
    var nwarhk = "\u2923";
    var nwarr = "\u2196";
    var nwArr = "\u21D6";
    var nwarrow = "\u2196";
    var nwnear = "\u2927";
    var Oacute = "\xD3";
    var oacute = "\xF3";
    var oast = "\u229B";
    var Ocirc = "\xD4";
    var ocirc = "\xF4";
    var ocir = "\u229A";
    var Ocy = "\u041E";
    var ocy = "\u043E";
    var odash = "\u229D";
    var Odblac = "\u0150";
    var odblac = "\u0151";
    var odiv = "\u2A38";
    var odot = "\u2299";
    var odsold = "\u29BC";
    var OElig = "\u0152";
    var oelig = "\u0153";
    var ofcir = "\u29BF";
    var Ofr = "\u{1D512}";
    var ofr = "\u{1D52C}";
    var ogon = "\u02DB";
    var Ograve = "\xD2";
    var ograve = "\xF2";
    var ogt = "\u29C1";
    var ohbar = "\u29B5";
    var ohm = "\u03A9";
    var oint = "\u222E";
    var olarr = "\u21BA";
    var olcir = "\u29BE";
    var olcross = "\u29BB";
    var oline = "\u203E";
    var olt = "\u29C0";
    var Omacr = "\u014C";
    var omacr = "\u014D";
    var Omega = "\u03A9";
    var omega = "\u03C9";
    var Omicron = "\u039F";
    var omicron = "\u03BF";
    var omid = "\u29B6";
    var ominus = "\u2296";
    var Oopf = "\u{1D546}";
    var oopf = "\u{1D560}";
    var opar = "\u29B7";
    var OpenCurlyDoubleQuote = "\u201C";
    var OpenCurlyQuote = "\u2018";
    var operp = "\u29B9";
    var oplus = "\u2295";
    var orarr = "\u21BB";
    var Or = "\u2A54";
    var or = "\u2228";
    var ord = "\u2A5D";
    var order = "\u2134";
    var orderof = "\u2134";
    var ordf = "\xAA";
    var ordm = "\xBA";
    var origof = "\u22B6";
    var oror = "\u2A56";
    var orslope = "\u2A57";
    var orv = "\u2A5B";
    var oS = "\u24C8";
    var Oscr = "\u{1D4AA}";
    var oscr = "\u2134";
    var Oslash = "\xD8";
    var oslash = "\xF8";
    var osol = "\u2298";
    var Otilde = "\xD5";
    var otilde = "\xF5";
    var otimesas = "\u2A36";
    var Otimes = "\u2A37";
    var otimes = "\u2297";
    var Ouml = "\xD6";
    var ouml = "\xF6";
    var ovbar = "\u233D";
    var OverBar = "\u203E";
    var OverBrace = "\u23DE";
    var OverBracket = "\u23B4";
    var OverParenthesis = "\u23DC";
    var para = "\xB6";
    var parallel = "\u2225";
    var par = "\u2225";
    var parsim = "\u2AF3";
    var parsl = "\u2AFD";
    var part = "\u2202";
    var PartialD = "\u2202";
    var Pcy = "\u041F";
    var pcy = "\u043F";
    var percnt = "%";
    var period = ".";
    var permil = "\u2030";
    var perp = "\u22A5";
    var pertenk = "\u2031";
    var Pfr = "\u{1D513}";
    var pfr = "\u{1D52D}";
    var Phi = "\u03A6";
    var phi = "\u03C6";
    var phiv = "\u03D5";
    var phmmat = "\u2133";
    var phone = "\u260E";
    var Pi = "\u03A0";
    var pi = "\u03C0";
    var pitchfork = "\u22D4";
    var piv = "\u03D6";
    var planck = "\u210F";
    var planckh = "\u210E";
    var plankv = "\u210F";
    var plusacir = "\u2A23";
    var plusb = "\u229E";
    var pluscir = "\u2A22";
    var plus = "+";
    var plusdo = "\u2214";
    var plusdu = "\u2A25";
    var pluse = "\u2A72";
    var PlusMinus = "\xB1";
    var plusmn = "\xB1";
    var plussim = "\u2A26";
    var plustwo = "\u2A27";
    var pm = "\xB1";
    var Poincareplane = "\u210C";
    var pointint = "\u2A15";
    var popf = "\u{1D561}";
    var Popf = "\u2119";
    var pound = "\xA3";
    var prap = "\u2AB7";
    var Pr = "\u2ABB";
    var pr = "\u227A";
    var prcue = "\u227C";
    var precapprox = "\u2AB7";
    var prec = "\u227A";
    var preccurlyeq = "\u227C";
    var Precedes = "\u227A";
    var PrecedesEqual = "\u2AAF";
    var PrecedesSlantEqual = "\u227C";
    var PrecedesTilde = "\u227E";
    var preceq = "\u2AAF";
    var precnapprox = "\u2AB9";
    var precneqq = "\u2AB5";
    var precnsim = "\u22E8";
    var pre = "\u2AAF";
    var prE = "\u2AB3";
    var precsim = "\u227E";
    var prime = "\u2032";
    var Prime = "\u2033";
    var primes = "\u2119";
    var prnap = "\u2AB9";
    var prnE = "\u2AB5";
    var prnsim = "\u22E8";
    var prod = "\u220F";
    var Product = "\u220F";
    var profalar = "\u232E";
    var profline = "\u2312";
    var profsurf = "\u2313";
    var prop = "\u221D";
    var Proportional = "\u221D";
    var Proportion = "\u2237";
    var propto = "\u221D";
    var prsim = "\u227E";
    var prurel = "\u22B0";
    var Pscr = "\u{1D4AB}";
    var pscr = "\u{1D4C5}";
    var Psi = "\u03A8";
    var psi = "\u03C8";
    var puncsp = "\u2008";
    var Qfr = "\u{1D514}";
    var qfr = "\u{1D52E}";
    var qint = "\u2A0C";
    var qopf = "\u{1D562}";
    var Qopf = "\u211A";
    var qprime = "\u2057";
    var Qscr = "\u{1D4AC}";
    var qscr = "\u{1D4C6}";
    var quaternions = "\u210D";
    var quatint = "\u2A16";
    var quest = "?";
    var questeq = "\u225F";
    var quot = '"';
    var QUOT = '"';
    var rAarr = "\u21DB";
    var race = "\u223D\u0331";
    var Racute = "\u0154";
    var racute = "\u0155";
    var radic = "\u221A";
    var raemptyv = "\u29B3";
    var rang = "\u27E9";
    var Rang = "\u27EB";
    var rangd = "\u2992";
    var range = "\u29A5";
    var rangle = "\u27E9";
    var raquo = "\xBB";
    var rarrap = "\u2975";
    var rarrb = "\u21E5";
    var rarrbfs = "\u2920";
    var rarrc = "\u2933";
    var rarr = "\u2192";
    var Rarr = "\u21A0";
    var rArr = "\u21D2";
    var rarrfs = "\u291E";
    var rarrhk = "\u21AA";
    var rarrlp = "\u21AC";
    var rarrpl = "\u2945";
    var rarrsim = "\u2974";
    var Rarrtl = "\u2916";
    var rarrtl = "\u21A3";
    var rarrw = "\u219D";
    var ratail = "\u291A";
    var rAtail = "\u291C";
    var ratio = "\u2236";
    var rationals = "\u211A";
    var rbarr = "\u290D";
    var rBarr = "\u290F";
    var RBarr = "\u2910";
    var rbbrk = "\u2773";
    var rbrace = "}";
    var rbrack = "]";
    var rbrke = "\u298C";
    var rbrksld = "\u298E";
    var rbrkslu = "\u2990";
    var Rcaron = "\u0158";
    var rcaron = "\u0159";
    var Rcedil = "\u0156";
    var rcedil = "\u0157";
    var rceil = "\u2309";
    var rcub = "}";
    var Rcy = "\u0420";
    var rcy = "\u0440";
    var rdca = "\u2937";
    var rdldhar = "\u2969";
    var rdquo = "\u201D";
    var rdquor = "\u201D";
    var rdsh = "\u21B3";
    var real = "\u211C";
    var realine = "\u211B";
    var realpart = "\u211C";
    var reals = "\u211D";
    var Re = "\u211C";
    var rect = "\u25AD";
    var reg = "\xAE";
    var REG = "\xAE";
    var ReverseElement = "\u220B";
    var ReverseEquilibrium = "\u21CB";
    var ReverseUpEquilibrium = "\u296F";
    var rfisht = "\u297D";
    var rfloor = "\u230B";
    var rfr = "\u{1D52F}";
    var Rfr = "\u211C";
    var rHar = "\u2964";
    var rhard = "\u21C1";
    var rharu = "\u21C0";
    var rharul = "\u296C";
    var Rho = "\u03A1";
    var rho = "\u03C1";
    var rhov = "\u03F1";
    var RightAngleBracket = "\u27E9";
    var RightArrowBar = "\u21E5";
    var rightarrow = "\u2192";
    var RightArrow = "\u2192";
    var Rightarrow = "\u21D2";
    var RightArrowLeftArrow = "\u21C4";
    var rightarrowtail = "\u21A3";
    var RightCeiling = "\u2309";
    var RightDoubleBracket = "\u27E7";
    var RightDownTeeVector = "\u295D";
    var RightDownVectorBar = "\u2955";
    var RightDownVector = "\u21C2";
    var RightFloor = "\u230B";
    var rightharpoondown = "\u21C1";
    var rightharpoonup = "\u21C0";
    var rightleftarrows = "\u21C4";
    var rightleftharpoons = "\u21CC";
    var rightrightarrows = "\u21C9";
    var rightsquigarrow = "\u219D";
    var RightTeeArrow = "\u21A6";
    var RightTee = "\u22A2";
    var RightTeeVector = "\u295B";
    var rightthreetimes = "\u22CC";
    var RightTriangleBar = "\u29D0";
    var RightTriangle = "\u22B3";
    var RightTriangleEqual = "\u22B5";
    var RightUpDownVector = "\u294F";
    var RightUpTeeVector = "\u295C";
    var RightUpVectorBar = "\u2954";
    var RightUpVector = "\u21BE";
    var RightVectorBar = "\u2953";
    var RightVector = "\u21C0";
    var ring = "\u02DA";
    var risingdotseq = "\u2253";
    var rlarr = "\u21C4";
    var rlhar = "\u21CC";
    var rlm = "\u200F";
    var rmoustache = "\u23B1";
    var rmoust = "\u23B1";
    var rnmid = "\u2AEE";
    var roang = "\u27ED";
    var roarr = "\u21FE";
    var robrk = "\u27E7";
    var ropar = "\u2986";
    var ropf = "\u{1D563}";
    var Ropf = "\u211D";
    var roplus = "\u2A2E";
    var rotimes = "\u2A35";
    var RoundImplies = "\u2970";
    var rpar = ")";
    var rpargt = "\u2994";
    var rppolint = "\u2A12";
    var rrarr = "\u21C9";
    var Rrightarrow = "\u21DB";
    var rsaquo = "\u203A";
    var rscr = "\u{1D4C7}";
    var Rscr = "\u211B";
    var rsh = "\u21B1";
    var Rsh = "\u21B1";
    var rsqb = "]";
    var rsquo = "\u2019";
    var rsquor = "\u2019";
    var rthree = "\u22CC";
    var rtimes = "\u22CA";
    var rtri = "\u25B9";
    var rtrie = "\u22B5";
    var rtrif = "\u25B8";
    var rtriltri = "\u29CE";
    var RuleDelayed = "\u29F4";
    var ruluhar = "\u2968";
    var rx = "\u211E";
    var Sacute = "\u015A";
    var sacute = "\u015B";
    var sbquo = "\u201A";
    var scap = "\u2AB8";
    var Scaron = "\u0160";
    var scaron = "\u0161";
    var Sc = "\u2ABC";
    var sc = "\u227B";
    var sccue = "\u227D";
    var sce = "\u2AB0";
    var scE = "\u2AB4";
    var Scedil = "\u015E";
    var scedil = "\u015F";
    var Scirc = "\u015C";
    var scirc = "\u015D";
    var scnap = "\u2ABA";
    var scnE = "\u2AB6";
    var scnsim = "\u22E9";
    var scpolint = "\u2A13";
    var scsim = "\u227F";
    var Scy = "\u0421";
    var scy = "\u0441";
    var sdotb = "\u22A1";
    var sdot = "\u22C5";
    var sdote = "\u2A66";
    var searhk = "\u2925";
    var searr = "\u2198";
    var seArr = "\u21D8";
    var searrow = "\u2198";
    var sect = "\xA7";
    var semi = ";";
    var seswar = "\u2929";
    var setminus = "\u2216";
    var setmn = "\u2216";
    var sext = "\u2736";
    var Sfr = "\u{1D516}";
    var sfr = "\u{1D530}";
    var sfrown = "\u2322";
    var sharp = "\u266F";
    var SHCHcy = "\u0429";
    var shchcy = "\u0449";
    var SHcy = "\u0428";
    var shcy = "\u0448";
    var ShortDownArrow = "\u2193";
    var ShortLeftArrow = "\u2190";
    var shortmid = "\u2223";
    var shortparallel = "\u2225";
    var ShortRightArrow = "\u2192";
    var ShortUpArrow = "\u2191";
    var shy = "\xAD";
    var Sigma = "\u03A3";
    var sigma = "\u03C3";
    var sigmaf = "\u03C2";
    var sigmav = "\u03C2";
    var sim = "\u223C";
    var simdot = "\u2A6A";
    var sime = "\u2243";
    var simeq = "\u2243";
    var simg = "\u2A9E";
    var simgE = "\u2AA0";
    var siml = "\u2A9D";
    var simlE = "\u2A9F";
    var simne = "\u2246";
    var simplus = "\u2A24";
    var simrarr = "\u2972";
    var slarr = "\u2190";
    var SmallCircle = "\u2218";
    var smallsetminus = "\u2216";
    var smashp = "\u2A33";
    var smeparsl = "\u29E4";
    var smid = "\u2223";
    var smile = "\u2323";
    var smt = "\u2AAA";
    var smte = "\u2AAC";
    var smtes = "\u2AAC\uFE00";
    var SOFTcy = "\u042C";
    var softcy = "\u044C";
    var solbar = "\u233F";
    var solb = "\u29C4";
    var sol = "/";
    var Sopf = "\u{1D54A}";
    var sopf = "\u{1D564}";
    var spades = "\u2660";
    var spadesuit = "\u2660";
    var spar = "\u2225";
    var sqcap = "\u2293";
    var sqcaps = "\u2293\uFE00";
    var sqcup = "\u2294";
    var sqcups = "\u2294\uFE00";
    var Sqrt = "\u221A";
    var sqsub = "\u228F";
    var sqsube = "\u2291";
    var sqsubset = "\u228F";
    var sqsubseteq = "\u2291";
    var sqsup = "\u2290";
    var sqsupe = "\u2292";
    var sqsupset = "\u2290";
    var sqsupseteq = "\u2292";
    var square = "\u25A1";
    var Square = "\u25A1";
    var SquareIntersection = "\u2293";
    var SquareSubset = "\u228F";
    var SquareSubsetEqual = "\u2291";
    var SquareSuperset = "\u2290";
    var SquareSupersetEqual = "\u2292";
    var SquareUnion = "\u2294";
    var squarf = "\u25AA";
    var squ = "\u25A1";
    var squf = "\u25AA";
    var srarr = "\u2192";
    var Sscr = "\u{1D4AE}";
    var sscr = "\u{1D4C8}";
    var ssetmn = "\u2216";
    var ssmile = "\u2323";
    var sstarf = "\u22C6";
    var Star = "\u22C6";
    var star = "\u2606";
    var starf = "\u2605";
    var straightepsilon = "\u03F5";
    var straightphi = "\u03D5";
    var strns = "\xAF";
    var sub = "\u2282";
    var Sub = "\u22D0";
    var subdot = "\u2ABD";
    var subE = "\u2AC5";
    var sube = "\u2286";
    var subedot = "\u2AC3";
    var submult = "\u2AC1";
    var subnE = "\u2ACB";
    var subne = "\u228A";
    var subplus = "\u2ABF";
    var subrarr = "\u2979";
    var subset = "\u2282";
    var Subset = "\u22D0";
    var subseteq = "\u2286";
    var subseteqq = "\u2AC5";
    var SubsetEqual = "\u2286";
    var subsetneq = "\u228A";
    var subsetneqq = "\u2ACB";
    var subsim = "\u2AC7";
    var subsub = "\u2AD5";
    var subsup = "\u2AD3";
    var succapprox = "\u2AB8";
    var succ = "\u227B";
    var succcurlyeq = "\u227D";
    var Succeeds = "\u227B";
    var SucceedsEqual = "\u2AB0";
    var SucceedsSlantEqual = "\u227D";
    var SucceedsTilde = "\u227F";
    var succeq = "\u2AB0";
    var succnapprox = "\u2ABA";
    var succneqq = "\u2AB6";
    var succnsim = "\u22E9";
    var succsim = "\u227F";
    var SuchThat = "\u220B";
    var sum = "\u2211";
    var Sum = "\u2211";
    var sung = "\u266A";
    var sup1 = "\xB9";
    var sup2 = "\xB2";
    var sup3 = "\xB3";
    var sup = "\u2283";
    var Sup = "\u22D1";
    var supdot = "\u2ABE";
    var supdsub = "\u2AD8";
    var supE = "\u2AC6";
    var supe = "\u2287";
    var supedot = "\u2AC4";
    var Superset = "\u2283";
    var SupersetEqual = "\u2287";
    var suphsol = "\u27C9";
    var suphsub = "\u2AD7";
    var suplarr = "\u297B";
    var supmult = "\u2AC2";
    var supnE = "\u2ACC";
    var supne = "\u228B";
    var supplus = "\u2AC0";
    var supset = "\u2283";
    var Supset = "\u22D1";
    var supseteq = "\u2287";
    var supseteqq = "\u2AC6";
    var supsetneq = "\u228B";
    var supsetneqq = "\u2ACC";
    var supsim = "\u2AC8";
    var supsub = "\u2AD4";
    var supsup = "\u2AD6";
    var swarhk = "\u2926";
    var swarr = "\u2199";
    var swArr = "\u21D9";
    var swarrow = "\u2199";
    var swnwar = "\u292A";
    var szlig = "\xDF";
    var Tab = "	";
    var target = "\u2316";
    var Tau = "\u03A4";
    var tau = "\u03C4";
    var tbrk = "\u23B4";
    var Tcaron = "\u0164";
    var tcaron = "\u0165";
    var Tcedil = "\u0162";
    var tcedil = "\u0163";
    var Tcy = "\u0422";
    var tcy = "\u0442";
    var tdot = "\u20DB";
    var telrec = "\u2315";
    var Tfr = "\u{1D517}";
    var tfr = "\u{1D531}";
    var there4 = "\u2234";
    var therefore = "\u2234";
    var Therefore = "\u2234";
    var Theta = "\u0398";
    var theta = "\u03B8";
    var thetasym = "\u03D1";
    var thetav = "\u03D1";
    var thickapprox = "\u2248";
    var thicksim = "\u223C";
    var ThickSpace = "\u205F\u200A";
    var ThinSpace = "\u2009";
    var thinsp = "\u2009";
    var thkap = "\u2248";
    var thksim = "\u223C";
    var THORN = "\xDE";
    var thorn = "\xFE";
    var tilde = "\u02DC";
    var Tilde = "\u223C";
    var TildeEqual = "\u2243";
    var TildeFullEqual = "\u2245";
    var TildeTilde = "\u2248";
    var timesbar = "\u2A31";
    var timesb = "\u22A0";
    var times = "\xD7";
    var timesd = "\u2A30";
    var tint = "\u222D";
    var toea = "\u2928";
    var topbot = "\u2336";
    var topcir = "\u2AF1";
    var top = "\u22A4";
    var Topf = "\u{1D54B}";
    var topf = "\u{1D565}";
    var topfork = "\u2ADA";
    var tosa = "\u2929";
    var tprime = "\u2034";
    var trade = "\u2122";
    var TRADE = "\u2122";
    var triangle = "\u25B5";
    var triangledown = "\u25BF";
    var triangleleft = "\u25C3";
    var trianglelefteq = "\u22B4";
    var triangleq = "\u225C";
    var triangleright = "\u25B9";
    var trianglerighteq = "\u22B5";
    var tridot = "\u25EC";
    var trie = "\u225C";
    var triminus = "\u2A3A";
    var TripleDot = "\u20DB";
    var triplus = "\u2A39";
    var trisb = "\u29CD";
    var tritime = "\u2A3B";
    var trpezium = "\u23E2";
    var Tscr = "\u{1D4AF}";
    var tscr = "\u{1D4C9}";
    var TScy = "\u0426";
    var tscy = "\u0446";
    var TSHcy = "\u040B";
    var tshcy = "\u045B";
    var Tstrok = "\u0166";
    var tstrok = "\u0167";
    var twixt = "\u226C";
    var twoheadleftarrow = "\u219E";
    var twoheadrightarrow = "\u21A0";
    var Uacute = "\xDA";
    var uacute = "\xFA";
    var uarr = "\u2191";
    var Uarr = "\u219F";
    var uArr = "\u21D1";
    var Uarrocir = "\u2949";
    var Ubrcy = "\u040E";
    var ubrcy = "\u045E";
    var Ubreve = "\u016C";
    var ubreve = "\u016D";
    var Ucirc = "\xDB";
    var ucirc = "\xFB";
    var Ucy = "\u0423";
    var ucy = "\u0443";
    var udarr = "\u21C5";
    var Udblac = "\u0170";
    var udblac = "\u0171";
    var udhar = "\u296E";
    var ufisht = "\u297E";
    var Ufr = "\u{1D518}";
    var ufr = "\u{1D532}";
    var Ugrave = "\xD9";
    var ugrave = "\xF9";
    var uHar = "\u2963";
    var uharl = "\u21BF";
    var uharr = "\u21BE";
    var uhblk = "\u2580";
    var ulcorn = "\u231C";
    var ulcorner = "\u231C";
    var ulcrop = "\u230F";
    var ultri = "\u25F8";
    var Umacr = "\u016A";
    var umacr = "\u016B";
    var uml = "\xA8";
    var UnderBar = "_";
    var UnderBrace = "\u23DF";
    var UnderBracket = "\u23B5";
    var UnderParenthesis = "\u23DD";
    var Union = "\u22C3";
    var UnionPlus = "\u228E";
    var Uogon = "\u0172";
    var uogon = "\u0173";
    var Uopf = "\u{1D54C}";
    var uopf = "\u{1D566}";
    var UpArrowBar = "\u2912";
    var uparrow = "\u2191";
    var UpArrow = "\u2191";
    var Uparrow = "\u21D1";
    var UpArrowDownArrow = "\u21C5";
    var updownarrow = "\u2195";
    var UpDownArrow = "\u2195";
    var Updownarrow = "\u21D5";
    var UpEquilibrium = "\u296E";
    var upharpoonleft = "\u21BF";
    var upharpoonright = "\u21BE";
    var uplus = "\u228E";
    var UpperLeftArrow = "\u2196";
    var UpperRightArrow = "\u2197";
    var upsi = "\u03C5";
    var Upsi = "\u03D2";
    var upsih = "\u03D2";
    var Upsilon = "\u03A5";
    var upsilon = "\u03C5";
    var UpTeeArrow = "\u21A5";
    var UpTee = "\u22A5";
    var upuparrows = "\u21C8";
    var urcorn = "\u231D";
    var urcorner = "\u231D";
    var urcrop = "\u230E";
    var Uring = "\u016E";
    var uring = "\u016F";
    var urtri = "\u25F9";
    var Uscr = "\u{1D4B0}";
    var uscr = "\u{1D4CA}";
    var utdot = "\u22F0";
    var Utilde = "\u0168";
    var utilde = "\u0169";
    var utri = "\u25B5";
    var utrif = "\u25B4";
    var uuarr = "\u21C8";
    var Uuml = "\xDC";
    var uuml = "\xFC";
    var uwangle = "\u29A7";
    var vangrt = "\u299C";
    var varepsilon = "\u03F5";
    var varkappa = "\u03F0";
    var varnothing = "\u2205";
    var varphi = "\u03D5";
    var varpi = "\u03D6";
    var varpropto = "\u221D";
    var varr = "\u2195";
    var vArr = "\u21D5";
    var varrho = "\u03F1";
    var varsigma = "\u03C2";
    var varsubsetneq = "\u228A\uFE00";
    var varsubsetneqq = "\u2ACB\uFE00";
    var varsupsetneq = "\u228B\uFE00";
    var varsupsetneqq = "\u2ACC\uFE00";
    var vartheta = "\u03D1";
    var vartriangleleft = "\u22B2";
    var vartriangleright = "\u22B3";
    var vBar = "\u2AE8";
    var Vbar = "\u2AEB";
    var vBarv = "\u2AE9";
    var Vcy = "\u0412";
    var vcy = "\u0432";
    var vdash = "\u22A2";
    var vDash = "\u22A8";
    var Vdash = "\u22A9";
    var VDash = "\u22AB";
    var Vdashl = "\u2AE6";
    var veebar = "\u22BB";
    var vee = "\u2228";
    var Vee = "\u22C1";
    var veeeq = "\u225A";
    var vellip = "\u22EE";
    var verbar = "|";
    var Verbar = "\u2016";
    var vert = "|";
    var Vert = "\u2016";
    var VerticalBar = "\u2223";
    var VerticalLine = "|";
    var VerticalSeparator = "\u2758";
    var VerticalTilde = "\u2240";
    var VeryThinSpace = "\u200A";
    var Vfr = "\u{1D519}";
    var vfr = "\u{1D533}";
    var vltri = "\u22B2";
    var vnsub = "\u2282\u20D2";
    var vnsup = "\u2283\u20D2";
    var Vopf = "\u{1D54D}";
    var vopf = "\u{1D567}";
    var vprop = "\u221D";
    var vrtri = "\u22B3";
    var Vscr = "\u{1D4B1}";
    var vscr = "\u{1D4CB}";
    var vsubnE = "\u2ACB\uFE00";
    var vsubne = "\u228A\uFE00";
    var vsupnE = "\u2ACC\uFE00";
    var vsupne = "\u228B\uFE00";
    var Vvdash = "\u22AA";
    var vzigzag = "\u299A";
    var Wcirc = "\u0174";
    var wcirc = "\u0175";
    var wedbar = "\u2A5F";
    var wedge = "\u2227";
    var Wedge = "\u22C0";
    var wedgeq = "\u2259";
    var weierp = "\u2118";
    var Wfr = "\u{1D51A}";
    var wfr = "\u{1D534}";
    var Wopf = "\u{1D54E}";
    var wopf = "\u{1D568}";
    var wp = "\u2118";
    var wr = "\u2240";
    var wreath = "\u2240";
    var Wscr = "\u{1D4B2}";
    var wscr = "\u{1D4CC}";
    var xcap = "\u22C2";
    var xcirc = "\u25EF";
    var xcup = "\u22C3";
    var xdtri = "\u25BD";
    var Xfr = "\u{1D51B}";
    var xfr = "\u{1D535}";
    var xharr = "\u27F7";
    var xhArr = "\u27FA";
    var Xi = "\u039E";
    var xi = "\u03BE";
    var xlarr = "\u27F5";
    var xlArr = "\u27F8";
    var xmap = "\u27FC";
    var xnis = "\u22FB";
    var xodot = "\u2A00";
    var Xopf = "\u{1D54F}";
    var xopf = "\u{1D569}";
    var xoplus = "\u2A01";
    var xotime = "\u2A02";
    var xrarr = "\u27F6";
    var xrArr = "\u27F9";
    var Xscr = "\u{1D4B3}";
    var xscr = "\u{1D4CD}";
    var xsqcup = "\u2A06";
    var xuplus = "\u2A04";
    var xutri = "\u25B3";
    var xvee = "\u22C1";
    var xwedge = "\u22C0";
    var Yacute = "\xDD";
    var yacute = "\xFD";
    var YAcy = "\u042F";
    var yacy = "\u044F";
    var Ycirc = "\u0176";
    var ycirc = "\u0177";
    var Ycy = "\u042B";
    var ycy = "\u044B";
    var yen = "\xA5";
    var Yfr = "\u{1D51C}";
    var yfr = "\u{1D536}";
    var YIcy = "\u0407";
    var yicy = "\u0457";
    var Yopf = "\u{1D550}";
    var yopf = "\u{1D56A}";
    var Yscr = "\u{1D4B4}";
    var yscr = "\u{1D4CE}";
    var YUcy = "\u042E";
    var yucy = "\u044E";
    var yuml = "\xFF";
    var Yuml = "\u0178";
    var Zacute = "\u0179";
    var zacute = "\u017A";
    var Zcaron = "\u017D";
    var zcaron = "\u017E";
    var Zcy = "\u0417";
    var zcy = "\u0437";
    var Zdot = "\u017B";
    var zdot = "\u017C";
    var zeetrf = "\u2128";
    var ZeroWidthSpace = "\u200B";
    var Zeta = "\u0396";
    var zeta = "\u03B6";
    var zfr = "\u{1D537}";
    var Zfr = "\u2128";
    var ZHcy = "\u0416";
    var zhcy = "\u0436";
    var zigrarr = "\u21DD";
    var zopf = "\u{1D56B}";
    var Zopf = "\u2124";
    var Zscr = "\u{1D4B5}";
    var zscr = "\u{1D4CF}";
    var zwj = "\u200D";
    var zwnj = "\u200C";
    var require$$0 = {
      Aacute,
      aacute,
      Abreve,
      abreve,
      ac,
      acd,
      acE,
      Acirc,
      acirc,
      acute,
      Acy,
      acy,
      AElig,
      aelig,
      af,
      Afr,
      afr,
      Agrave,
      agrave,
      alefsym,
      aleph,
      Alpha,
      alpha,
      Amacr,
      amacr,
      amalg,
      amp,
      AMP,
      andand,
      And,
      and,
      andd,
      andslope,
      andv,
      ang,
      ange,
      angle,
      angmsdaa,
      angmsdab,
      angmsdac,
      angmsdad,
      angmsdae,
      angmsdaf,
      angmsdag,
      angmsdah,
      angmsd,
      angrt,
      angrtvb,
      angrtvbd,
      angsph,
      angst,
      angzarr,
      Aogon,
      aogon,
      Aopf,
      aopf,
      apacir,
      ap,
      apE,
      ape,
      apid,
      apos,
      ApplyFunction,
      approx,
      approxeq,
      Aring,
      aring,
      Ascr,
      ascr,
      Assign,
      ast,
      asymp,
      asympeq,
      Atilde,
      atilde,
      Auml,
      auml,
      awconint,
      awint,
      backcong,
      backepsilon,
      backprime,
      backsim,
      backsimeq,
      Backslash,
      Barv,
      barvee,
      barwed,
      Barwed,
      barwedge,
      bbrk,
      bbrktbrk,
      bcong,
      Bcy,
      bcy,
      bdquo,
      becaus,
      because,
      Because,
      bemptyv,
      bepsi,
      bernou,
      Bernoullis,
      Beta,
      beta,
      beth,
      between,
      Bfr,
      bfr,
      bigcap,
      bigcirc,
      bigcup,
      bigodot,
      bigoplus,
      bigotimes,
      bigsqcup,
      bigstar,
      bigtriangledown,
      bigtriangleup,
      biguplus,
      bigvee,
      bigwedge,
      bkarow,
      blacklozenge,
      blacksquare,
      blacktriangle,
      blacktriangledown,
      blacktriangleleft,
      blacktriangleright,
      blank,
      blk12,
      blk14,
      blk34,
      block: block$1,
      bne,
      bnequiv,
      bNot,
      bnot,
      Bopf,
      bopf,
      bot,
      bottom,
      bowtie,
      boxbox,
      boxdl,
      boxdL,
      boxDl,
      boxDL,
      boxdr,
      boxdR,
      boxDr,
      boxDR,
      boxh,
      boxH,
      boxhd,
      boxHd,
      boxhD,
      boxHD,
      boxhu,
      boxHu,
      boxhU,
      boxHU,
      boxminus,
      boxplus,
      boxtimes,
      boxul,
      boxuL,
      boxUl,
      boxUL,
      boxur,
      boxuR,
      boxUr,
      boxUR,
      boxv,
      boxV,
      boxvh,
      boxvH,
      boxVh,
      boxVH,
      boxvl,
      boxvL,
      boxVl,
      boxVL,
      boxvr,
      boxvR,
      boxVr,
      boxVR,
      bprime,
      breve,
      Breve,
      brvbar,
      bscr,
      Bscr,
      bsemi,
      bsim,
      bsime,
      bsolb,
      bsol,
      bsolhsub,
      bull,
      bullet,
      bump,
      bumpE,
      bumpe,
      Bumpeq,
      bumpeq,
      Cacute,
      cacute,
      capand,
      capbrcup,
      capcap,
      cap,
      Cap,
      capcup,
      capdot,
      CapitalDifferentialD,
      caps,
      caret,
      caron,
      Cayleys,
      ccaps,
      Ccaron,
      ccaron,
      Ccedil,
      ccedil,
      Ccirc,
      ccirc,
      Cconint,
      ccups,
      ccupssm,
      Cdot,
      cdot,
      cedil,
      Cedilla,
      cemptyv,
      cent,
      centerdot,
      CenterDot,
      cfr,
      Cfr,
      CHcy,
      chcy,
      check,
      checkmark,
      Chi,
      chi,
      circ,
      circeq,
      circlearrowleft,
      circlearrowright,
      circledast,
      circledcirc,
      circleddash,
      CircleDot,
      circledR,
      circledS,
      CircleMinus,
      CirclePlus,
      CircleTimes,
      cir,
      cirE,
      cire,
      cirfnint,
      cirmid,
      cirscir,
      ClockwiseContourIntegral,
      CloseCurlyDoubleQuote,
      CloseCurlyQuote,
      clubs,
      clubsuit,
      colon,
      Colon,
      Colone,
      colone,
      coloneq,
      comma,
      commat,
      comp,
      compfn,
      complement,
      complexes,
      cong,
      congdot,
      Congruent,
      conint,
      Conint,
      ContourIntegral,
      copf,
      Copf,
      coprod,
      Coproduct,
      copy,
      COPY,
      copysr,
      CounterClockwiseContourIntegral,
      crarr,
      cross,
      Cross,
      Cscr,
      cscr,
      csub,
      csube,
      csup,
      csupe,
      ctdot,
      cudarrl,
      cudarrr,
      cuepr,
      cuesc,
      cularr,
      cularrp,
      cupbrcap,
      cupcap,
      CupCap,
      cup,
      Cup,
      cupcup,
      cupdot,
      cupor,
      cups,
      curarr,
      curarrm,
      curlyeqprec,
      curlyeqsucc,
      curlyvee,
      curlywedge,
      curren,
      curvearrowleft,
      curvearrowright,
      cuvee,
      cuwed,
      cwconint,
      cwint,
      cylcty,
      dagger,
      Dagger,
      daleth,
      darr,
      Darr,
      dArr,
      dash,
      Dashv,
      dashv,
      dbkarow,
      dblac,
      Dcaron,
      dcaron,
      Dcy,
      dcy,
      ddagger,
      ddarr,
      DD,
      dd,
      DDotrahd,
      ddotseq,
      deg,
      Del,
      Delta,
      delta,
      demptyv,
      dfisht,
      Dfr,
      dfr,
      dHar,
      dharl,
      dharr,
      DiacriticalAcute,
      DiacriticalDot,
      DiacriticalDoubleAcute,
      DiacriticalGrave,
      DiacriticalTilde,
      diam,
      diamond,
      Diamond,
      diamondsuit,
      diams,
      die,
      DifferentialD,
      digamma,
      disin,
      div,
      divide,
      divideontimes,
      divonx,
      DJcy,
      djcy,
      dlcorn,
      dlcrop,
      dollar,
      Dopf,
      dopf,
      Dot,
      dot,
      DotDot,
      doteq,
      doteqdot,
      DotEqual,
      dotminus,
      dotplus,
      dotsquare,
      doublebarwedge,
      DoubleContourIntegral,
      DoubleDot,
      DoubleDownArrow,
      DoubleLeftArrow,
      DoubleLeftRightArrow,
      DoubleLeftTee,
      DoubleLongLeftArrow,
      DoubleLongLeftRightArrow,
      DoubleLongRightArrow,
      DoubleRightArrow,
      DoubleRightTee,
      DoubleUpArrow,
      DoubleUpDownArrow,
      DoubleVerticalBar,
      DownArrowBar,
      downarrow,
      DownArrow,
      Downarrow,
      DownArrowUpArrow,
      DownBreve,
      downdownarrows,
      downharpoonleft,
      downharpoonright,
      DownLeftRightVector,
      DownLeftTeeVector,
      DownLeftVectorBar,
      DownLeftVector,
      DownRightTeeVector,
      DownRightVectorBar,
      DownRightVector,
      DownTeeArrow,
      DownTee,
      drbkarow,
      drcorn,
      drcrop,
      Dscr,
      dscr,
      DScy,
      dscy,
      dsol,
      Dstrok,
      dstrok,
      dtdot,
      dtri,
      dtrif,
      duarr,
      duhar,
      dwangle,
      DZcy,
      dzcy,
      dzigrarr,
      Eacute,
      eacute,
      easter,
      Ecaron,
      ecaron,
      Ecirc,
      ecirc,
      ecir,
      ecolon,
      Ecy,
      ecy,
      eDDot,
      Edot,
      edot,
      eDot,
      ee,
      efDot,
      Efr,
      efr,
      eg,
      Egrave,
      egrave,
      egs,
      egsdot,
      el,
      Element,
      elinters,
      ell,
      els,
      elsdot,
      Emacr,
      emacr,
      empty,
      emptyset,
      EmptySmallSquare,
      emptyv,
      EmptyVerySmallSquare,
      emsp13,
      emsp14,
      emsp,
      ENG,
      eng,
      ensp,
      Eogon,
      eogon,
      Eopf,
      eopf,
      epar,
      eparsl,
      eplus,
      epsi,
      Epsilon,
      epsilon,
      epsiv,
      eqcirc,
      eqcolon,
      eqsim,
      eqslantgtr,
      eqslantless,
      Equal,
      equals,
      EqualTilde,
      equest,
      Equilibrium,
      equiv,
      equivDD,
      eqvparsl,
      erarr,
      erDot,
      escr,
      Escr,
      esdot,
      Esim,
      esim,
      Eta,
      eta,
      ETH,
      eth,
      Euml,
      euml,
      euro,
      excl,
      exist,
      Exists,
      expectation,
      exponentiale,
      ExponentialE,
      fallingdotseq,
      Fcy,
      fcy,
      female,
      ffilig,
      fflig,
      ffllig,
      Ffr,
      ffr,
      filig,
      FilledSmallSquare,
      FilledVerySmallSquare,
      fjlig,
      flat,
      fllig,
      fltns,
      fnof,
      Fopf,
      fopf,
      forall,
      ForAll,
      fork,
      forkv,
      Fouriertrf,
      fpartint,
      frac12,
      frac13,
      frac14,
      frac15,
      frac16,
      frac18,
      frac23,
      frac25,
      frac34,
      frac35,
      frac38,
      frac45,
      frac56,
      frac58,
      frac78,
      frasl,
      frown,
      fscr,
      Fscr,
      gacute,
      Gamma,
      gamma,
      Gammad,
      gammad,
      gap,
      Gbreve,
      gbreve,
      Gcedil,
      Gcirc,
      gcirc,
      Gcy,
      gcy,
      Gdot,
      gdot,
      ge,
      gE,
      gEl,
      gel,
      geq,
      geqq,
      geqslant,
      gescc,
      ges,
      gesdot,
      gesdoto,
      gesdotol,
      gesl,
      gesles,
      Gfr,
      gfr,
      gg,
      Gg,
      ggg,
      gimel,
      GJcy,
      gjcy,
      gla,
      gl,
      glE,
      glj,
      gnap,
      gnapprox,
      gne,
      gnE,
      gneq,
      gneqq,
      gnsim,
      Gopf,
      gopf,
      grave,
      GreaterEqual,
      GreaterEqualLess,
      GreaterFullEqual,
      GreaterGreater,
      GreaterLess,
      GreaterSlantEqual,
      GreaterTilde,
      Gscr,
      gscr,
      gsim,
      gsime,
      gsiml,
      gtcc,
      gtcir,
      gt,
      GT,
      Gt,
      gtdot,
      gtlPar,
      gtquest,
      gtrapprox,
      gtrarr,
      gtrdot,
      gtreqless,
      gtreqqless,
      gtrless,
      gtrsim,
      gvertneqq,
      gvnE,
      Hacek,
      hairsp,
      half,
      hamilt,
      HARDcy,
      hardcy,
      harrcir,
      harr,
      hArr,
      harrw,
      Hat,
      hbar,
      Hcirc,
      hcirc,
      hearts,
      heartsuit,
      hellip,
      hercon,
      hfr,
      Hfr,
      HilbertSpace,
      hksearow,
      hkswarow,
      hoarr,
      homtht,
      hookleftarrow,
      hookrightarrow,
      hopf,
      Hopf,
      horbar,
      HorizontalLine,
      hscr,
      Hscr,
      hslash,
      Hstrok,
      hstrok,
      HumpDownHump,
      HumpEqual,
      hybull,
      hyphen,
      Iacute,
      iacute,
      ic,
      Icirc,
      icirc,
      Icy,
      icy,
      Idot,
      IEcy,
      iecy,
      iexcl,
      iff,
      ifr,
      Ifr,
      Igrave,
      igrave,
      ii,
      iiiint,
      iiint,
      iinfin,
      iiota,
      IJlig,
      ijlig,
      Imacr,
      imacr,
      image: image$1,
      ImaginaryI,
      imagline,
      imagpart,
      imath,
      Im,
      imof,
      imped,
      Implies,
      incare,
      "in": "\u2208",
      infin,
      infintie,
      inodot,
      intcal,
      int,
      Int,
      integers,
      Integral,
      intercal,
      Intersection,
      intlarhk,
      intprod,
      InvisibleComma,
      InvisibleTimes,
      IOcy,
      iocy,
      Iogon,
      iogon,
      Iopf,
      iopf,
      Iota,
      iota,
      iprod,
      iquest,
      iscr,
      Iscr,
      isin,
      isindot,
      isinE,
      isins,
      isinsv,
      isinv,
      it,
      Itilde,
      itilde,
      Iukcy,
      iukcy,
      Iuml,
      iuml,
      Jcirc,
      jcirc,
      Jcy,
      jcy,
      Jfr,
      jfr,
      jmath,
      Jopf,
      jopf,
      Jscr,
      jscr,
      Jsercy,
      jsercy,
      Jukcy,
      jukcy,
      Kappa,
      kappa,
      kappav,
      Kcedil,
      kcedil,
      Kcy,
      kcy,
      Kfr,
      kfr,
      kgreen,
      KHcy,
      khcy,
      KJcy,
      kjcy,
      Kopf,
      kopf,
      Kscr,
      kscr,
      lAarr,
      Lacute,
      lacute,
      laemptyv,
      lagran,
      Lambda,
      lambda,
      lang,
      Lang,
      langd,
      langle,
      lap,
      Laplacetrf,
      laquo,
      larrb,
      larrbfs,
      larr,
      Larr,
      lArr,
      larrfs,
      larrhk,
      larrlp,
      larrpl,
      larrsim,
      larrtl,
      latail,
      lAtail,
      lat,
      late,
      lates,
      lbarr,
      lBarr,
      lbbrk,
      lbrace,
      lbrack,
      lbrke,
      lbrksld,
      lbrkslu,
      Lcaron,
      lcaron,
      Lcedil,
      lcedil,
      lceil,
      lcub,
      Lcy,
      lcy,
      ldca,
      ldquo,
      ldquor,
      ldrdhar,
      ldrushar,
      ldsh,
      le,
      lE,
      LeftAngleBracket,
      LeftArrowBar,
      leftarrow,
      LeftArrow,
      Leftarrow,
      LeftArrowRightArrow,
      leftarrowtail,
      LeftCeiling,
      LeftDoubleBracket,
      LeftDownTeeVector,
      LeftDownVectorBar,
      LeftDownVector,
      LeftFloor,
      leftharpoondown,
      leftharpoonup,
      leftleftarrows,
      leftrightarrow,
      LeftRightArrow,
      Leftrightarrow,
      leftrightarrows,
      leftrightharpoons,
      leftrightsquigarrow,
      LeftRightVector,
      LeftTeeArrow,
      LeftTee,
      LeftTeeVector,
      leftthreetimes,
      LeftTriangleBar,
      LeftTriangle,
      LeftTriangleEqual,
      LeftUpDownVector,
      LeftUpTeeVector,
      LeftUpVectorBar,
      LeftUpVector,
      LeftVectorBar,
      LeftVector,
      lEg,
      leg,
      leq,
      leqq,
      leqslant,
      lescc,
      les,
      lesdot,
      lesdoto,
      lesdotor,
      lesg,
      lesges,
      lessapprox,
      lessdot,
      lesseqgtr,
      lesseqqgtr,
      LessEqualGreater,
      LessFullEqual,
      LessGreater,
      lessgtr,
      LessLess,
      lesssim,
      LessSlantEqual,
      LessTilde,
      lfisht,
      lfloor,
      Lfr,
      lfr,
      lg,
      lgE,
      lHar,
      lhard,
      lharu,
      lharul,
      lhblk,
      LJcy,
      ljcy,
      llarr,
      ll,
      Ll,
      llcorner,
      Lleftarrow,
      llhard,
      lltri,
      Lmidot,
      lmidot,
      lmoustache,
      lmoust,
      lnap,
      lnapprox,
      lne,
      lnE,
      lneq,
      lneqq,
      lnsim,
      loang,
      loarr,
      lobrk,
      longleftarrow,
      LongLeftArrow,
      Longleftarrow,
      longleftrightarrow,
      LongLeftRightArrow,
      Longleftrightarrow,
      longmapsto,
      longrightarrow,
      LongRightArrow,
      Longrightarrow,
      looparrowleft,
      looparrowright,
      lopar,
      Lopf,
      lopf,
      loplus,
      lotimes,
      lowast,
      lowbar,
      LowerLeftArrow,
      LowerRightArrow,
      loz,
      lozenge,
      lozf,
      lpar,
      lparlt,
      lrarr,
      lrcorner,
      lrhar,
      lrhard,
      lrm,
      lrtri,
      lsaquo,
      lscr,
      Lscr,
      lsh,
      Lsh,
      lsim,
      lsime,
      lsimg,
      lsqb,
      lsquo,
      lsquor,
      Lstrok,
      lstrok,
      ltcc,
      ltcir,
      lt,
      LT,
      Lt,
      ltdot,
      lthree,
      ltimes,
      ltlarr,
      ltquest,
      ltri,
      ltrie,
      ltrif,
      ltrPar,
      lurdshar,
      luruhar,
      lvertneqq,
      lvnE,
      macr,
      male,
      malt,
      maltese,
      "Map": "\u2905",
      map,
      mapsto,
      mapstodown,
      mapstoleft,
      mapstoup,
      marker,
      mcomma,
      Mcy,
      mcy,
      mdash,
      mDDot,
      measuredangle,
      MediumSpace,
      Mellintrf,
      Mfr,
      mfr,
      mho,
      micro,
      midast,
      midcir,
      mid,
      middot,
      minusb,
      minus,
      minusd,
      minusdu,
      MinusPlus,
      mlcp,
      mldr,
      mnplus,
      models,
      Mopf,
      mopf,
      mp,
      mscr,
      Mscr,
      mstpos,
      Mu,
      mu,
      multimap,
      mumap,
      nabla,
      Nacute,
      nacute,
      nang,
      nap,
      napE,
      napid,
      napos,
      napprox,
      natural,
      naturals,
      natur,
      nbsp,
      nbump,
      nbumpe,
      ncap,
      Ncaron,
      ncaron,
      Ncedil,
      ncedil,
      ncong,
      ncongdot,
      ncup,
      Ncy,
      ncy,
      ndash,
      nearhk,
      nearr,
      neArr,
      nearrow,
      ne,
      nedot,
      NegativeMediumSpace,
      NegativeThickSpace,
      NegativeThinSpace,
      NegativeVeryThinSpace,
      nequiv,
      nesear,
      nesim,
      NestedGreaterGreater,
      NestedLessLess,
      NewLine,
      nexist,
      nexists,
      Nfr,
      nfr,
      ngE,
      nge,
      ngeq,
      ngeqq,
      ngeqslant,
      nges,
      nGg,
      ngsim,
      nGt,
      ngt,
      ngtr,
      nGtv,
      nharr,
      nhArr,
      nhpar,
      ni,
      nis,
      nisd,
      niv,
      NJcy,
      njcy,
      nlarr,
      nlArr,
      nldr,
      nlE,
      nle,
      nleftarrow,
      nLeftarrow,
      nleftrightarrow,
      nLeftrightarrow,
      nleq,
      nleqq,
      nleqslant,
      nles,
      nless,
      nLl,
      nlsim,
      nLt,
      nlt,
      nltri,
      nltrie,
      nLtv,
      nmid,
      NoBreak,
      NonBreakingSpace,
      nopf,
      Nopf,
      Not,
      not,
      NotCongruent,
      NotCupCap,
      NotDoubleVerticalBar,
      NotElement,
      NotEqual,
      NotEqualTilde,
      NotExists,
      NotGreater,
      NotGreaterEqual,
      NotGreaterFullEqual,
      NotGreaterGreater,
      NotGreaterLess,
      NotGreaterSlantEqual,
      NotGreaterTilde,
      NotHumpDownHump,
      NotHumpEqual,
      notin,
      notindot,
      notinE,
      notinva,
      notinvb,
      notinvc,
      NotLeftTriangleBar,
      NotLeftTriangle,
      NotLeftTriangleEqual,
      NotLess,
      NotLessEqual,
      NotLessGreater,
      NotLessLess,
      NotLessSlantEqual,
      NotLessTilde,
      NotNestedGreaterGreater,
      NotNestedLessLess,
      notni,
      notniva,
      notnivb,
      notnivc,
      NotPrecedes,
      NotPrecedesEqual,
      NotPrecedesSlantEqual,
      NotReverseElement,
      NotRightTriangleBar,
      NotRightTriangle,
      NotRightTriangleEqual,
      NotSquareSubset,
      NotSquareSubsetEqual,
      NotSquareSuperset,
      NotSquareSupersetEqual,
      NotSubset,
      NotSubsetEqual,
      NotSucceeds,
      NotSucceedsEqual,
      NotSucceedsSlantEqual,
      NotSucceedsTilde,
      NotSuperset,
      NotSupersetEqual,
      NotTilde,
      NotTildeEqual,
      NotTildeFullEqual,
      NotTildeTilde,
      NotVerticalBar,
      nparallel,
      npar,
      nparsl,
      npart,
      npolint,
      npr,
      nprcue,
      nprec,
      npreceq,
      npre,
      nrarrc,
      nrarr,
      nrArr,
      nrarrw,
      nrightarrow,
      nRightarrow,
      nrtri,
      nrtrie,
      nsc,
      nsccue,
      nsce,
      Nscr,
      nscr,
      nshortmid,
      nshortparallel,
      nsim,
      nsime,
      nsimeq,
      nsmid,
      nspar,
      nsqsube,
      nsqsupe,
      nsub,
      nsubE,
      nsube,
      nsubset,
      nsubseteq,
      nsubseteqq,
      nsucc,
      nsucceq,
      nsup,
      nsupE,
      nsupe,
      nsupset,
      nsupseteq,
      nsupseteqq,
      ntgl,
      Ntilde,
      ntilde,
      ntlg,
      ntriangleleft,
      ntrianglelefteq,
      ntriangleright,
      ntrianglerighteq,
      Nu,
      nu,
      num,
      numero,
      numsp,
      nvap,
      nvdash,
      nvDash,
      nVdash,
      nVDash,
      nvge,
      nvgt,
      nvHarr,
      nvinfin,
      nvlArr,
      nvle,
      nvlt,
      nvltrie,
      nvrArr,
      nvrtrie,
      nvsim,
      nwarhk,
      nwarr,
      nwArr,
      nwarrow,
      nwnear,
      Oacute,
      oacute,
      oast,
      Ocirc,
      ocirc,
      ocir,
      Ocy,
      ocy,
      odash,
      Odblac,
      odblac,
      odiv,
      odot,
      odsold,
      OElig,
      oelig,
      ofcir,
      Ofr,
      ofr,
      ogon,
      Ograve,
      ograve,
      ogt,
      ohbar,
      ohm,
      oint,
      olarr,
      olcir,
      olcross,
      oline,
      olt,
      Omacr,
      omacr,
      Omega,
      omega,
      Omicron,
      omicron,
      omid,
      ominus,
      Oopf,
      oopf,
      opar,
      OpenCurlyDoubleQuote,
      OpenCurlyQuote,
      operp,
      oplus,
      orarr,
      Or,
      or,
      ord,
      order,
      orderof,
      ordf,
      ordm,
      origof,
      oror,
      orslope,
      orv,
      oS,
      Oscr,
      oscr,
      Oslash,
      oslash,
      osol,
      Otilde,
      otilde,
      otimesas,
      Otimes,
      otimes,
      Ouml,
      ouml,
      ovbar,
      OverBar,
      OverBrace,
      OverBracket,
      OverParenthesis,
      para,
      parallel,
      par,
      parsim,
      parsl,
      part,
      PartialD,
      Pcy,
      pcy,
      percnt,
      period,
      permil,
      perp,
      pertenk,
      Pfr,
      pfr,
      Phi,
      phi,
      phiv,
      phmmat,
      phone,
      Pi,
      pi,
      pitchfork,
      piv,
      planck,
      planckh,
      plankv,
      plusacir,
      plusb,
      pluscir,
      plus,
      plusdo,
      plusdu,
      pluse,
      PlusMinus,
      plusmn,
      plussim,
      plustwo,
      pm,
      Poincareplane,
      pointint,
      popf,
      Popf,
      pound,
      prap,
      Pr,
      pr,
      prcue,
      precapprox,
      prec,
      preccurlyeq,
      Precedes,
      PrecedesEqual,
      PrecedesSlantEqual,
      PrecedesTilde,
      preceq,
      precnapprox,
      precneqq,
      precnsim,
      pre,
      prE,
      precsim,
      prime,
      Prime,
      primes,
      prnap,
      prnE,
      prnsim,
      prod,
      Product,
      profalar,
      profline,
      profsurf,
      prop,
      Proportional,
      Proportion,
      propto,
      prsim,
      prurel,
      Pscr,
      pscr,
      Psi,
      psi,
      puncsp,
      Qfr,
      qfr,
      qint,
      qopf,
      Qopf,
      qprime,
      Qscr,
      qscr,
      quaternions,
      quatint,
      quest,
      questeq,
      quot,
      QUOT,
      rAarr,
      race,
      Racute,
      racute,
      radic,
      raemptyv,
      rang,
      Rang,
      rangd,
      range,
      rangle,
      raquo,
      rarrap,
      rarrb,
      rarrbfs,
      rarrc,
      rarr,
      Rarr,
      rArr,
      rarrfs,
      rarrhk,
      rarrlp,
      rarrpl,
      rarrsim,
      Rarrtl,
      rarrtl,
      rarrw,
      ratail,
      rAtail,
      ratio,
      rationals,
      rbarr,
      rBarr,
      RBarr,
      rbbrk,
      rbrace,
      rbrack,
      rbrke,
      rbrksld,
      rbrkslu,
      Rcaron,
      rcaron,
      Rcedil,
      rcedil,
      rceil,
      rcub,
      Rcy,
      rcy,
      rdca,
      rdldhar,
      rdquo,
      rdquor,
      rdsh,
      real,
      realine,
      realpart,
      reals,
      Re,
      rect,
      reg,
      REG,
      ReverseElement,
      ReverseEquilibrium,
      ReverseUpEquilibrium,
      rfisht,
      rfloor,
      rfr,
      Rfr,
      rHar,
      rhard,
      rharu,
      rharul,
      Rho,
      rho,
      rhov,
      RightAngleBracket,
      RightArrowBar,
      rightarrow,
      RightArrow,
      Rightarrow,
      RightArrowLeftArrow,
      rightarrowtail,
      RightCeiling,
      RightDoubleBracket,
      RightDownTeeVector,
      RightDownVectorBar,
      RightDownVector,
      RightFloor,
      rightharpoondown,
      rightharpoonup,
      rightleftarrows,
      rightleftharpoons,
      rightrightarrows,
      rightsquigarrow,
      RightTeeArrow,
      RightTee,
      RightTeeVector,
      rightthreetimes,
      RightTriangleBar,
      RightTriangle,
      RightTriangleEqual,
      RightUpDownVector,
      RightUpTeeVector,
      RightUpVectorBar,
      RightUpVector,
      RightVectorBar,
      RightVector,
      ring,
      risingdotseq,
      rlarr,
      rlhar,
      rlm,
      rmoustache,
      rmoust,
      rnmid,
      roang,
      roarr,
      robrk,
      ropar,
      ropf,
      Ropf,
      roplus,
      rotimes,
      RoundImplies,
      rpar,
      rpargt,
      rppolint,
      rrarr,
      Rrightarrow,
      rsaquo,
      rscr,
      Rscr,
      rsh,
      Rsh,
      rsqb,
      rsquo,
      rsquor,
      rthree,
      rtimes,
      rtri,
      rtrie,
      rtrif,
      rtriltri,
      RuleDelayed,
      ruluhar,
      rx,
      Sacute,
      sacute,
      sbquo,
      scap,
      Scaron,
      scaron,
      Sc,
      sc,
      sccue,
      sce,
      scE,
      Scedil,
      scedil,
      Scirc,
      scirc,
      scnap,
      scnE,
      scnsim,
      scpolint,
      scsim,
      Scy,
      scy,
      sdotb,
      sdot,
      sdote,
      searhk,
      searr,
      seArr,
      searrow,
      sect,
      semi,
      seswar,
      setminus,
      setmn,
      sext,
      Sfr,
      sfr,
      sfrown,
      sharp,
      SHCHcy,
      shchcy,
      SHcy,
      shcy,
      ShortDownArrow,
      ShortLeftArrow,
      shortmid,
      shortparallel,
      ShortRightArrow,
      ShortUpArrow,
      shy,
      Sigma,
      sigma,
      sigmaf,
      sigmav,
      sim,
      simdot,
      sime,
      simeq,
      simg,
      simgE,
      siml,
      simlE,
      simne,
      simplus,
      simrarr,
      slarr,
      SmallCircle,
      smallsetminus,
      smashp,
      smeparsl,
      smid,
      smile,
      smt,
      smte,
      smtes,
      SOFTcy,
      softcy,
      solbar,
      solb,
      sol,
      Sopf,
      sopf,
      spades,
      spadesuit,
      spar,
      sqcap,
      sqcaps,
      sqcup,
      sqcups,
      Sqrt,
      sqsub,
      sqsube,
      sqsubset,
      sqsubseteq,
      sqsup,
      sqsupe,
      sqsupset,
      sqsupseteq,
      square,
      Square,
      SquareIntersection,
      SquareSubset,
      SquareSubsetEqual,
      SquareSuperset,
      SquareSupersetEqual,
      SquareUnion,
      squarf,
      squ,
      squf,
      srarr,
      Sscr,
      sscr,
      ssetmn,
      ssmile,
      sstarf,
      Star,
      star,
      starf,
      straightepsilon,
      straightphi,
      strns,
      sub,
      Sub,
      subdot,
      subE,
      sube,
      subedot,
      submult,
      subnE,
      subne,
      subplus,
      subrarr,
      subset,
      Subset,
      subseteq,
      subseteqq,
      SubsetEqual,
      subsetneq,
      subsetneqq,
      subsim,
      subsub,
      subsup,
      succapprox,
      succ,
      succcurlyeq,
      Succeeds,
      SucceedsEqual,
      SucceedsSlantEqual,
      SucceedsTilde,
      succeq,
      succnapprox,
      succneqq,
      succnsim,
      succsim,
      SuchThat,
      sum,
      Sum,
      sung,
      sup1,
      sup2,
      sup3,
      sup,
      Sup,
      supdot,
      supdsub,
      supE,
      supe,
      supedot,
      Superset,
      SupersetEqual,
      suphsol,
      suphsub,
      suplarr,
      supmult,
      supnE,
      supne,
      supplus,
      supset,
      Supset,
      supseteq,
      supseteqq,
      supsetneq,
      supsetneqq,
      supsim,
      supsub,
      supsup,
      swarhk,
      swarr,
      swArr,
      swarrow,
      swnwar,
      szlig,
      Tab,
      target,
      Tau,
      tau,
      tbrk,
      Tcaron,
      tcaron,
      Tcedil,
      tcedil,
      Tcy,
      tcy,
      tdot,
      telrec,
      Tfr,
      tfr,
      there4,
      therefore,
      Therefore,
      Theta,
      theta,
      thetasym,
      thetav,
      thickapprox,
      thicksim,
      ThickSpace,
      ThinSpace,
      thinsp,
      thkap,
      thksim,
      THORN,
      thorn,
      tilde,
      Tilde,
      TildeEqual,
      TildeFullEqual,
      TildeTilde,
      timesbar,
      timesb,
      times,
      timesd,
      tint,
      toea,
      topbot,
      topcir,
      top,
      Topf,
      topf,
      topfork,
      tosa,
      tprime,
      trade,
      TRADE,
      triangle,
      triangledown,
      triangleleft,
      trianglelefteq,
      triangleq,
      triangleright,
      trianglerighteq,
      tridot,
      trie,
      triminus,
      TripleDot,
      triplus,
      trisb,
      tritime,
      trpezium,
      Tscr,
      tscr,
      TScy,
      tscy,
      TSHcy,
      tshcy,
      Tstrok,
      tstrok,
      twixt,
      twoheadleftarrow,
      twoheadrightarrow,
      Uacute,
      uacute,
      uarr,
      Uarr,
      uArr,
      Uarrocir,
      Ubrcy,
      ubrcy,
      Ubreve,
      ubreve,
      Ucirc,
      ucirc,
      Ucy,
      ucy,
      udarr,
      Udblac,
      udblac,
      udhar,
      ufisht,
      Ufr,
      ufr,
      Ugrave,
      ugrave,
      uHar,
      uharl,
      uharr,
      uhblk,
      ulcorn,
      ulcorner,
      ulcrop,
      ultri,
      Umacr,
      umacr,
      uml,
      UnderBar,
      UnderBrace,
      UnderBracket,
      UnderParenthesis,
      Union,
      UnionPlus,
      Uogon,
      uogon,
      Uopf,
      uopf,
      UpArrowBar,
      uparrow,
      UpArrow,
      Uparrow,
      UpArrowDownArrow,
      updownarrow,
      UpDownArrow,
      Updownarrow,
      UpEquilibrium,
      upharpoonleft,
      upharpoonright,
      uplus,
      UpperLeftArrow,
      UpperRightArrow,
      upsi,
      Upsi,
      upsih,
      Upsilon,
      upsilon,
      UpTeeArrow,
      UpTee,
      upuparrows,
      urcorn,
      urcorner,
      urcrop,
      Uring,
      uring,
      urtri,
      Uscr,
      uscr,
      utdot,
      Utilde,
      utilde,
      utri,
      utrif,
      uuarr,
      Uuml,
      uuml,
      uwangle,
      vangrt,
      varepsilon,
      varkappa,
      varnothing,
      varphi,
      varpi,
      varpropto,
      varr,
      vArr,
      varrho,
      varsigma,
      varsubsetneq,
      varsubsetneqq,
      varsupsetneq,
      varsupsetneqq,
      vartheta,
      vartriangleleft,
      vartriangleright,
      vBar,
      Vbar,
      vBarv,
      Vcy,
      vcy,
      vdash,
      vDash,
      Vdash,
      VDash,
      Vdashl,
      veebar,
      vee,
      Vee,
      veeeq,
      vellip,
      verbar,
      Verbar,
      vert,
      Vert,
      VerticalBar,
      VerticalLine,
      VerticalSeparator,
      VerticalTilde,
      VeryThinSpace,
      Vfr,
      vfr,
      vltri,
      vnsub,
      vnsup,
      Vopf,
      vopf,
      vprop,
      vrtri,
      Vscr,
      vscr,
      vsubnE,
      vsubne,
      vsupnE,
      vsupne,
      Vvdash,
      vzigzag,
      Wcirc,
      wcirc,
      wedbar,
      wedge,
      Wedge,
      wedgeq,
      weierp,
      Wfr,
      wfr,
      Wopf,
      wopf,
      wp,
      wr,
      wreath,
      Wscr,
      wscr,
      xcap,
      xcirc,
      xcup,
      xdtri,
      Xfr,
      xfr,
      xharr,
      xhArr,
      Xi,
      xi,
      xlarr,
      xlArr,
      xmap,
      xnis,
      xodot,
      Xopf,
      xopf,
      xoplus,
      xotime,
      xrarr,
      xrArr,
      Xscr,
      xscr,
      xsqcup,
      xuplus,
      xutri,
      xvee,
      xwedge,
      Yacute,
      yacute,
      YAcy,
      yacy,
      Ycirc,
      ycirc,
      Ycy,
      ycy,
      yen,
      Yfr,
      yfr,
      YIcy,
      yicy,
      Yopf,
      yopf,
      Yscr,
      yscr,
      YUcy,
      yucy,
      yuml,
      Yuml,
      Zacute,
      zacute,
      Zcaron,
      zcaron,
      Zcy,
      zcy,
      Zdot,
      zdot,
      zeetrf,
      ZeroWidthSpace,
      Zeta,
      zeta,
      zfr,
      Zfr,
      ZHcy,
      zhcy,
      zigrarr,
      zopf,
      Zopf,
      Zscr,
      zscr,
      zwj,
      zwnj
    };
    (function(module3) {
      module3.exports = require$$0;
    })(entities$1);
    getDefaultExportFromCjs(entitiesExports);
    var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
    var mdurl$1 = {};
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i2, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i2.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        cache[exclude.charCodeAt(i2)] = exclude[i2];
      }
      return cache;
    }
    function encode(string, exclude, keepEscaped) {
      var i2, l, code2, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i2 = 0, l = string.length; i2 < l; i2++) {
        code2 = string.charCodeAt(i2);
        if (keepEscaped && code2 === 37 && i2 + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i2 + 1, i2 + 3))) {
            result += string.slice(i2, i2 + 3);
            i2 += 2;
            continue;
          }
        }
        if (code2 < 128) {
          result += cache[code2];
          continue;
        }
        if (code2 >= 55296 && code2 <= 57343) {
          if (code2 >= 55296 && code2 <= 56319 && i2 + 1 < l) {
            nextCode = string.charCodeAt(i2 + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i2] + string[i2 + 1]);
              i2++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i2]);
      }
      return result;
    }
    encode.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode.componentChars = "-_.!~*'()";
    var encode_1 = encode;
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i2, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i2 = 0; i2 < 128; i2++) {
        ch = String.fromCharCode(i2);
        cache.push(ch);
      }
      for (i2 = 0; i2 < exclude.length; i2++) {
        ch = exclude.charCodeAt(i2);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i2, l, b1, b2, b3, b4, chr, result = "";
        for (i2 = 0, l = seq.length; i2 < l; i2 += 3) {
          b1 = parseInt(seq.slice(i2 + 1, i2 + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i2 + 3 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i2 + 6 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i2 += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i2 + 9 < l) {
            b2 = parseInt(seq.slice(i2 + 4, i2 + 6), 16);
            b3 = parseInt(seq.slice(i2 + 7, i2 + 9), 16);
            b4 = parseInt(seq.slice(i2 + 10, i2 + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i2 += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode.defaultChars = ";/?:@&=+$,#";
    decode.componentChars = "";
    var decode_1 = decode;
    var format = function format2(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i2, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i2 = 0; i2 < hostEndingChars.length; i2++) {
          hec = rest.indexOf(hostEndingChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i2 = 0; i2 < nonHostChars.length; i2++) {
          hec = rest.indexOf(nonHostChars[i2]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i2 = 0, l = hostparts.length; i2 < l; i2++) {
            var part2 = hostparts[i2];
            if (!part2) {
              continue;
            }
            if (!part2.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part2.length; j < k; j++) {
                if (part2.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part2[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i2);
                var notHost = hostparts.slice(i2 + 1);
                var bit = part2.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    var parse = urlParse;
    mdurl$1.encode = encode_1;
    mdurl$1.decode = decode_1;
    mdurl$1.format = format;
    mdurl$1.parse = parse;
    var uc_micro = {};
    var regex$3;
    var hasRequiredRegex$3;
    function requireRegex$3() {
      if (hasRequiredRegex$3)
        return regex$3;
      hasRequiredRegex$3 = 1;
      regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
      return regex$3;
    }
    var regex$2;
    var hasRequiredRegex$2;
    function requireRegex$2() {
      if (hasRequiredRegex$2)
        return regex$2;
      hasRequiredRegex$2 = 1;
      regex$2 = /[\0-\x1F\x7F-\x9F]/;
      return regex$2;
    }
    var regex$1;
    var hasRequiredRegex$1;
    function requireRegex$1() {
      if (hasRequiredRegex$1)
        return regex$1;
      hasRequiredRegex$1 = 1;
      regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
      return regex$1;
    }
    var regex;
    var hasRequiredRegex;
    function requireRegex() {
      if (hasRequiredRegex)
        return regex;
      hasRequiredRegex = 1;
      regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
      return regex;
    }
    var hasRequiredUc_micro;
    function requireUc_micro() {
      if (hasRequiredUc_micro)
        return uc_micro;
      hasRequiredUc_micro = 1;
      uc_micro.Any = requireRegex$3();
      uc_micro.Cc = requireRegex$2();
      uc_micro.Cf = requireRegex$1();
      uc_micro.P = regex$4;
      uc_micro.Z = requireRegex();
      return uc_micro;
    }
    (function(exports2) {
      function _class2(obj) {
        return Object.prototype.toString.call(obj);
      }
      function isString2(obj) {
        return _class2(obj) === "[object String]";
      }
      var _hasOwnProperty = Object.prototype.hasOwnProperty;
      function has2(object, key) {
        return _hasOwnProperty.call(object, key);
      }
      function assign2(obj) {
        var sources = Array.prototype.slice.call(arguments, 1);
        sources.forEach(function(source) {
          if (!source) {
            return;
          }
          if (typeof source !== "object") {
            throw new TypeError(source + "must be object");
          }
          Object.keys(source).forEach(function(key) {
            obj[key] = source[key];
          });
        });
        return obj;
      }
      function arrayReplaceAt2(src2, pos, newElements) {
        return [].concat(src2.slice(0, pos), newElements, src2.slice(pos + 1));
      }
      function isValidEntityCode2(c) {
        if (c >= 55296 && c <= 57343) {
          return false;
        }
        if (c >= 64976 && c <= 65007) {
          return false;
        }
        if ((c & 65535) === 65535 || (c & 65535) === 65534) {
          return false;
        }
        if (c >= 0 && c <= 8) {
          return false;
        }
        if (c === 11) {
          return false;
        }
        if (c >= 14 && c <= 31) {
          return false;
        }
        if (c >= 127 && c <= 159) {
          return false;
        }
        if (c > 1114111) {
          return false;
        }
        return true;
      }
      function fromCodePoint2(c) {
        if (c > 65535) {
          c -= 65536;
          var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        }
        return String.fromCharCode(c);
      }
      var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
      var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
      var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
      var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
      var entities2 = entitiesExports;
      function replaceEntityPattern(match, name) {
        var code2 = 0;
        if (has2(entities2, name)) {
          return entities2[name];
        }
        if (name.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name)) {
          code2 = name[1].toLowerCase() === "x" ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);
          if (isValidEntityCode2(code2)) {
            return fromCodePoint2(code2);
          }
        }
        return match;
      }
      function unescapeMd(str) {
        if (str.indexOf("\\") < 0) {
          return str;
        }
        return str.replace(UNESCAPE_MD_RE, "$1");
      }
      function unescapeAll2(str) {
        if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
          return str;
        }
        return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity2) {
          if (escaped) {
            return escaped;
          }
          return replaceEntityPattern(match, entity2);
        });
      }
      var HTML_ESCAPE_TEST_RE = /[&<>"]/;
      var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
      var HTML_REPLACEMENTS = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;"
      };
      function replaceUnsafeChar(ch) {
        return HTML_REPLACEMENTS[ch];
      }
      function escapeHtml2(str) {
        if (HTML_ESCAPE_TEST_RE.test(str)) {
          return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
        }
        return str;
      }
      var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
      function escapeRE2(str) {
        return str.replace(REGEXP_ESCAPE_RE, "\\$&");
      }
      function isSpace2(code2) {
        switch (code2) {
          case 9:
          case 32:
            return true;
        }
        return false;
      }
      function isWhiteSpace2(code2) {
        if (code2 >= 8192 && code2 <= 8202) {
          return true;
        }
        switch (code2) {
          case 9:
          case 10:
          case 11:
          case 12:
          case 13:
          case 32:
          case 160:
          case 5760:
          case 8239:
          case 8287:
          case 12288:
            return true;
        }
        return false;
      }
      var UNICODE_PUNCT_RE = regex$4;
      function isPunctChar2(ch) {
        return UNICODE_PUNCT_RE.test(ch);
      }
      function isMdAsciiPunct2(ch) {
        switch (ch) {
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38:
          case 39:
          case 40:
          case 41:
          case 42:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 58:
          case 59:
          case 60:
          case 61:
          case 62:
          case 63:
          case 64:
          case 91:
          case 92:
          case 93:
          case 94:
          case 95:
          case 96:
          case 123:
          case 124:
          case 125:
          case 126:
            return true;
          default:
            return false;
        }
      }
      function normalizeReference2(str) {
        str = str.trim().replace(/\s+/g, " ");
        if ("\u1E9E".toLowerCase() === "\u1E7E") {
          str = str.replace(//g, "\xDF");
        }
        return str.toLowerCase().toUpperCase();
      }
      exports2.lib = {};
      exports2.lib.mdurl = mdurl$1;
      exports2.lib.ucmicro = requireUc_micro();
      exports2.assign = assign2;
      exports2.isString = isString2;
      exports2.has = has2;
      exports2.unescapeMd = unescapeMd;
      exports2.unescapeAll = unescapeAll2;
      exports2.isValidEntityCode = isValidEntityCode2;
      exports2.fromCodePoint = fromCodePoint2;
      exports2.escapeHtml = escapeHtml2;
      exports2.arrayReplaceAt = arrayReplaceAt2;
      exports2.isSpace = isSpace2;
      exports2.isWhiteSpace = isWhiteSpace2;
      exports2.isMdAsciiPunct = isMdAsciiPunct2;
      exports2.isPunctChar = isPunctChar2;
      exports2.escapeRE = escapeRE2;
      exports2.normalizeReference = normalizeReference2;
    })(utils$1);
    var helpers$1 = {};
    var parse_link_label = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker2, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker2 = state.src.charCodeAt(state.pos);
        if (marker2 === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker2 === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
    var unescapeAll$2 = utils$1.unescapeAll;
    var parse_link_destination = function parseLinkDestination(str, pos, max) {
      var code2, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code2 = str.charCodeAt(pos);
          if (code2 === 10) {
            return result;
          }
          if (code2 === 60) {
            return result;
          }
          if (code2 === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll$2(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code2 === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === 32) {
          break;
        }
        if (code2 < 32 || code2 === 127) {
          break;
        }
        if (code2 === 92 && pos + 1 < max) {
          if (str.charCodeAt(pos + 1) === 32) {
            break;
          }
          pos += 2;
          continue;
        }
        if (code2 === 40) {
          level++;
          if (level > 32) {
            return result;
          }
        }
        if (code2 === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll$2(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
    var unescapeAll$1 = utils$1.unescapeAll;
    var parse_link_title = function parseLinkTitle(str, pos, max) {
      var code2, marker2, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker2 = str.charCodeAt(pos);
      if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
        return result;
      }
      pos++;
      if (marker2 === 40) {
        marker2 = 41;
      }
      while (pos < max) {
        code2 = str.charCodeAt(pos);
        if (code2 === marker2) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll$1(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code2 === 40 && marker2 === 41) {
          return result;
        } else if (code2 === 10) {
          lines++;
        } else if (code2 === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
    helpers$1.parseLinkLabel = parse_link_label;
    helpers$1.parseLinkDestination = parse_link_destination;
    helpers$1.parseLinkTitle = parse_link_title;
    var assign$1 = utils$1.assign;
    var unescapeAll = utils$1.unescapeAll;
    var escapeHtml = utils$1.escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options2, env, slf) {
      var token2 = tokens[idx];
      return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options2, env, slf) {
      var token2 = tokens[idx];
      return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options2, env, slf) {
      var token2 = tokens[idx], info = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i2, arr, tmpAttrs, tmpToken;
      if (info) {
        arr = info.split(/(\s+)/g);
        langName = arr[0];
        langAttrs = arr.slice(2).join("");
      }
      if (options2.highlight) {
        highlighted = options2.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
      } else {
        highlighted = escapeHtml(token2.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i2 = token2.attrIndex("class");
        tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
        if (i2 < 0) {
          tmpAttrs.push(["class", options2.langPrefix + langName]);
        } else {
          tmpAttrs[i2] = tmpAttrs[i2].slice();
          tmpAttrs[i2][1] += " " + options2.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options2, env, slf) {
      var token2 = tokens[idx];
      token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options2, env);
      return slf.renderToken(tokens, idx, options2);
    };
    default_rules.hardbreak = function(tokens, idx, options2) {
      return options2.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options2) {
      return options2.breaks ? options2.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer$1() {
      this.rules = assign$1({}, default_rules);
    }
    Renderer$1.prototype.renderAttrs = function renderAttrs(token2) {
      var i2, l, result;
      if (!token2.attrs) {
        return "";
      }
      result = "";
      for (i2 = 0, l = token2.attrs.length; i2 < l; i2++) {
        result += " " + escapeHtml(token2.attrs[i2][0]) + '="' + escapeHtml(token2.attrs[i2][1]) + '"';
      }
      return result;
    };
    Renderer$1.prototype.renderToken = function renderToken(tokens, idx, options2) {
      var nextToken, result = "", needLf = false, token2 = tokens[idx];
      if (token2.hidden) {
        return "";
      }
      if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
      result += this.renderAttrs(token2);
      if (token2.nesting === 0 && options2.xhtmlOut) {
        result += " /";
      }
      if (token2.block) {
        needLf = true;
        if (token2.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer$1.prototype.renderInline = function(tokens, options2, env) {
      var type, result = "", rules = this.rules;
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (typeof rules[type] !== "undefined") {
          result += rules[type](tokens, i2, options2, env, this);
        } else {
          result += this.renderToken(tokens, i2, options2);
        }
      }
      return result;
    };
    Renderer$1.prototype.renderInlineAsText = function(tokens, options2, env) {
      var result = "";
      for (var i2 = 0, len = tokens.length; i2 < len; i2++) {
        if (tokens[i2].type === "text") {
          result += tokens[i2].content;
        } else if (tokens[i2].type === "image") {
          result += this.renderInlineAsText(tokens[i2].children, options2, env);
        } else if (tokens[i2].type === "softbreak") {
          result += "\n";
        }
      }
      return result;
    };
    Renderer$1.prototype.render = function(tokens, options2, env) {
      var i2, len, type, result = "", rules = this.rules;
      for (i2 = 0, len = tokens.length; i2 < len; i2++) {
        type = tokens[i2].type;
        if (type === "inline") {
          result += this.renderInline(tokens[i2].children, options2, env);
        } else if (typeof rules[type] !== "undefined") {
          result += rules[tokens[i2].type](tokens, i2, options2, env, this);
        } else {
          result += this.renderToken(tokens, i2, options2, env);
        }
      }
      return result;
    };
    var renderer = Renderer$1;
    function Ruler$3() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler$3.prototype.__find__ = function(name) {
      for (var i2 = 0; i2 < this.__rules__.length; i2++) {
        if (this.__rules__[i2].name === name) {
          return i2;
        }
      }
      return -1;
    };
    Ruler$3.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler$3.prototype.at = function(name, fn, options2) {
      var index = this.__find__(name);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt.alt || [];
      this.__cache__ = null;
    };
    Ruler$3.prototype.before = function(beforeName, ruleName, fn, options2) {
      var index = this.__find__(beforeName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.after = function(afterName, ruleName, fn, options2) {
      var index = this.__find__(afterName);
      var opt = options2 || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.push = function(ruleName, fn, options2) {
      var opt = options2 || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt.alt || []
      });
      this.__cache__ = null;
    };
    Ruler$3.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = true;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler$3.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name) {
        var idx = this.__find__(name);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name);
        }
        this.__rules__[idx].enabled = false;
        result.push(name);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler$3.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    var ruler = Ruler$3;
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    var normalize = function normalize2(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
    var block = function block2(state) {
      var token2;
      if (state.inlineMode) {
        token2 = new state.Token("inline", "", 0);
        token2.content = state.src;
        token2.map = [0, 1];
        token2.children = [];
        state.tokens.push(token2);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
    var inline = function inline2(state) {
      var tokens = state.tokens, tok, i2, l;
      for (i2 = 0, l = tokens.length; i2 < l; i2++) {
        tok = tokens[i2];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
    var arrayReplaceAt = utils$1.arrayReplaceAt;
    function isLinkOpen$1(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose$1(str) {
      return /^<\/a\s*>/i.test(str);
    }
    var linkify$1 = function linkify2(state) {
      var i2, j, l, tokens, token2, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i2 = tokens.length - 1; i2 >= 0; i2--) {
          currentToken = tokens[i2];
          if (currentToken.type === "link_close") {
            i2--;
            while (tokens[i2].level !== currentToken.level && tokens[i2].type !== "link_open") {
              i2--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen$1(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose$1(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            if (links.length > 0 && links[0].index === 0 && i2 > 0 && tokens[i2 - 1].type === "text_special") {
              links = links.slice(1);
            }
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token2 = new state.Token("text", "", 0);
                token2.content = text2.slice(lastPos, pos);
                token2.level = level;
                nodes.push(token2);
              }
              token2 = new state.Token("link_open", "a", 1);
              token2.attrs = [["href", fullUrl]];
              token2.level = level++;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              token2 = new state.Token("text", "", 0);
              token2.content = urlText;
              token2.level = level;
              nodes.push(token2);
              token2 = new state.Token("link_close", "a", -1);
              token2.level = --level;
              token2.markup = "linkify";
              token2.info = "auto";
              nodes.push(token2);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token2 = new state.Token("text", "", 0);
              token2.content = text2.slice(lastPos);
              token2.level = level;
              nodes.push(token2);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i2, nodes);
          }
        }
      }
    };
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      tm: "\u2122"
    };
    function replaceFn(match, name) {
      return SCOPED_ABBR[name.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i2, token2, inside_autolink = 0;
      for (i2 = inlineTokens.length - 1; i2 >= 0; i2--) {
        token2 = inlineTokens[i2];
        if (token2.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token2.content)) {
            token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
          }
        }
        if (token2.type === "link_open" && token2.info === "auto") {
          inside_autolink--;
        }
        if (token2.type === "link_close" && token2.info === "auto") {
          inside_autolink++;
        }
      }
    }
    var replacements = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
    var isWhiteSpace$1 = utils$1.isWhiteSpace;
    var isPunctChar$1 = utils$1.isPunctChar;
    var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.slice(0, index) + ch + str.slice(index + 1);
    }
    function process_inlines(tokens, state) {
      var i2, token2, text2, t, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i2 = 0; i2 < tokens.length; i2++) {
        token2 = tokens[i2];
        thisLevel = tokens[i2].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token2.type !== "text") {
          continue;
        }
        text2 = token2.content;
        pos = 0;
        max = text2.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t = QUOTE_RE.exec(text2);
            if (!t) {
              break;
            }
            canOpen = canClose = true;
            pos = t.index + 1;
            isSingle = t[0] === "'";
            lastChar = 32;
            if (t.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t.index - 1);
            } else {
              for (j = i2 - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i2 + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (!tokens[j].content)
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace$1(lastChar);
            isNextWhiteSpace = isWhiteSpace$1(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = isLastPunctChar;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token2.content = replaceAt(token2.content, t.index, closeQuote);
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item.token === i2) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token2.content;
                  max = text2.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i2,
                pos: t.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token2.content = replaceAt(token2.content, t.index, APOSTROPHE);
            }
          }
      }
    }
    var smartquotes = function smartquotes2(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
    var text_join = function text_join2(state) {
      var j, l, tokens, curr, max, last, blockTokens = state.tokens;
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline")
          continue;
        tokens = blockTokens[j].children;
        max = tokens.length;
        for (curr = 0; curr < max; curr++) {
          if (tokens[curr].type === "text_special") {
            tokens[curr].type = "text";
          }
        }
        for (curr = last = 0; curr < max; curr++) {
          if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
            tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
          } else {
            if (curr !== last) {
              tokens[last] = tokens[curr];
            }
            last++;
          }
        }
        if (curr !== last) {
          tokens.length = last;
        }
      }
    };
    function Token$3(type, tag, nesting) {
      this.type = type;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token$3.prototype.attrIndex = function attrIndex(name) {
      var attrs, i2, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i2 = 0, len = attrs.length; i2 < len; i2++) {
        if (attrs[i2][0] === name) {
          return i2;
        }
      }
      return -1;
    };
    Token$3.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token$3.prototype.attrSet = function attrSet(name, value) {
      var idx = this.attrIndex(name), attrData = [name, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token$3.prototype.attrGet = function attrGet(name) {
      var idx = this.attrIndex(name), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token$3.prototype.attrJoin = function attrJoin(name, value) {
      var idx = this.attrIndex(name);
      if (idx < 0) {
        this.attrPush([name, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    var token = Token$3;
    var Token$2 = token;
    function StateCore(src2, md, env) {
      this.src = src2;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md;
    }
    StateCore.prototype.Token = Token$2;
    var state_core = StateCore;
    var Ruler$2 = ruler;
    var _rules$2 = [
      ["normalize", normalize],
      ["block", block],
      ["inline", inline],
      ["linkify", linkify$1],
      ["replacements", replacements],
      ["smartquotes", smartquotes],
      ["text_join", text_join]
    ];
    function Core() {
      this.ruler = new Ruler$2();
      for (var i2 = 0; i2 < _rules$2.length; i2++) {
        this.ruler.push(_rules$2[i2][0], _rules$2[i2][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i2, l, rules;
      rules = this.ruler.getRules("");
      for (i2 = 0, l = rules.length; i2 < l; i2++) {
        rules[i2](state);
      }
    };
    Core.prototype.State = state_core;
    var parser_core = Core;
    var isSpace$a = utils$1.isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.tShift[line], max = state.eMarks[line];
      return state.src.slice(pos, max);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 124) {
          if (!isEscaped) {
            result.push(current + str.substring(lastPos, pos));
            current = "";
            lastPos = pos + 1;
          } else {
            current += str.substring(lastPos, pos - 1);
            lastPos = pos;
          }
        }
        isEscaped = ch === 92;
        pos++;
        ch = str.charCodeAt(pos);
      }
      result.push(current + str.substring(lastPos));
      return result;
    }
    var table = function table2(state, startLine, endLine, silent) {
      var ch, lineText, pos, i2, l, nextLine, columns, columnCount, token2, aligns, t, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      firstCh = state.src.charCodeAt(pos++);
      if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
        return false;
      }
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      secondCh = state.src.charCodeAt(pos++);
      if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
        return false;
      }
      if (firstCh === 45 && isSpace$a(secondCh)) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i2 = 0; i2 < columns.length; i2++) {
        t = columns[i2].trim();
        if (!t) {
          if (i2 === 0 || i2 === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t)) {
          return false;
        }
        if (t.charCodeAt(t.length - 1) === 58) {
          aligns.push(t.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText);
      if (columns.length && columns[0] === "")
        columns.shift();
      if (columns.length && columns[columns.length - 1] === "")
        columns.pop();
      columnCount = columns.length;
      if (columnCount === 0 || columnCount !== aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      oldParentType = state.parentType;
      state.parentType = "table";
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      token2 = state.push("table_open", "table", 1);
      token2.map = tableLines = [startLine, 0];
      token2 = state.push("thead_open", "thead", 1);
      token2.map = [startLine, startLine + 1];
      token2 = state.push("tr_open", "tr", 1);
      token2.map = [startLine, startLine + 1];
      for (i2 = 0; i2 < columns.length; i2++) {
        token2 = state.push("th_open", "th", 1);
        if (aligns[i2]) {
          token2.attrs = [["style", "text-align:" + aligns[i2]]];
        }
        token2 = state.push("inline", "", 0);
        token2.content = columns[i2].trim();
        token2.children = [];
        token2 = state.push("th_close", "th", -1);
      }
      token2 = state.push("tr_close", "tr", -1);
      token2 = state.push("thead_close", "thead", -1);
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (!lineText) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText);
        if (columns.length && columns[0] === "")
          columns.shift();
        if (columns.length && columns[columns.length - 1] === "")
          columns.pop();
        if (nextLine === startLine + 2) {
          token2 = state.push("tbody_open", "tbody", 1);
          token2.map = tbodyLines = [startLine + 2, 0];
        }
        token2 = state.push("tr_open", "tr", 1);
        token2.map = [nextLine, nextLine + 1];
        for (i2 = 0; i2 < columnCount; i2++) {
          token2 = state.push("td_open", "td", 1);
          if (aligns[i2]) {
            token2.attrs = [["style", "text-align:" + aligns[i2]]];
          }
          token2 = state.push("inline", "", 0);
          token2.content = columns[i2] ? columns[i2].trim() : "";
          token2.children = [];
          token2 = state.push("td_close", "td", -1);
        }
        token2 = state.push("tr_close", "tr", -1);
      }
      if (tbodyLines) {
        token2 = state.push("tbody_close", "tbody", -1);
        tbodyLines[1] = nextLine;
      }
      token2 = state.push("table_close", "table", -1);
      tableLines[1] = nextLine;
      state.parentType = oldParentType;
      state.line = nextLine;
      return true;
    };
    var code = function code2(state, startLine, endLine) {
      var nextLine, last, token2;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token2 = state.push("code_block", "code", 0);
      token2.content = state.getLines(startLine, last, 4 + state.blkIndent, false) + "\n";
      token2.map = [startLine, state.line];
      return true;
    };
    var fence = function fence2(state, startLine, endLine, silent) {
      var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos);
      if (marker2 !== 126 && marker2 !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker2);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker2 === 96) {
        if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker2) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker2);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token2 = state.push("fence", "code", 0);
      token2.info = params;
      token2.content = state.getLines(startLine + 1, nextLine, len, true);
      token2.markup = markup;
      token2.map = [startLine, state.line];
      return true;
    };
    var isSpace$9 = utils$1.isSpace;
    var blockquote = function blockquote2(state, startLine, endLine, silent) {
      var adjustTab, ch, i2, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + 1;
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace$9(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        isOutdented = state.sCount[nextLine] < state.blkIndent;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !isOutdented) {
          initial = offset = state.sCount[nextLine] + 1;
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace$9(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token2 = state.push("blockquote_open", "blockquote", 1);
      token2.markup = ">";
      token2.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token2 = state.push("blockquote_close", "blockquote", -1);
      token2.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i2 = 0; i2 < oldTShift.length; i2++) {
        state.bMarks[i2 + startLine] = oldBMarks[i2];
        state.tShift[i2 + startLine] = oldTShift[i2];
        state.sCount[i2 + startLine] = oldSCount[i2];
        state.bsCount[i2 + startLine] = oldBSCount[i2];
      }
      state.blkIndent = oldIndent;
      return true;
    };
    var isSpace$8 = utils$1.isSpace;
    var hr = function hr2(state, startLine, endLine, silent) {
      var marker2, cnt, ch, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker2 && !isSpace$8(ch)) {
          return false;
        }
        if (ch === marker2) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token2 = state.push("hr", "hr", 0);
      token2.map = [startLine, state.line];
      token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
      return true;
    };
    var isSpace$7 = utils$1.isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker2, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker2 = state.src.charCodeAt(pos++);
      if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace$7(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i2, l, level = state.level + 2;
      for (i2 = idx + 2, l = state.tokens.length - 2; i2 < l; i2++) {
        if (state.tokens[i2].level === level && state.tokens[i2].type === "paragraph_open") {
          state.tokens[i2 + 2].hidden = true;
          state.tokens[i2].hidden = true;
          i2 += 2;
        }
      }
    }
    var list = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i2, indent, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.sCount[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.slice(start, posAfterMarker - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token2 = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token2.attrs = [["start", markerValue]];
        }
      } else {
        token2 = state.push("bullet_list_open", "ul", 1);
      }
      token2.map = listLines = [startLine, 0];
      token2.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent = initial + indentAfterMarker;
        token2 = state.push("list_item_open", "li", 1);
        token2.markup = String.fromCharCode(markerCharCode);
        token2.map = itemLines = [startLine, 0];
        if (isOrdered) {
          token2.info = state.src.slice(start, posAfterMarker - 1);
        }
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token2 = state.push("list_item_close", "li", -1);
        token2.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
          start = state.bMarks[nextLine] + state.tShift[nextLine];
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token2 = state.push("ordered_list_close", "ol", -1);
      } else {
        token2 = state.push("bullet_list_close", "ul", -1);
      }
      token2.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
    var normalizeReference$2 = utils$1.normalizeReference;
    var isSpace$6 = utils$1.isSpace;
    var reference = function reference2(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i2, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace$6(ch))
          ;
        else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace$6(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference$2(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
    var html_blocks = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    var html_re = {};
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?][\\s\\S]*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    html_re.HTML_TAG_RE = HTML_TAG_RE$1;
    html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
    var block_names = html_blocks;
    var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    var html_block = function html_block2(state, startLine, endLine, silent) {
      var i2, nextLine, token2, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i2 = 0; i2 < HTML_SEQUENCES.length; i2++) {
        if (HTML_SEQUENCES[i2][0].test(lineText)) {
          break;
        }
      }
      if (i2 === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i2][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i2][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i2][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token2 = state.push("html_block", "", 0);
      token2.map = [startLine, nextLine];
      token2.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
    var isSpace$5 = utils$1.isSpace;
    var heading = function heading2(state, startLine, endLine, silent) {
      var ch, level, tmp, token2, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace$5(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace$5(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = "########".slice(0, level);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = state.src.slice(pos, max).trim();
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = "########".slice(0, level);
      return true;
    };
    var lheading = function lheading2(state, startLine, endLine) {
      var content, terminate, i2, l, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker2 = state.src.charCodeAt(pos);
            if (marker2 === 45 || marker2 === 61) {
              pos = state.skipChars(pos, marker2);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker2 === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token2 = state.push("heading_open", "h" + String(level), 1);
      token2.markup = String.fromCharCode(marker2);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content;
      token2.map = [startLine, state.line - 1];
      token2.children = [];
      token2 = state.push("heading_close", "h" + String(level), -1);
      token2.markup = String.fromCharCode(marker2);
      state.parentType = oldParentType;
      return true;
    };
    var paragraph = function paragraph2(state, startLine) {
      var content, terminate, i2, l, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i2 = 0, l = terminatorRules.length; i2 < l; i2++) {
          if (terminatorRules[i2](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token2 = state.push("paragraph_open", "p", 1);
      token2.map = [startLine, state.line];
      token2 = state.push("inline", "", 0);
      token2.content = content;
      token2.map = [startLine, state.line];
      token2.children = [];
      token2 = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
    var Token$1 = token;
    var isSpace$4 = utils$1.isSpace;
    function StateBlock(src2, md, env, tokens) {
      var ch, s, start, pos, len, indent, offset, indent_found;
      this.src = src2;
      this.md = md;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace$4(ch)) {
            indent++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type, tag, nesting) {
      var token2 = new Token$1(type, tag, nesting);
      token2.block = true;
      if (nesting < 0)
        this.level--;
      token2.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token2);
      return token2;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace$4(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace$4(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code2) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code2) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code2, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code2 !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {
      var i2, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i2 = 0; line < end; line++, i2++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent) {
          ch = this.src.charCodeAt(first);
          if (isSpace$4(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent) {
          queue[i2] = new Array(lineIndent - indent + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i2] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token$1;
    var state_block = StateBlock;
    var Ruler$1 = ruler;
    var _rules$1 = [
      ["table", table, ["paragraph", "reference"]],
      ["code", code],
      ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
      ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
      ["list", list, ["paragraph", "reference", "blockquote"]],
      ["reference", reference],
      ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
      ["heading", heading, ["paragraph", "reference", "blockquote"]],
      ["lheading", lheading],
      ["paragraph", paragraph]
    ];
    function ParserBlock$1() {
      this.ruler = new Ruler$1();
      for (var i2 = 0; i2 < _rules$1.length; i2++) {
        this.ruler.push(_rules$1[i2][0], _rules$1[i2][1], { alt: (_rules$1[i2][2] || []).slice() });
      }
    }
    ParserBlock$1.prototype.tokenize = function(state, startLine, endLine) {
      var ok2, i2, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i2 = 0; i2 < len; i2++) {
          ok2 = rules[i2](state, line, endLine, false);
          if (ok2) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock$1.prototype.parse = function(src2, md, env, outTokens) {
      var state;
      if (!src2) {
        return;
      }
      state = new this.State(src2, md, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock$1.prototype.State = state_block;
    var parser_block = ParserBlock$1;
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    var text = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
    var SCHEME_RE = /(?:^|[^a-z0-9.+-])([a-z][a-z0-9.+-]*)$/i;
    var linkify = function linkify2(state, silent) {
      var pos, max, match, proto, link2, url, fullUrl, token2;
      if (!state.md.options.linkify)
        return false;
      if (state.linkLevel > 0)
        return false;
      pos = state.pos;
      max = state.posMax;
      if (pos + 3 > max)
        return false;
      if (state.src.charCodeAt(pos) !== 58)
        return false;
      if (state.src.charCodeAt(pos + 1) !== 47)
        return false;
      if (state.src.charCodeAt(pos + 2) !== 47)
        return false;
      match = state.pending.match(SCHEME_RE);
      if (!match)
        return false;
      proto = match[1];
      link2 = state.md.linkify.matchAtStart(state.src.slice(pos - proto.length));
      if (!link2)
        return false;
      url = link2.url;
      url = url.replace(/\*+$/, "");
      fullUrl = state.md.normalizeLink(url);
      if (!state.md.validateLink(fullUrl))
        return false;
      if (!silent) {
        state.pending = state.pending.slice(0, -proto.length);
        token2 = state.push("link_open", "a", 1);
        token2.attrs = [["href", fullUrl]];
        token2.markup = "linkify";
        token2.info = "auto";
        token2 = state.push("text", "", 0);
        token2.content = state.md.normalizeLinkText(url);
        token2 = state.push("link_close", "a", -1);
        token2.markup = "linkify";
        token2.info = "auto";
      }
      state.pos += url.length - proto.length;
      return true;
    };
    var isSpace$3 = utils$1.isSpace;
    var newline = function newline2(state, silent) {
      var pmax, max, ws, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            ws = pmax - 1;
            while (ws >= 1 && state.pending.charCodeAt(ws - 1) === 32)
              ws--;
            state.pending = state.pending.slice(0, ws);
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace$3(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
    var isSpace$2 = utils$1.isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    var _escape = function escape(state, silent) {
      var ch1, ch2, origStr, escapedStr, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92)
        return false;
      pos++;
      if (pos >= max)
        return false;
      ch1 = state.src.charCodeAt(pos);
      if (ch1 === 10) {
        if (!silent) {
          state.push("hardbreak", "br", 0);
        }
        pos++;
        while (pos < max) {
          ch1 = state.src.charCodeAt(pos);
          if (!isSpace$2(ch1))
            break;
          pos++;
        }
        state.pos = pos;
        return true;
      }
      escapedStr = state.src[pos];
      if (ch1 >= 55296 && ch1 <= 56319 && pos + 1 < max) {
        ch2 = state.src.charCodeAt(pos + 1);
        if (ch2 >= 56320 && ch2 <= 57343) {
          escapedStr += state.src[pos + 1];
          pos++;
        }
      }
      origStr = "\\" + escapedStr;
      if (!silent) {
        token2 = state.push("text_special", "", 0);
        if (ch1 < 256 && ESCAPED[ch1] !== 0) {
          token2.content = escapedStr;
        } else {
          token2.content = origStr;
        }
        token2.markup = origStr;
        token2.info = "escape";
      }
      state.pos = pos + 1;
      return true;
    };
    var backticks = function backtick(state, silent) {
      var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker2 = state.src.slice(start, pos);
      openerLength = marker2.length;
      if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {
        if (!silent)
          state.pending += marker2;
        state.pos += openerLength;
        return true;
      }
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        closerLength = matchEnd - matchStart;
        if (closerLength === openerLength) {
          if (!silent) {
            token2 = state.push("code_inline", "code", 0);
            token2.markup = marker2;
            token2.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
        state.backticks[closerLength] = matchStart;
      }
      state.backticksScanned = true;
      if (!silent)
        state.pending += marker2;
      state.pos += openerLength;
      return true;
    };
    var strikethrough = {};
    strikethrough.tokenize = function strikethrough2(state, silent) {
      var i2, scanned, token2, len, ch, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker2);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch;
        len--;
      }
      for (i2 = 0; i2 < len; i2 += 2) {
        token2 = state.push("text", "", 0);
        token2.content = ch + ch;
        state.delimiters.push({
          marker: marker2,
          length: 0,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess$1(state, delimiters) {
      var i2, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
      for (i2 = 0; i2 < max; i2++) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token2 = state.tokens[startDelim.token];
        token2.type = "s_open";
        token2.tag = "s";
        token2.nesting = 1;
        token2.markup = "~~";
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = "s_close";
        token2.tag = "s";
        token2.nesting = -1;
        token2.markup = "~~";
        token2.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i2 = loneMarkers.pop();
        j = i2 + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i2 !== j) {
          token2 = state.tokens[j];
          state.tokens[j] = state.tokens[i2];
          state.tokens[i2] = token2;
        }
      }
    }
    strikethrough.postProcess = function strikethrough2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess$1(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess$1(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var emphasis = {};
    emphasis.tokenize = function emphasis2(state, silent) {
      var i2, scanned, token2, start = state.pos, marker2 = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker2 !== 95 && marker2 !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker2 === 42);
      for (i2 = 0; i2 < scanned.length; i2++) {
        token2 = state.push("text", "", 0);
        token2.content = String.fromCharCode(marker2);
        state.delimiters.push({
          marker: marker2,
          length: scanned.length,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i2, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
      for (i2 = max - 1; i2 >= 0; i2--) {
        startDelim = delimiters[i2];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i2 > 0 && delimiters[i2 - 1].end === startDelim.end + 1 && delimiters[i2 - 1].marker === startDelim.marker && delimiters[i2 - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1;
        ch = String.fromCharCode(startDelim.marker);
        token2 = state.tokens[startDelim.token];
        token2.type = isStrong ? "strong_open" : "em_open";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = 1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        token2 = state.tokens[endDelim.token];
        token2.type = isStrong ? "strong_close" : "em_close";
        token2.tag = isStrong ? "strong" : "em";
        token2.nesting = -1;
        token2.markup = isStrong ? ch + ch : ch;
        token2.content = "";
        if (isStrong) {
          state.tokens[delimiters[i2 - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i2--;
        }
      }
    }
    emphasis.postProcess = function emphasis2(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var normalizeReference$1 = utils$1.normalizeReference;
    var isSpace$1 = utils$1.isSpace;
    var link = function link2(state, silent) {
      var attrs, code2, label, labelEnd, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace$1(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
          start = pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace$1(code2) && code2 !== 10) {
              break;
            }
          }
          res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
          if (pos < max && start !== pos && res.ok) {
            title = res.str;
            pos = res.pos;
            for (; pos < max; pos++) {
              code2 = state.src.charCodeAt(pos);
              if (!isSpace$1(code2) && code2 !== 10) {
                break;
              }
            }
          }
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference$1(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token2 = state.push("link_open", "a", 1);
        token2.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.linkLevel++;
        state.md.inline.tokenize(state);
        state.linkLevel--;
        token2 = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var normalizeReference = utils$1.normalizeReference;
    var isSpace = utils$1.isSpace;
    var image = function image2(state, silent) {
      var attrs, code2, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code2 = state.src.charCodeAt(pos);
          if (!isSpace(code2) && code2 !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code2 = state.src.charCodeAt(pos);
            if (!isSpace(code2) && code2 !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        token2 = state.push("image", "img", 0);
        token2.attrs = attrs = [["src", href], ["alt", ""]];
        token2.children = tokens;
        token2.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
    var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
    var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
    var autolink = function autolink2(state, silent) {
      var url, fullUrl, token2, ch, start, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      start = state.pos;
      max = state.posMax;
      for (; ; ) {
        if (++pos >= max)
          return false;
        ch = state.src.charCodeAt(pos);
        if (ch === 60)
          return false;
        if (ch === 62)
          break;
      }
      url = state.src.slice(start + 1, pos);
      if (AUTOLINK_RE.test(url)) {
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      if (EMAIL_RE.test(url)) {
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token2 = state.push("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.markup = "autolink";
          token2.info = "auto";
          token2 = state.push("text", "", 0);
          token2.content = state.md.normalizeLinkText(url);
          token2 = state.push("link_close", "a", -1);
          token2.markup = "autolink";
          token2.info = "auto";
        }
        state.pos += url.length + 2;
        return true;
      }
      return false;
    };
    var HTML_TAG_RE = html_re.HTML_TAG_RE;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    var html_inline = function html_inline2(state, silent) {
      var ch, match, max, token2, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token2 = state.push("html_inline", "", 0);
        token2.content = state.src.slice(pos, pos + match[0].length);
        if (isLinkOpen(token2.content))
          state.linkLevel++;
        if (isLinkClose(token2.content))
          state.linkLevel--;
      }
      state.pos += match[0].length;
      return true;
    };
    var entities = entitiesExports;
    var has = utils$1.has;
    var isValidEntityCode = utils$1.isValidEntityCode;
    var fromCodePoint = utils$1.fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    var entity = function entity2(state, silent) {
      var ch, code2, match, token2, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38)
        return false;
      if (pos + 1 >= max)
        return false;
      ch = state.src.charCodeAt(pos + 1);
      if (ch === 35) {
        match = state.src.slice(pos).match(DIGITAL_RE);
        if (match) {
          if (!silent) {
            code2 = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
            token2 = state.push("text_special", "", 0);
            token2.content = isValidEntityCode(code2) ? fromCodePoint(code2) : fromCodePoint(65533);
            token2.markup = match[0];
            token2.info = "entity";
          }
          state.pos += match[0].length;
          return true;
        }
      } else {
        match = state.src.slice(pos).match(NAMED_RE);
        if (match) {
          if (has(entities, match[1])) {
            if (!silent) {
              token2 = state.push("text_special", "", 0);
              token2.content = entities[match[1]];
              token2.markup = match[0];
              token2.info = "entity";
            }
            state.pos += match[0].length;
            return true;
          }
        }
      }
      return false;
    };
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      if (!max)
        return;
      var headerIdx = 0;
      var lastTokenIdx = -2;
      var jumps = [];
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        jumps.push(0);
        if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {
          headerIdx = closerIdx;
        }
        lastTokenIdx = closer.token;
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
        openerIdx = headerIdx - jumps[headerIdx] - 1;
        newMinOpenerIdx = openerIdx;
        for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (opener.open && opener.end < 0) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;
              jumps[closerIdx] = closerIdx - openerIdx + lastJump;
              jumps[openerIdx] = lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.close = false;
              newMinOpenerIdx = -1;
              lastTokenIdx = -2;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    var balance_pairs = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
    var fragments_join = function fragments_join2(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
    var Token = token;
    var isWhiteSpace = utils$1.isWhiteSpace;
    var isPunctChar = utils$1.isPunctChar;
    var isMdAsciiPunct = utils$1.isMdAsciiPunct;
    function StateInline(src2, md, env, outTokens) {
      this.src = src2;
      this.env = env;
      this.md = md;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
      this.backticks = {};
      this.backticksScanned = false;
      this.linkLevel = 0;
    }
    StateInline.prototype.pushPending = function() {
      var token2 = new Token("text", "", 0);
      token2.content = this.pending;
      token2.level = this.pendingLevel;
      this.tokens.push(token2);
      this.pending = "";
      return token2;
    };
    StateInline.prototype.push = function(type, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token2 = new Token(type, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token2.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token2);
      this.tokens_meta.push(token_meta);
      return token2;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker2) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token;
    var state_inline = StateInline;
    var Ruler = ruler;
    var _rules = [
      ["text", text],
      ["linkify", linkify],
      ["newline", newline],
      ["escape", _escape],
      ["backticks", backticks],
      ["strikethrough", strikethrough.tokenize],
      ["emphasis", emphasis.tokenize],
      ["link", link],
      ["image", image],
      ["autolink", autolink],
      ["html_inline", html_inline],
      ["entity", entity]
    ];
    var _rules2 = [
      ["balance_pairs", balance_pairs],
      ["strikethrough", strikethrough.postProcess],
      ["emphasis", emphasis.postProcess],
      ["fragments_join", fragments_join]
    ];
    function ParserInline$1() {
      var i2;
      this.ruler = new Ruler();
      for (i2 = 0; i2 < _rules.length; i2++) {
        this.ruler.push(_rules[i2][0], _rules[i2][1]);
      }
      this.ruler2 = new Ruler();
      for (i2 = 0; i2 < _rules2.length; i2++) {
        this.ruler2.push(_rules2[i2][0], _rules2[i2][1]);
      }
    }
    ParserInline$1.prototype.skipToken = function(state) {
      var ok2, i2, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i2 = 0; i2 < len; i2++) {
          state.level++;
          ok2 = rules[i2](state, true);
          state.level--;
          if (ok2) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok2) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline$1.prototype.tokenize = function(state) {
      var ok2, i2, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i2 = 0; i2 < len; i2++) {
            ok2 = rules[i2](state, false);
            if (ok2) {
              break;
            }
          }
        }
        if (ok2) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
      var i2, rules, len;
      var state = new this.State(str, md, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i2 = 0; i2 < len; i2++) {
        rules[i2](state);
      }
    };
    ParserInline$1.prototype.State = state_inline;
    var parser_inline = ParserInline$1;
    var re;
    var hasRequiredRe;
    function requireRe() {
      if (hasRequiredRe)
        return re;
      hasRequiredRe = 1;
      re = function(opts) {
        var re2 = {};
        opts = opts || {};
        re2.src_Any = requireRegex$3().source;
        re2.src_Cc = requireRegex$2().source;
        re2.src_Z = requireRegex().source;
        re2.src_P = regex$4.source;
        re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
        re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
        var text_separators = "[><\uFF5C]";
        re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
        re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
        re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
        re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
        re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!" + (opts["---"] ? "-(?!--)|" : "-|") + "_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
        re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-])|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]|$)|" + (opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + "|$)|;(?!" + re2.src_ZCc + "|$)|\\!+(?!" + re2.src_ZCc + "|[!]|$)|\\?(?!" + re2.src_ZCc + "|[?]|$))+|\\/)?";
        re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
        re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
        re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
        re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
        re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
        re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
        re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
        re2.src_host_strict = re2.src_host + re2.src_host_terminator;
        re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
        re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
        re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
        re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
        re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
        re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
        return re2;
      };
      return re;
    }
    function assign(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re2) {
      return function(text2, pos) {
        var tail = text2.slice(pos);
        if (re2.test(tail)) {
          return tail.match(re2)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re2 = self2.re = requireRe()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re2.src_xn);
      re2.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re2.src_tlds);
      }
      re2.email_fuzzy = RegExp(untpl(re2.tpl_email_fuzzy), "i");
      re2.link_fuzzy = RegExp(untpl(re2.tpl_link_fuzzy), "i");
      re2.link_no_ip_fuzzy = RegExp(untpl(re2.tpl_link_no_ip_fuzzy), "i");
      re2.host_fuzzy_test = RegExp(untpl(re2.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name) {
        var val = self2.__schemas__[name];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name);
          return;
        }
        schemaError(name, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name) {
        return name.length > 0 && self2.__compiled__[name];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re2.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.schema_at_start = RegExp("^" + self2.re.schema_search.source, "i");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text2 = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt$1(schemas, options2) {
      if (!(this instanceof LinkifyIt$1)) {
        return new LinkifyIt$1(schemas, options2);
      }
      if (!options2) {
        if (isOptionsObj(schemas)) {
          options2 = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign({}, defaultOptions, options2);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt$1.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt$1.prototype.set = function set(options2) {
      this.__opts__ = assign(this.__opts__, options2);
      return this;
    };
    LinkifyIt$1.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re2, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re2 = this.re.schema_search;
        re2.lastIndex = 0;
        while ((m = re2.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re2.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt$1.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt$1.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt$1.prototype.match = function match(text2) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt$1.prototype.matchAtStart = function matchAtStart(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length)
        return null;
      var m = this.re.schema_at_start.exec(text2);
      if (!m)
        return null;
      var len = this.testSchemaAt(text2, m[2], m[0].length);
      if (!len)
        return null;
      this.__schema__ = m[2];
      this.__index__ = m.index + m[1].length;
      this.__last_index__ = m.index + m[0].length + len;
      return createMatch(this, 0);
    };
    LinkifyIt$1.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el2, idx, arr) {
        return el2 !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt$1.prototype.normalize = function normalize2(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt$1.prototype.onCompile = function onCompile() {
    };
    var linkifyIt = LinkifyIt$1;
    var _default = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
    var zero = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "fragments_join"
          ]
        }
      }
    };
    var commonmark = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline",
            "text_join"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "fragments_join"
          ]
        }
      }
    };
    var utils = utils$1;
    var helpers = helpers$1;
    var Renderer = renderer;
    var ParserCore = parser_core;
    var ParserBlock = parser_block;
    var ParserInline = parser_inline;
    var LinkifyIt = linkifyIt;
    var mdurl = mdurl$1;
    var punycode = require$$8;
    var config = {
      default: _default,
      zero,
      commonmark
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
    }
    function MarkdownIt(presetName, options2) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options2);
      }
      if (!options2) {
        if (!utils.isString(presetName)) {
          options2 = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options2) {
        this.set(options2);
      }
    }
    MarkdownIt.prototype.set = function(options2) {
      utils.assign(this.options, options2);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name) {
          if (presets.components[name].rules) {
            self2[name].ruler.enableOnly(presets.components[name].rules);
          }
          if (presets.components[name].rules2) {
            self2[name].ruler2.enableOnly(presets.components[name].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name) {
        return result.indexOf(name) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt.prototype.parse = function(src2, env) {
      if (typeof src2 !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src2, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src2, env) {
      env = env || {};
      return this.renderer.render(this.parse(src2, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src2, env) {
      var state = new this.core.State(src2, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src2, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src2, env), this.options, env);
    };
    var lib$1 = MarkdownIt;
    (function(module3) {
      module3.exports = lib$1;
    })(markdownIt);
    var MDLib = getDefaultExportFromCjs(markdownItExports);
    var underscoreUmdExports = {};
    var underscoreUmd = {
      get exports() {
        return underscoreUmdExports;
      },
      set exports(v) {
        underscoreUmdExports = v;
      }
    };
    (function(module3, exports2) {
      (function(global2, factory) {
        module3.exports = factory();
      })(commonjsGlobal, function() {
        var VERSION = "1.13.6";
        var root = typeof self == "object" && self.self === self && self || typeof commonjsGlobal == "object" && commonjsGlobal.global === commonjsGlobal && commonjsGlobal || Function("return this")() || {};
        var ArrayProto = Array.prototype, ObjProto = Object.prototype;
        var SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
        var push = ArrayProto.push, slice2 = ArrayProto.slice, toString = ObjProto.toString, hasOwnProperty = ObjProto.hasOwnProperty;
        var supportsArrayBuffer = typeof ArrayBuffer !== "undefined", supportsDataView = typeof DataView !== "undefined";
        var nativeIsArray = Array.isArray, nativeKeys = Object.keys, nativeCreate = Object.create, nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
        var _isNaN = isNaN, _isFinite = isFinite;
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
        var nonEnumerableProps = [
          "valueOf",
          "isPrototypeOf",
          "toString",
          "propertyIsEnumerable",
          "hasOwnProperty",
          "toLocaleString"
        ];
        var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
        function restArguments(func, startIndex) {
          startIndex = startIndex == null ? func.length - 1 : +startIndex;
          return function() {
            var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
            for (; index < length; index++) {
              rest2[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
              case 0:
                return func.call(this, rest2);
              case 1:
                return func.call(this, arguments[0], rest2);
              case 2:
                return func.call(this, arguments[0], arguments[1], rest2);
            }
            var args = Array(startIndex + 1);
            for (index = 0; index < startIndex; index++) {
              args[index] = arguments[index];
            }
            args[startIndex] = rest2;
            return func.apply(this, args);
          };
        }
        function isObject2(obj) {
          var type = typeof obj;
          return type === "function" || type === "object" && !!obj;
        }
        function isNull(obj) {
          return obj === null;
        }
        function isUndefined(obj) {
          return obj === void 0;
        }
        function isBoolean(obj) {
          return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
        }
        function isElement(obj) {
          return !!(obj && obj.nodeType === 1);
        }
        function tagTester(name) {
          var tag = "[object " + name + "]";
          return function(obj) {
            return toString.call(obj) === tag;
          };
        }
        var isString2 = tagTester("String");
        var isNumber = tagTester("Number");
        var isDate = tagTester("Date");
        var isRegExp2 = tagTester("RegExp");
        var isError = tagTester("Error");
        var isSymbol = tagTester("Symbol");
        var isArrayBuffer = tagTester("ArrayBuffer");
        var isFunction2 = tagTester("Function");
        var nodelist = root.document && root.document.childNodes;
        if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
          isFunction2 = function(obj) {
            return typeof obj == "function" || false;
          };
        }
        var isFunction$1 = isFunction2;
        var hasObjectTag = tagTester("Object");
        var hasStringTagBug = supportsDataView && hasObjectTag(new DataView(new ArrayBuffer(8))), isIE11 = typeof Map !== "undefined" && hasObjectTag(/* @__PURE__ */ new Map());
        var isDataView = tagTester("DataView");
        function ie10IsDataView(obj) {
          return obj != null && isFunction$1(obj.getInt8) && isArrayBuffer(obj.buffer);
        }
        var isDataView$1 = hasStringTagBug ? ie10IsDataView : isDataView;
        var isArray = nativeIsArray || tagTester("Array");
        function has$1(obj, key) {
          return obj != null && hasOwnProperty.call(obj, key);
        }
        var isArguments = tagTester("Arguments");
        (function() {
          if (!isArguments(arguments)) {
            isArguments = function(obj) {
              return has$1(obj, "callee");
            };
          }
        })();
        var isArguments$1 = isArguments;
        function isFinite$1(obj) {
          return !isSymbol(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
        }
        function isNaN$1(obj) {
          return isNumber(obj) && _isNaN(obj);
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function createSizePropertyCheck(getSizeProperty) {
          return function(collection) {
            var sizeProperty = getSizeProperty(collection);
            return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
          };
        }
        function shallowProperty(key) {
          return function(obj) {
            return obj == null ? void 0 : obj[key];
          };
        }
        var getByteLength = shallowProperty("byteLength");
        var isBufferLike = createSizePropertyCheck(getByteLength);
        var typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
        function isTypedArray(obj) {
          return nativeIsView ? nativeIsView(obj) && !isDataView$1(obj) : isBufferLike(obj) && typedArrayPattern.test(toString.call(obj));
        }
        var isTypedArray$1 = supportsArrayBuffer ? isTypedArray : constant(false);
        var getLength = shallowProperty("length");
        function emulatedSet(keys2) {
          var hash = {};
          for (var l = keys2.length, i2 = 0; i2 < l; ++i2)
            hash[keys2[i2]] = true;
          return {
            contains: function(key) {
              return hash[key] === true;
            },
            push: function(key) {
              hash[key] = true;
              return keys2.push(key);
            }
          };
        }
        function collectNonEnumProps(obj, keys2) {
          keys2 = emulatedSet(keys2);
          var nonEnumIdx = nonEnumerableProps.length;
          var constructor = obj.constructor;
          var proto = isFunction$1(constructor) && constructor.prototype || ObjProto;
          var prop2 = "constructor";
          if (has$1(obj, prop2) && !keys2.contains(prop2))
            keys2.push(prop2);
          while (nonEnumIdx--) {
            prop2 = nonEnumerableProps[nonEnumIdx];
            if (prop2 in obj && obj[prop2] !== proto[prop2] && !keys2.contains(prop2)) {
              keys2.push(prop2);
            }
          }
        }
        function keys(obj) {
          if (!isObject2(obj))
            return [];
          if (nativeKeys)
            return nativeKeys(obj);
          var keys2 = [];
          for (var key in obj)
            if (has$1(obj, key))
              keys2.push(key);
          if (hasEnumBug)
            collectNonEnumProps(obj, keys2);
          return keys2;
        }
        function isEmpty(obj) {
          if (obj == null)
            return true;
          var length = getLength(obj);
          if (typeof length == "number" && (isArray(obj) || isString2(obj) || isArguments$1(obj)))
            return length === 0;
          return getLength(keys(obj)) === 0;
        }
        function isMatch(object2, attrs) {
          var _keys = keys(attrs), length = _keys.length;
          if (object2 == null)
            return !length;
          var obj = Object(object2);
          for (var i2 = 0; i2 < length; i2++) {
            var key = _keys[i2];
            if (attrs[key] !== obj[key] || !(key in obj))
              return false;
          }
          return true;
        }
        function _$1(obj) {
          if (obj instanceof _$1)
            return obj;
          if (!(this instanceof _$1))
            return new _$1(obj);
          this._wrapped = obj;
        }
        _$1.VERSION = VERSION;
        _$1.prototype.value = function() {
          return this._wrapped;
        };
        _$1.prototype.valueOf = _$1.prototype.toJSON = _$1.prototype.value;
        _$1.prototype.toString = function() {
          return String(this._wrapped);
        };
        function toBufferView(bufferSource) {
          return new Uint8Array(bufferSource.buffer || bufferSource, bufferSource.byteOffset || 0, getByteLength(bufferSource));
        }
        var tagDataView = "[object DataView]";
        function eq(a, b, aStack, bStack) {
          if (a === b)
            return a !== 0 || 1 / a === 1 / b;
          if (a == null || b == null)
            return false;
          if (a !== a)
            return b !== b;
          var type = typeof a;
          if (type !== "function" && type !== "object" && typeof b != "object")
            return false;
          return deepEq(a, b, aStack, bStack);
        }
        function deepEq(a, b, aStack, bStack) {
          if (a instanceof _$1)
            a = a._wrapped;
          if (b instanceof _$1)
            b = b._wrapped;
          var className = toString.call(a);
          if (className !== toString.call(b))
            return false;
          if (hasStringTagBug && className == "[object Object]" && isDataView$1(a)) {
            if (!isDataView$1(b))
              return false;
            className = tagDataView;
          }
          switch (className) {
            case "[object RegExp]":
            case "[object String]":
              return "" + a === "" + b;
            case "[object Number]":
              if (+a !== +a)
                return +b !== +b;
              return +a === 0 ? 1 / +a === 1 / b : +a === +b;
            case "[object Date]":
            case "[object Boolean]":
              return +a === +b;
            case "[object Symbol]":
              return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
            case "[object ArrayBuffer]":
            case tagDataView:
              return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
          }
          var areArrays = className === "[object Array]";
          if (!areArrays && isTypedArray$1(a)) {
            var byteLength = getByteLength(a);
            if (byteLength !== getByteLength(b))
              return false;
            if (a.buffer === b.buffer && a.byteOffset === b.byteOffset)
              return true;
            areArrays = true;
          }
          if (!areArrays) {
            if (typeof a != "object" || typeof b != "object")
              return false;
            var aCtor = a.constructor, bCtor = b.constructor;
            if (aCtor !== bCtor && !(isFunction$1(aCtor) && aCtor instanceof aCtor && isFunction$1(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
              return false;
            }
          }
          aStack = aStack || [];
          bStack = bStack || [];
          var length = aStack.length;
          while (length--) {
            if (aStack[length] === a)
              return bStack[length] === b;
          }
          aStack.push(a);
          bStack.push(b);
          if (areArrays) {
            length = a.length;
            if (length !== b.length)
              return false;
            while (length--) {
              if (!eq(a[length], b[length], aStack, bStack))
                return false;
            }
          } else {
            var _keys = keys(a), key;
            length = _keys.length;
            if (keys(b).length !== length)
              return false;
            while (length--) {
              key = _keys[length];
              if (!(has$1(b, key) && eq(a[key], b[key], aStack, bStack)))
                return false;
            }
          }
          aStack.pop();
          bStack.pop();
          return true;
        }
        function isEqual(a, b) {
          return eq(a, b);
        }
        function allKeys(obj) {
          if (!isObject2(obj))
            return [];
          var keys2 = [];
          for (var key in obj)
            keys2.push(key);
          if (hasEnumBug)
            collectNonEnumProps(obj, keys2);
          return keys2;
        }
        function ie11fingerprint(methods) {
          var length = getLength(methods);
          return function(obj) {
            if (obj == null)
              return false;
            var keys2 = allKeys(obj);
            if (getLength(keys2))
              return false;
            for (var i2 = 0; i2 < length; i2++) {
              if (!isFunction$1(obj[methods[i2]]))
                return false;
            }
            return methods !== weakMapMethods || !isFunction$1(obj[forEachName]);
          };
        }
        var forEachName = "forEach", hasName = "has", commonInit = ["clear", "delete"], mapTail = ["get", hasName, "set"];
        var mapMethods = commonInit.concat(forEachName, mapTail), weakMapMethods = commonInit.concat(mapTail), setMethods = ["add"].concat(commonInit, forEachName, hasName);
        var isMap = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
        var isWeakMap = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
        var isSet = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
        var isWeakSet = tagTester("WeakSet");
        function values(obj) {
          var _keys = keys(obj);
          var length = _keys.length;
          var values2 = Array(length);
          for (var i2 = 0; i2 < length; i2++) {
            values2[i2] = obj[_keys[i2]];
          }
          return values2;
        }
        function pairs(obj) {
          var _keys = keys(obj);
          var length = _keys.length;
          var pairs2 = Array(length);
          for (var i2 = 0; i2 < length; i2++) {
            pairs2[i2] = [_keys[i2], obj[_keys[i2]]];
          }
          return pairs2;
        }
        function invert(obj) {
          var result2 = {};
          var _keys = keys(obj);
          for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
            result2[obj[_keys[i2]]] = _keys[i2];
          }
          return result2;
        }
        function functions(obj) {
          var names = [];
          for (var key in obj) {
            if (isFunction$1(obj[key]))
              names.push(key);
          }
          return names.sort();
        }
        function createAssigner(keysFunc, defaults2) {
          return function(obj) {
            var length = arguments.length;
            if (defaults2)
              obj = Object(obj);
            if (length < 2 || obj == null)
              return obj;
            for (var index = 1; index < length; index++) {
              var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
              for (var i2 = 0; i2 < l; i2++) {
                var key = keys2[i2];
                if (!defaults2 || obj[key] === void 0)
                  obj[key] = source[key];
              }
            }
            return obj;
          };
        }
        var extend = createAssigner(allKeys);
        var extendOwn = createAssigner(keys);
        var defaults = createAssigner(allKeys, true);
        function ctor() {
          return function() {
          };
        }
        function baseCreate(prototype) {
          if (!isObject2(prototype))
            return {};
          if (nativeCreate)
            return nativeCreate(prototype);
          var Ctor = ctor();
          Ctor.prototype = prototype;
          var result2 = new Ctor();
          Ctor.prototype = null;
          return result2;
        }
        function create(prototype, props) {
          var result2 = baseCreate(prototype);
          if (props)
            extendOwn(result2, props);
          return result2;
        }
        function clone2(obj) {
          if (!isObject2(obj))
            return obj;
          return isArray(obj) ? obj.slice() : extend({}, obj);
        }
        function tap(obj, interceptor) {
          interceptor(obj);
          return obj;
        }
        function toPath$1(path2) {
          return isArray(path2) ? path2 : [path2];
        }
        _$1.toPath = toPath$1;
        function toPath(path2) {
          return _$1.toPath(path2);
        }
        function deepGet(obj, path2) {
          var length = path2.length;
          for (var i2 = 0; i2 < length; i2++) {
            if (obj == null)
              return void 0;
            obj = obj[path2[i2]];
          }
          return length ? obj : void 0;
        }
        function get2(object2, path2, defaultValue) {
          var value = deepGet(object2, toPath(path2));
          return isUndefined(value) ? defaultValue : value;
        }
        function has2(obj, path2) {
          path2 = toPath(path2);
          var length = path2.length;
          for (var i2 = 0; i2 < length; i2++) {
            var key = path2[i2];
            if (!has$1(obj, key))
              return false;
            obj = obj[key];
          }
          return !!length;
        }
        function identity(value) {
          return value;
        }
        function matcher(attrs) {
          attrs = extendOwn({}, attrs);
          return function(obj) {
            return isMatch(obj, attrs);
          };
        }
        function property(path2) {
          path2 = toPath(path2);
          return function(obj) {
            return deepGet(obj, path2);
          };
        }
        function optimizeCb(func, context, argCount) {
          if (context === void 0)
            return func;
          switch (argCount == null ? 3 : argCount) {
            case 1:
              return function(value) {
                return func.call(context, value);
              };
            case 3:
              return function(value, index, collection) {
                return func.call(context, value, index, collection);
              };
            case 4:
              return function(accumulator, value, index, collection) {
                return func.call(context, accumulator, value, index, collection);
              };
          }
          return function() {
            return func.apply(context, arguments);
          };
        }
        function baseIteratee(value, context, argCount) {
          if (value == null)
            return identity;
          if (isFunction$1(value))
            return optimizeCb(value, context, argCount);
          if (isObject2(value) && !isArray(value))
            return matcher(value);
          return property(value);
        }
        function iteratee(value, context) {
          return baseIteratee(value, context, Infinity);
        }
        _$1.iteratee = iteratee;
        function cb(value, context, argCount) {
          if (_$1.iteratee !== iteratee)
            return _$1.iteratee(value, context);
          return baseIteratee(value, context, argCount);
        }
        function mapObject(obj, iteratee2, context) {
          iteratee2 = cb(iteratee2, context);
          var _keys = keys(obj), length = _keys.length, results = {};
          for (var index = 0; index < length; index++) {
            var currentKey = _keys[index];
            results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
          }
          return results;
        }
        function noop() {
        }
        function propertyOf(obj) {
          if (obj == null)
            return noop;
          return function(path2) {
            return get2(obj, path2);
          };
        }
        function times2(n, iteratee2, context) {
          var accum = Array(Math.max(0, n));
          iteratee2 = optimizeCb(iteratee2, context, 1);
          for (var i2 = 0; i2 < n; i2++)
            accum[i2] = iteratee2(i2);
          return accum;
        }
        function random(min2, max2) {
          if (max2 == null) {
            max2 = min2;
            min2 = 0;
          }
          return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
        }
        var now = Date.now || function() {
          return new Date().getTime();
        };
        function createEscaper(map3) {
          var escaper = function(match) {
            return map3[match];
          };
          var source = "(?:" + keys(map3).join("|") + ")";
          var testRegexp = RegExp(source);
          var replaceRegexp = RegExp(source, "g");
          return function(string) {
            string = string == null ? "" : "" + string;
            return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
          };
        }
        var escapeMap = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#x27;",
          "`": "&#x60;"
        };
        var _escape2 = createEscaper(escapeMap);
        var unescapeMap = invert(escapeMap);
        var _unescape = createEscaper(unescapeMap);
        var templateSettings = _$1.templateSettings = {
          evaluate: /<%([\s\S]+?)%>/g,
          interpolate: /<%=([\s\S]+?)%>/g,
          escape: /<%-([\s\S]+?)%>/g
        };
        var noMatch = /(.)^/;
        var escapes = {
          "'": "'",
          "\\": "\\",
          "\r": "r",
          "\n": "n",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
        function escapeChar(match) {
          return "\\" + escapes[match];
        }
        var bareIdentifier = /^\s*(\w|\$)+\s*$/;
        function template(text2, settings, oldSettings) {
          if (!settings && oldSettings)
            settings = oldSettings;
          settings = defaults({}, settings, _$1.templateSettings);
          var matcher2 = RegExp([
            (settings.escape || noMatch).source,
            (settings.interpolate || noMatch).source,
            (settings.evaluate || noMatch).source
          ].join("|") + "|$", "g");
          var index = 0;
          var source = "__p+='";
          text2.replace(matcher2, function(match, escape, interpolate, evaluate, offset) {
            source += text2.slice(index, offset).replace(escapeRegExp, escapeChar);
            index = offset + match.length;
            if (escape) {
              source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            } else if (interpolate) {
              source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            } else if (evaluate) {
              source += "';\n" + evaluate + "\n__p+='";
            }
            return match;
          });
          source += "';\n";
          var argument = settings.variable;
          if (argument) {
            if (!bareIdentifier.test(argument))
              throw new Error("variable is not a bare identifier: " + argument);
          } else {
            source = "with(obj||{}){\n" + source + "}\n";
            argument = "obj";
          }
          source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
          var render;
          try {
            render = new Function(argument, "_", source);
          } catch (e) {
            e.source = source;
            throw e;
          }
          var template2 = function(data) {
            return render.call(this, data, _$1);
          };
          template2.source = "function(" + argument + "){\n" + source + "}";
          return template2;
        }
        function result(obj, path2, fallback) {
          path2 = toPath(path2);
          var length = path2.length;
          if (!length) {
            return isFunction$1(fallback) ? fallback.call(obj) : fallback;
          }
          for (var i2 = 0; i2 < length; i2++) {
            var prop2 = obj == null ? void 0 : obj[path2[i2]];
            if (prop2 === void 0) {
              prop2 = fallback;
              i2 = length;
            }
            obj = isFunction$1(prop2) ? prop2.call(obj) : prop2;
          }
          return obj;
        }
        var idCounter = 0;
        function uniqueId(prefix) {
          var id = ++idCounter + "";
          return prefix ? prefix + id : id;
        }
        function chain(obj) {
          var instance = _$1(obj);
          instance._chain = true;
          return instance;
        }
        function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
          if (!(callingContext instanceof boundFunc))
            return sourceFunc.apply(context, args);
          var self2 = baseCreate(sourceFunc.prototype);
          var result2 = sourceFunc.apply(self2, args);
          if (isObject2(result2))
            return result2;
          return self2;
        }
        var partial = restArguments(function(func, boundArgs) {
          var placeholder = partial.placeholder;
          var bound = function() {
            var position = 0, length = boundArgs.length;
            var args = Array(length);
            for (var i2 = 0; i2 < length; i2++) {
              args[i2] = boundArgs[i2] === placeholder ? arguments[position++] : boundArgs[i2];
            }
            while (position < arguments.length)
              args.push(arguments[position++]);
            return executeBound(func, bound, this, this, args);
          };
          return bound;
        });
        partial.placeholder = _$1;
        var bind = restArguments(function(func, context, args) {
          if (!isFunction$1(func))
            throw new TypeError("Bind must be called on a function");
          var bound = restArguments(function(callArgs) {
            return executeBound(func, bound, context, this, args.concat(callArgs));
          });
          return bound;
        });
        var isArrayLike = createSizePropertyCheck(getLength);
        function flatten$1(input, depth, strict, output2) {
          output2 = output2 || [];
          if (!depth && depth !== 0) {
            depth = Infinity;
          } else if (depth <= 0) {
            return output2.concat(input);
          }
          var idx = output2.length;
          for (var i2 = 0, length = getLength(input); i2 < length; i2++) {
            var value = input[i2];
            if (isArrayLike(value) && (isArray(value) || isArguments$1(value))) {
              if (depth > 1) {
                flatten$1(value, depth - 1, strict, output2);
                idx = output2.length;
              } else {
                var j = 0, len = value.length;
                while (j < len)
                  output2[idx++] = value[j++];
              }
            } else if (!strict) {
              output2[idx++] = value;
            }
          }
          return output2;
        }
        var bindAll = restArguments(function(obj, keys2) {
          keys2 = flatten$1(keys2, false, false);
          var index = keys2.length;
          if (index < 1)
            throw new Error("bindAll must be passed function names");
          while (index--) {
            var key = keys2[index];
            obj[key] = bind(obj[key], obj);
          }
          return obj;
        });
        function memoize(func, hasher) {
          var memoize2 = function(key) {
            var cache = memoize2.cache;
            var address = "" + (hasher ? hasher.apply(this, arguments) : key);
            if (!has$1(cache, address))
              cache[address] = func.apply(this, arguments);
            return cache[address];
          };
          memoize2.cache = {};
          return memoize2;
        }
        var delay = restArguments(function(func, wait, args) {
          return setTimeout(function() {
            return func.apply(null, args);
          }, wait);
        });
        var defer = partial(delay, _$1, 1);
        function throttle(func, wait, options2) {
          var timeout2, context, args, result2;
          var previous = 0;
          if (!options2)
            options2 = {};
          var later = function() {
            previous = options2.leading === false ? 0 : now();
            timeout2 = null;
            result2 = func.apply(context, args);
            if (!timeout2)
              context = args = null;
          };
          var throttled = function() {
            var _now = now();
            if (!previous && options2.leading === false)
              previous = _now;
            var remaining = wait - (_now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0 || remaining > wait) {
              if (timeout2) {
                clearTimeout(timeout2);
                timeout2 = null;
              }
              previous = _now;
              result2 = func.apply(context, args);
              if (!timeout2)
                context = args = null;
            } else if (!timeout2 && options2.trailing !== false) {
              timeout2 = setTimeout(later, remaining);
            }
            return result2;
          };
          throttled.cancel = function() {
            clearTimeout(timeout2);
            previous = 0;
            timeout2 = context = args = null;
          };
          return throttled;
        }
        function debounce(func, wait, immediate) {
          var timeout2, previous, args, result2, context;
          var later = function() {
            var passed = now() - previous;
            if (wait > passed) {
              timeout2 = setTimeout(later, wait - passed);
            } else {
              timeout2 = null;
              if (!immediate)
                result2 = func.apply(context, args);
              if (!timeout2)
                args = context = null;
            }
          };
          var debounced = restArguments(function(_args) {
            context = this;
            args = _args;
            previous = now();
            if (!timeout2) {
              timeout2 = setTimeout(later, wait);
              if (immediate)
                result2 = func.apply(context, args);
            }
            return result2;
          });
          debounced.cancel = function() {
            clearTimeout(timeout2);
            timeout2 = args = context = null;
          };
          return debounced;
        }
        function wrap(func, wrapper) {
          return partial(wrapper, func);
        }
        function negate(predicate) {
          return function() {
            return !predicate.apply(this, arguments);
          };
        }
        function compose() {
          var args = arguments;
          var start = args.length - 1;
          return function() {
            var i2 = start;
            var result2 = args[start].apply(this, arguments);
            while (i2--)
              result2 = args[i2].call(this, result2);
            return result2;
          };
        }
        function after(times3, func) {
          return function() {
            if (--times3 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function before(times3, func) {
          var memo;
          return function() {
            if (--times3 > 0) {
              memo = func.apply(this, arguments);
            }
            if (times3 <= 1)
              func = null;
            return memo;
          };
        }
        var once2 = partial(before, 2);
        function findKey(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = keys(obj), key;
          for (var i2 = 0, length = _keys.length; i2 < length; i2++) {
            key = _keys[i2];
            if (predicate(obj[key], key, obj))
              return key;
          }
        }
        function createPredicateIndexFinder(dir) {
          return function(array, predicate, context) {
            predicate = cb(predicate, context);
            var length = getLength(array);
            var index = dir > 0 ? 0 : length - 1;
            for (; index >= 0 && index < length; index += dir) {
              if (predicate(array[index], index, array))
                return index;
            }
            return -1;
          };
        }
        var findIndex = createPredicateIndexFinder(1);
        var findLastIndex = createPredicateIndexFinder(-1);
        function sortedIndex(array, obj, iteratee2, context) {
          iteratee2 = cb(iteratee2, context, 1);
          var value = iteratee2(obj);
          var low = 0, high = getLength(array);
          while (low < high) {
            var mid2 = Math.floor((low + high) / 2);
            if (iteratee2(array[mid2]) < value)
              low = mid2 + 1;
            else
              high = mid2;
          }
          return low;
        }
        function createIndexFinder(dir, predicateFind, sortedIndex2) {
          return function(array, item, idx) {
            var i2 = 0, length = getLength(array);
            if (typeof idx == "number") {
              if (dir > 0) {
                i2 = idx >= 0 ? idx : Math.max(idx + length, i2);
              } else {
                length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
              }
            } else if (sortedIndex2 && idx && length) {
              idx = sortedIndex2(array, item);
              return array[idx] === item ? idx : -1;
            }
            if (item !== item) {
              idx = predicateFind(slice2.call(array, i2, length), isNaN$1);
              return idx >= 0 ? idx + i2 : -1;
            }
            for (idx = dir > 0 ? i2 : length - 1; idx >= 0 && idx < length; idx += dir) {
              if (array[idx] === item)
                return idx;
            }
            return -1;
          };
        }
        var indexOf = createIndexFinder(1, findIndex, sortedIndex);
        var lastIndexOf = createIndexFinder(-1, findLastIndex);
        function find(obj, predicate, context) {
          var keyFinder = isArrayLike(obj) ? findIndex : findKey;
          var key = keyFinder(obj, predicate, context);
          if (key !== void 0 && key !== -1)
            return obj[key];
        }
        function findWhere(obj, attrs) {
          return find(obj, matcher(attrs));
        }
        function each(obj, iteratee2, context) {
          iteratee2 = optimizeCb(iteratee2, context);
          var i2, length;
          if (isArrayLike(obj)) {
            for (i2 = 0, length = obj.length; i2 < length; i2++) {
              iteratee2(obj[i2], i2, obj);
            }
          } else {
            var _keys = keys(obj);
            for (i2 = 0, length = _keys.length; i2 < length; i2++) {
              iteratee2(obj[_keys[i2]], _keys[i2], obj);
            }
          }
          return obj;
        }
        function map2(obj, iteratee2, context) {
          iteratee2 = cb(iteratee2, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            results[index] = iteratee2(obj[currentKey], currentKey, obj);
          }
          return results;
        }
        function createReduce(dir) {
          var reducer = function(obj, iteratee2, memo, initial2) {
            var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
            if (!initial2) {
              memo = obj[_keys ? _keys[index] : index];
              index += dir;
            }
            for (; index >= 0 && index < length; index += dir) {
              var currentKey = _keys ? _keys[index] : index;
              memo = iteratee2(memo, obj[currentKey], currentKey, obj);
            }
            return memo;
          };
          return function(obj, iteratee2, memo, context) {
            var initial2 = arguments.length >= 3;
            return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
          };
        }
        var reduce = createReduce(1);
        var reduceRight = createReduce(-1);
        function filter(obj, predicate, context) {
          var results = [];
          predicate = cb(predicate, context);
          each(obj, function(value, index, list2) {
            if (predicate(value, index, list2))
              results.push(value);
          });
          return results;
        }
        function reject(obj, predicate, context) {
          return filter(obj, negate(cb(predicate)), context);
        }
        function every(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (!predicate(obj[currentKey], currentKey, obj))
              return false;
          }
          return true;
        }
        function some(obj, predicate, context) {
          predicate = cb(predicate, context);
          var _keys = !isArrayLike(obj) && keys(obj), length = (_keys || obj).length;
          for (var index = 0; index < length; index++) {
            var currentKey = _keys ? _keys[index] : index;
            if (predicate(obj[currentKey], currentKey, obj))
              return true;
          }
          return false;
        }
        function contains(obj, item, fromIndex, guard) {
          if (!isArrayLike(obj))
            obj = values(obj);
          if (typeof fromIndex != "number" || guard)
            fromIndex = 0;
          return indexOf(obj, item, fromIndex) >= 0;
        }
        var invoke = restArguments(function(obj, path2, args) {
          var contextPath, func;
          if (isFunction$1(path2)) {
            func = path2;
          } else {
            path2 = toPath(path2);
            contextPath = path2.slice(0, -1);
            path2 = path2[path2.length - 1];
          }
          return map2(obj, function(context) {
            var method = func;
            if (!method) {
              if (contextPath && contextPath.length) {
                context = deepGet(context, contextPath);
              }
              if (context == null)
                return void 0;
              method = context[path2];
            }
            return method == null ? method : method.apply(context, args);
          });
        });
        function pluck(obj, key) {
          return map2(obj, property(key));
        }
        function where(obj, attrs) {
          return filter(obj, matcher(attrs));
        }
        function max(obj, iteratee2, context) {
          var result2 = -Infinity, lastComputed = -Infinity, value, computed;
          if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
            obj = isArrayLike(obj) ? obj : values(obj);
            for (var i2 = 0, length = obj.length; i2 < length; i2++) {
              value = obj[i2];
              if (value != null && value > result2) {
                result2 = value;
              }
            }
          } else {
            iteratee2 = cb(iteratee2, context);
            each(obj, function(v, index, list2) {
              computed = iteratee2(v, index, list2);
              if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
                result2 = v;
                lastComputed = computed;
              }
            });
          }
          return result2;
        }
        function min(obj, iteratee2, context) {
          var result2 = Infinity, lastComputed = Infinity, value, computed;
          if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
            obj = isArrayLike(obj) ? obj : values(obj);
            for (var i2 = 0, length = obj.length; i2 < length; i2++) {
              value = obj[i2];
              if (value != null && value < result2) {
                result2 = value;
              }
            }
          } else {
            iteratee2 = cb(iteratee2, context);
            each(obj, function(v, index, list2) {
              computed = iteratee2(v, index, list2);
              if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
                result2 = v;
                lastComputed = computed;
              }
            });
          }
          return result2;
        }
        var reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
        function toArray(obj) {
          if (!obj)
            return [];
          if (isArray(obj))
            return slice2.call(obj);
          if (isString2(obj)) {
            return obj.match(reStrSymbol);
          }
          if (isArrayLike(obj))
            return map2(obj, identity);
          return values(obj);
        }
        function sample(obj, n, guard) {
          if (n == null || guard) {
            if (!isArrayLike(obj))
              obj = values(obj);
            return obj[random(obj.length - 1)];
          }
          var sample2 = toArray(obj);
          var length = getLength(sample2);
          n = Math.max(Math.min(n, length), 0);
          var last2 = length - 1;
          for (var index = 0; index < n; index++) {
            var rand = random(index, last2);
            var temp = sample2[index];
            sample2[index] = sample2[rand];
            sample2[rand] = temp;
          }
          return sample2.slice(0, n);
        }
        function shuffle(obj) {
          return sample(obj, Infinity);
        }
        function sortBy(obj, iteratee2, context) {
          var index = 0;
          iteratee2 = cb(iteratee2, context);
          return pluck(map2(obj, function(value, key, list2) {
            return {
              value,
              index: index++,
              criteria: iteratee2(value, key, list2)
            };
          }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
              if (a > b || a === void 0)
                return 1;
              if (a < b || b === void 0)
                return -1;
            }
            return left.index - right.index;
          }), "value");
        }
        function group(behavior, partition2) {
          return function(obj, iteratee2, context) {
            var result2 = partition2 ? [[], []] : {};
            iteratee2 = cb(iteratee2, context);
            each(obj, function(value, index) {
              var key = iteratee2(value, index, obj);
              behavior(result2, value, key);
            });
            return result2;
          };
        }
        var groupBy = group(function(result2, value, key) {
          if (has$1(result2, key))
            result2[key].push(value);
          else
            result2[key] = [value];
        });
        var indexBy = group(function(result2, value, key) {
          result2[key] = value;
        });
        var countBy = group(function(result2, value, key) {
          if (has$1(result2, key))
            result2[key]++;
          else
            result2[key] = 1;
        });
        var partition = group(function(result2, value, pass) {
          result2[pass ? 0 : 1].push(value);
        }, true);
        function size(obj) {
          if (obj == null)
            return 0;
          return isArrayLike(obj) ? obj.length : keys(obj).length;
        }
        function keyInObj(value, key, obj) {
          return key in obj;
        }
        var pick = restArguments(function(obj, keys2) {
          var result2 = {}, iteratee2 = keys2[0];
          if (obj == null)
            return result2;
          if (isFunction$1(iteratee2)) {
            if (keys2.length > 1)
              iteratee2 = optimizeCb(iteratee2, keys2[1]);
            keys2 = allKeys(obj);
          } else {
            iteratee2 = keyInObj;
            keys2 = flatten$1(keys2, false, false);
            obj = Object(obj);
          }
          for (var i2 = 0, length = keys2.length; i2 < length; i2++) {
            var key = keys2[i2];
            var value = obj[key];
            if (iteratee2(value, key, obj))
              result2[key] = value;
          }
          return result2;
        });
        var omit = restArguments(function(obj, keys2) {
          var iteratee2 = keys2[0], context;
          if (isFunction$1(iteratee2)) {
            iteratee2 = negate(iteratee2);
            if (keys2.length > 1)
              context = keys2[1];
          } else {
            keys2 = map2(flatten$1(keys2, false, false), String);
            iteratee2 = function(value, key) {
              return !contains(keys2, key);
            };
          }
          return pick(obj, iteratee2, context);
        });
        function initial(array, n, guard) {
          return slice2.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
        }
        function first(array, n, guard) {
          if (array == null || array.length < 1)
            return n == null || guard ? void 0 : [];
          if (n == null || guard)
            return array[0];
          return initial(array, array.length - n);
        }
        function rest(array, n, guard) {
          return slice2.call(array, n == null || guard ? 1 : n);
        }
        function last(array, n, guard) {
          if (array == null || array.length < 1)
            return n == null || guard ? void 0 : [];
          if (n == null || guard)
            return array[array.length - 1];
          return rest(array, Math.max(0, array.length - n));
        }
        function compact(array) {
          return filter(array, Boolean);
        }
        function flatten(array, depth) {
          return flatten$1(array, depth, false);
        }
        var difference = restArguments(function(array, rest2) {
          rest2 = flatten$1(rest2, true, true);
          return filter(array, function(value) {
            return !contains(rest2, value);
          });
        });
        var without = restArguments(function(array, otherArrays) {
          return difference(array, otherArrays);
        });
        function uniq(array, isSorted, iteratee2, context) {
          if (!isBoolean(isSorted)) {
            context = iteratee2;
            iteratee2 = isSorted;
            isSorted = false;
          }
          if (iteratee2 != null)
            iteratee2 = cb(iteratee2, context);
          var result2 = [];
          var seen = [];
          for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
            var value = array[i2], computed = iteratee2 ? iteratee2(value, i2, array) : value;
            if (isSorted && !iteratee2) {
              if (!i2 || seen !== computed)
                result2.push(value);
              seen = computed;
            } else if (iteratee2) {
              if (!contains(seen, computed)) {
                seen.push(computed);
                result2.push(value);
              }
            } else if (!contains(result2, value)) {
              result2.push(value);
            }
          }
          return result2;
        }
        var union = restArguments(function(arrays) {
          return uniq(flatten$1(arrays, true, true));
        });
        function intersection(array) {
          var result2 = [];
          var argsLength = arguments.length;
          for (var i2 = 0, length = getLength(array); i2 < length; i2++) {
            var item = array[i2];
            if (contains(result2, item))
              continue;
            var j;
            for (j = 1; j < argsLength; j++) {
              if (!contains(arguments[j], item))
                break;
            }
            if (j === argsLength)
              result2.push(item);
          }
          return result2;
        }
        function unzip(array) {
          var length = array && max(array, getLength).length || 0;
          var result2 = Array(length);
          for (var index = 0; index < length; index++) {
            result2[index] = pluck(array, index);
          }
          return result2;
        }
        var zip = restArguments(unzip);
        function object(list2, values2) {
          var result2 = {};
          for (var i2 = 0, length = getLength(list2); i2 < length; i2++) {
            if (values2) {
              result2[list2[i2]] = values2[i2];
            } else {
              result2[list2[i2][0]] = list2[i2][1];
            }
          }
          return result2;
        }
        function range2(start, stop, step) {
          if (stop == null) {
            stop = start || 0;
            start = 0;
          }
          if (!step) {
            step = stop < start ? -1 : 1;
          }
          var length = Math.max(Math.ceil((stop - start) / step), 0);
          var range3 = Array(length);
          for (var idx = 0; idx < length; idx++, start += step) {
            range3[idx] = start;
          }
          return range3;
        }
        function chunk(array, count) {
          if (count == null || count < 1)
            return [];
          var result2 = [];
          var i2 = 0, length = array.length;
          while (i2 < length) {
            result2.push(slice2.call(array, i2, i2 += count));
          }
          return result2;
        }
        function chainResult(instance, obj) {
          return instance._chain ? _$1(obj).chain() : obj;
        }
        function mixin(obj) {
          each(functions(obj), function(name) {
            var func = _$1[name] = obj[name];
            _$1.prototype[name] = function() {
              var args = [this._wrapped];
              push.apply(args, arguments);
              return chainResult(this, func.apply(_$1, args));
            };
          });
          return _$1;
        }
        each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
          var method = ArrayProto[name];
          _$1.prototype[name] = function() {
            var obj = this._wrapped;
            if (obj != null) {
              method.apply(obj, arguments);
              if ((name === "shift" || name === "splice") && obj.length === 0) {
                delete obj[0];
              }
            }
            return chainResult(this, obj);
          };
        });
        each(["concat", "join", "slice"], function(name) {
          var method = ArrayProto[name];
          _$1.prototype[name] = function() {
            var obj = this._wrapped;
            if (obj != null)
              obj = method.apply(obj, arguments);
            return chainResult(this, obj);
          };
        });
        var allExports = {
          __proto__: null,
          VERSION,
          restArguments,
          isObject: isObject2,
          isNull,
          isUndefined,
          isBoolean,
          isElement,
          isString: isString2,
          isNumber,
          isDate,
          isRegExp: isRegExp2,
          isError,
          isSymbol,
          isArrayBuffer,
          isDataView: isDataView$1,
          isArray,
          isFunction: isFunction$1,
          isArguments: isArguments$1,
          isFinite: isFinite$1,
          isNaN: isNaN$1,
          isTypedArray: isTypedArray$1,
          isEmpty,
          isMatch,
          isEqual,
          isMap,
          isWeakMap,
          isSet,
          isWeakSet,
          keys,
          allKeys,
          values,
          pairs,
          invert,
          functions,
          methods: functions,
          extend,
          extendOwn,
          assign: extendOwn,
          defaults,
          create,
          clone: clone2,
          tap,
          get: get2,
          has: has2,
          mapObject,
          identity,
          constant,
          noop,
          toPath: toPath$1,
          property,
          propertyOf,
          matcher,
          matches: matcher,
          times: times2,
          random,
          now,
          escape: _escape2,
          unescape: _unescape,
          templateSettings,
          template,
          result,
          uniqueId,
          chain,
          iteratee,
          partial,
          bind,
          bindAll,
          memoize,
          delay,
          defer,
          throttle,
          debounce,
          wrap,
          negate,
          compose,
          after,
          before,
          once: once2,
          findKey,
          findIndex,
          findLastIndex,
          sortedIndex,
          indexOf,
          lastIndexOf,
          find,
          detect: find,
          findWhere,
          each,
          forEach: each,
          map: map2,
          collect: map2,
          reduce,
          foldl: reduce,
          inject: reduce,
          reduceRight,
          foldr: reduceRight,
          filter,
          select: filter,
          reject,
          every,
          all: every,
          some,
          any: some,
          contains,
          includes: contains,
          include: contains,
          invoke,
          pluck,
          where,
          max,
          min,
          shuffle,
          sample,
          sortBy,
          groupBy,
          indexBy,
          countBy,
          partition,
          toArray,
          size,
          pick,
          omit,
          first,
          head: first,
          take: first,
          initial,
          last,
          rest,
          tail: rest,
          drop: rest,
          compact,
          flatten,
          without,
          uniq,
          unique: uniq,
          union,
          intersection,
          difference,
          unzip,
          transpose: unzip,
          zip,
          object,
          range: range2,
          chunk,
          mixin,
          "default": _$1
        };
        var _2 = mixin(allExports);
        _2._ = _2;
        return _2;
      });
    })(underscoreUmd);
    var _;
    var checkboxReplace;
    _ = underscoreUmdExports;
    checkboxReplace = function(md, options2, Token2) {
      var arrayReplaceAt2, createTokens, defaults, lastId, pattern2, splitTextToken;
      arrayReplaceAt2 = md.utils.arrayReplaceAt;
      lastId = 0;
      defaults = {
        divWrap: false,
        divClass: "checkbox",
        idPrefix: "checkbox"
      };
      options2 = _.extend(defaults, options2);
      pattern2 = /\[(X|\s|\_|\-)\]\s(.*)/i;
      createTokens = function(checked, label, Token3) {
        var id, nodes, token2;
        nodes = [];
        if (options2.divWrap) {
          token2 = new Token3("checkbox_open", "div", 1);
          token2.attrs = [["class", options2.divClass]];
          nodes.push(token2);
        }
        id = options2.idPrefix + lastId;
        lastId += 1;
        token2 = new Token3("checkbox_input", "input", 0);
        token2.attrs = [["type", "checkbox"], ["id", id]];
        if (checked === true) {
          token2.attrs.push(["checked", "true"]);
        }
        nodes.push(token2);
        token2 = new Token3("label_open", "label", 1);
        token2.attrs = [["for", id]];
        nodes.push(token2);
        token2 = new Token3("text", "", 0);
        token2.content = label;
        nodes.push(token2);
        nodes.push(new Token3("label_close", "label", -1));
        if (options2.divWrap) {
          nodes.push(new Token3("checkbox_close", "div", -1));
        }
        return nodes;
      };
      splitTextToken = function(original, Token3) {
        var checked, label, matches, text2, value;
        text2 = original.content;
        matches = text2.match(pattern2);
        if (matches === null) {
          return original;
        }
        checked = false;
        value = matches[1];
        label = matches[2];
        if (value === "X" || value === "x") {
          checked = true;
        }
        return createTokens(checked, label, Token3);
      };
      return function(state) {
        var blockTokens, i2, j, l, token2, tokens;
        blockTokens = state.tokens;
        j = 0;
        l = blockTokens.length;
        while (j < l) {
          if (blockTokens[j].type !== "inline") {
            j++;
            continue;
          }
          tokens = blockTokens[j].children;
          i2 = tokens.length - 1;
          while (i2 >= 0) {
            token2 = tokens[i2];
            blockTokens[j].children = tokens = arrayReplaceAt2(tokens, i2, splitTextToken(token2, state.Token));
            i2--;
          }
          j++;
        }
      };
    };
    var markdownItCheckbox = function(md, options2) {
      md.core.ruler.push("checkbox", checkboxReplace(md, options2));
    };
    function externalLinksPlugin(md, options2) {
      options2 = options2 || {};
      let externalClassName = typeof options2.externalClassName === "string" || options2.externalClassName === null ? options2.externalClassName : "external-link";
      let internalClassName = typeof options2.internalClassName === "string" || options2.internalClassName === null ? options2.internalClassName : null;
      let internalDomains = Array.isArray(options2.internalDomains) ? options2.internalDomains.map((domain) => domain.toLowerCase()) : [];
      let externalTarget = options2.externalTarget || "_self";
      let internalTarget = options2.internalTarget || "_self";
      let externalRel = options2.externalRel || null;
      let internalRel = options2.internalRel || null;
      if (externalClassName === null && internalClassName === null && externalTarget === "_self" && internalTarget === "_self" && externalRel === null && internalRel === null) {
        return;
      }
      function externalLinks(state) {
        function applyFilterToTokenHierarchy(token2) {
          if (token2.children) {
            token2.children.map(applyFilterToTokenHierarchy);
          }
          if (token2.type === "link_open") {
            let href = token2.attrGet("href");
            let internal = isInternalLink(href);
            let newClasses = internal ? internalClassName : externalClassName;
            if (newClasses) {
              let existingClasses = token2.attrGet("class") || "";
              if (existingClasses !== "") {
                newClasses = existingClasses + " " + newClasses;
              }
              token2.attrSet("class", newClasses);
            }
            let target2 = internal ? internalTarget : externalTarget;
            if (target2 !== "_self") {
              token2.attrSet("target", target2);
            }
            let rel = internal ? internalRel : externalRel;
            if (rel) {
              let existingRel = token2.attrGet("rel") || "";
              if (existingRel !== "") {
                rel = existingRel + " " + rel;
              }
              token2.attrSet("rel", rel);
            }
          }
        }
        state.tokens.map(applyFilterToTokenHierarchy);
      }
      function isInternalLink(href) {
        let domain = getDomain(href);
        return domain === null || internalDomains.indexOf(domain) !== -1;
      }
      function getDomain(href) {
        let domain = href.split("//")[1];
        if (domain) {
          domain = domain.split("/")[0].toLowerCase();
          return domain || null;
        }
        return null;
      }
      md.core.ruler.push("external_links", externalLinks);
    }
    var lib = externalLinksPlugin;
    var Parser = class {
      constructor(pklib) {
        __publicField(this, "pklib");
        __publicField(this, "mdParser");
        __publicField(this, "mdParserOptions");
        __publicField(this, "jsdom");
        __publicField(this, "cache");
        __publicField(this, "transformer");
        __publicField(this, "removers");
        __publicField(this, "customParseMD");
        __publicField(this, "resetIndex", () => {
          this.cache = {
            md: {},
            image: {},
            pdf: {},
            note: {},
            json: {},
            error: {}
          };
        });
        __publicField(this, "index", (asset) => {
          const { cache } = this;
          const { hash, type } = asset;
          const key = `${type}.${hash}`;
          if (get(cache, key))
            return;
          asset.eat = new Date().toISOString();
          put(cache, key, asset);
        });
        __publicField(this, "setTransformer", (fn) => {
          this.transformer = fn;
        });
        __publicField(this, "setRemovers", (removers) => {
          this.removers = removers;
        });
        __publicField(this, "getMDParser", () => {
          if (this.mdParser)
            return this.mdParser;
          const parser = new MDLib(this.mdParserOptions);
          parser.use(markdownItCheckbox);
          parser.use(lib);
          this.mdParser = parser;
          return parser;
        });
        __publicField(this, "setMDParserOptions", (options2 = {}) => {
          this.mdParser = false;
          return this.mdParserOptions = options2;
        });
        __publicField(this, "setCustomParseMD", (fn) => {
          this.customParseMD = fn;
        });
        __publicField(this, "parseMD", async (file) => {
          if (this.customParseMD)
            return this.customParseMD(file);
          const content = await this.pklib.vault.read(file, { encoding: "utf-8" });
          const { frontmatter, body: body2 } = parseFrontmatter(content);
          const tags = this.pklib.utils.a.asArray(frontmatter.tags);
          const html2 = this.getMDParser().render(body2);
          return { frontmatter, html: html2, tags };
        });
        __publicField(this, "processHtml", async (s) => {
          const { utils: utils2 } = this.pklib;
          const win = await this.getWindowFromString(s);
          const { document: doc } = win;
          const txs = [];
          if (this.transformer) {
            await this.transformer(win, txs, this.pklib);
            await processTxs(txs, win);
          }
          const removers = Object.keys(this.removers);
          removers.forEach((key) => {
            const fn = utils2.dom.remove[key];
            fn(this.removers[key], doc.body);
          });
          return win;
        });
        __publicField(this, "getWindowFromString", async (s) => {
          if (this.jsdom) {
            const dom = new this.jsdom.JSDOM(s);
            jquery(dom.window, true);
            return dom.window;
          } else {
            const win = {};
            win.document = new window.DOMParser().parseFromString(s, "text/html");
            win.$ = jquery;
            return win;
          }
        });
        __publicField(this, "getTextFromElement", async (doc, el2) => {
          if (!el2 || !el2.innerHTML)
            return "";
          const div2 = doc.createElement("div");
          div2.insertAdjacentHTML("beforeend", el2.innerHTML);
          const text2 = Array.from(div2.querySelectorAll("h1,h2,h3,p")).map((x) => (x.textContent || "").replace(/\s\s+/g, " ")).filter((x) => !!x).join(" ");
          return text2;
        });
        __publicField(this, "print", (cache) => {
          cache = cache || this.cache;
          const string = [
            { key: "note", icon: "\u{1F4C4}" },
            { key: "image", icon: "\u{1F3DE}\uFE0F" },
            { key: "pdf", icon: "\u{1F517}" },
            { key: "json", icon: "\u{1F4C1}" },
            { key: "error", icon: "\u{1F4A5}" }
          ].map((category) => {
            return this.printCategory(category, cache);
          });
          return string.filter(Boolean).join("\n\n");
        });
        __publicField(this, "printCategory", (category, cache) => {
          const values = Object.values(cache[category.key]);
          const nbValues = values.length;
          if (nbValues <= 0)
            return false;
          return `${category.icon}  ${nbValues} ${category.key}${nbValues > 1 ? "s" : ""} 
-------------------
${values.map((a) => {
            const err = category.key == "error" ? ` [${a.err}]` : "";
            return `\u2794 ${a.url} ${err}`;
          }).join("\n")}`;
        });
        this.pklib = pklib;
        this.setMDParserOptions({ html: true });
        this.setTransformer(defaultTransformer);
        this.setRemovers({});
        this.mdParserOptions = { linkify: true };
      }
    };
    var processTxs = async (txs, win) => {
      const result = {};
      for (const el2 of txs) {
        result[el2[0]] = await processTx(el2[0], el2[1], win);
      }
      return result;
    };
    var processTx = async (selector, fn, win) => {
      const { document: doc } = win;
      const els2 = [...doc.querySelectorAll(selector)];
      await Promise.allSettled(els2.map((el2) => fn(el2)));
      return els2.length;
    };
    var defaultTransformer = async (win, txs, pklib) => {
      const { document: doc, $: $2 } = win;
      const body2 = doc.querySelector("body");
      if (!body2)
        return;
      const { fileToAsset, parser } = pklib;
      const isInternal = (path2) => {
        if (!path2)
          return;
        if (path2.includes("//"))
          return;
        if (path2.startsWith("/"))
          return path2.slice(1);
        return path2;
      };
      txs.push([
        "img",
        async (el2) => {
          const path2 = isInternal(el2.getAttribute("src"));
          const asset = path2 && await fileToAsset(path2);
          if (!asset)
            return;
          el2.setAttribute("src", asset.url);
          parser.index(asset);
        }
      ]);
    };
    var DB = class {
      constructor(name) {
        __publicField(this, "name");
        __publicField(this, "data");
        __publicField(this, "base");
        this.name = name;
        this.data = {};
      }
      setBase(path2) {
        this.base = path2 || this.base;
      }
      toPath() {
        if (!this.base)
          throw new Error("db has no base");
        return `${this.base}/${this.name}.json`;
      }
      get(col, key) {
        const data = this.data[col] || {};
        key ? data[key] : data;
        return data;
      }
      set(col, key, value) {
        const data = this.data[col] || {};
        data[key] = value;
        this.data[col] = data;
      }
      unset(col, key) {
        const data = this.data[col] || {};
        delete data[key];
        this.data[col] = data;
      }
      async save() {
        const data = JSON.stringify(this.data);
        await fs$3.outputFile(this.toPath(), data);
      }
      async load() {
        const path2 = this.toPath();
        if (!await fs$3.existsSync(path2))
          await fs$3.outputFile(path2, "{}");
        try {
          this.data = JSON.parse(await fs$3.readFile(path2, "utf8"));
        } catch (error) {
          throw new Error("db.load failed");
        }
      }
    };
    var header = (data = {}) => {
      const { cfg } = data;
      const double2singleQuote = (s) => typeof s == "string" ? s.replace(/"/g, "'") : s;
      const escaped = (k) => double2singleQuote(cfg(k));
      const getValue = (v) => escaped(v) || escaped(`og.${v}`) || escaped(`site.${v}`) || "";
      const og = cfg("og", {});
      const meta = "url,title,description,image,name,keyswords".split(",").reduce((acc, key) => {
        acc[key] = getValue(key);
        if ("url,title,description,image".includes(key))
          og[key] = acc[key];
        if (key == "name")
          og["site_name"] = acc[key];
        return acc;
      }, {});
      const buildMeta = (index, og2) => Object.keys(index).reduce((acc, key) => {
        const prop2 = og2 ? "property" : "name";
        const value = og2 ? `og:${key}` : key;
        const content = index[key];
        return acc += index[key] && `<meta ${prop2}="${value}" content="${content}" />` || "";
      }, "");
      meta.viewport = "width=device-width, initial-scale=1, maximum-scale=1";
      const metaTags = buildMeta(meta);
      const ogTags = buildMeta(og, true);
      return `
<title>${cfg("title")}</title>
<meta charset="utf-8" />
${metaTags}
${ogTags}
<script type="text/javascript" src="https://cdn.jsdelivr.net/gh/publishkit/kit@latest/init.js"><\/script>
`;
    };
    var body = (data = {}) => `
<template id="frontmatter">
${JSON.stringify(data.frontmatter)}
</template>
<template id="content">
${data.body}
</template>`;
    var html = (data = {}) => `<!DOCTYPE html>
<html>
    <head>${data.head}</head>
    <body>
${data.body}
</body>
</html>`;
    var kitrc = (data = {}) => `---

# \u{1F4C2} Vault

vault:
  kit_folder: ${data.vault.kit_folder}
  include: 
    - '^(kitrc|index|navbar).md$'
    - '^blog/'
    - '^notes/'
  exclude: 
    - '^kit/'
    - '^templates/'
    - '^blog/draft'


# \u{1F9F0} Kit

kit:
  version: latest
  dirs: false


# \u{1F5A5}\uFE0F Site

site:
  id: ${data.site.id}
  name: ${data.site.name}
  description: Welcome to ${data.site.name}
  url: https://your-site-domain.com
  keyswords: publishkit, blogging, markdown

og:
  image: https://publishkit.dev/attachements/og-image.png


# \u{1F50C} Plugins

plugins: 
  theme: "@default"
  header: true
  darkmode: true
  navbar: true
  toc: true
  search: true
  social: true


# \u2699\uFE0F  Plugins settings

social:
  github: https://publishkit.dev
  discord: https://publishkit.dev

---
# KITRC

KITRC stands for Kit **R**un **C**ommands.
It holds your app global configuration. 


Edit settings or add plugins, and export the file in your kit. If the file is valid frontmatter wise, you should see a \`kitrc.json\` at the root of your kit folder.


Check out https://publishkit.dev`;
    var _log2;
    var PKLib2 = class {
      constructor(options2 = {}) {
        __publicField(this, "utils");
        __publicField(this, "env");
        __publicField(this, "kitrc");
        __publicField(this, "kitrcfly");
        __publicField(this, "vault");
        __publicField(this, "kit");
        __publicField(this, "db");
        __publicField(this, "cfg");
        __publicField(this, "preExport");
        __publicField(this, "postExport");
        __publicField(this, "version");
        __publicField(this, "verbose");
        __publicField(this, "parser");
        __publicField(this, "isProcessing");
        __publicField(this, "error");
        __privateAdd(this, _log2, (...args) => {
          this.verbose && console.log(`pklib \u2794`, ...args);
        });
        __publicField(this, "init", async () => {
          __privateGet(this, _log2).call(this, "init");
        });
        __publicField(this, "loadDirsConfig", async (asset) => {
          var _a;
          const { vault, utils: utils2, kitrc: kitrc2 } = this;
          if (!((_a = kitrc2.pk) == null ? void 0 : _a.dirs))
            return [];
          const dirs = asset.path.split("/").slice(0, -1).filter(Boolean);
          const paths = dirs.map((dir, i2) => {
            if (i2 == 0)
              return dir;
            const prev = dirs[i2 - 1];
            return [prev, dir].join("/");
          });
          const files = await Promise.allSettled(paths.map(async (path2) => {
            try {
              const file = await vault.read(`${path2}/dirrc.md`, {
                encoding: "utf-8"
              });
              const { frontmatter } = utils2.md.parseFrontmatter(file);
              return Object.keys(frontmatter).length ? frontmatter : false;
            } catch (e) {
              return false;
            }
          }));
          return files.map((r) => r.value).filter(Boolean);
        });
        __publicField(this, "exportFile", async (files, options2) => {
          this.isProcessing = true;
          const { parser, utils: utils2, cfg } = this;
          options2 = options2 || {};
          files = utils2.a.asArray(files);
          parser.resetIndex();
          const preExport = await (this.preExport || (() => {
          }))();
          const run = async (notes) => {
            for (const file of notes) {
              if (!file)
                continue;
              if (file.split(".").pop() != "md")
                continue;
              const asset = await this.fileToAsset(file);
              try {
                const md = await parser.parseMD(file);
                if (asset.path == "kitrc.md") {
                  const content = utils2.o.clone(md.frontmatter, "obsidian,vault,password");
                  asset.content = JSON.stringify(content, null, 2);
                  asset.url = "kitrc.json";
                  asset.type = "json";
                  parser.index(asset);
                  continue;
                }
                if (asset.path.split("/").pop() == "dirrc.md") {
                  const content = utils2.o.clone(md.frontmatter, "obsidian,vault,password");
                  asset.content = JSON.stringify(content, null, 2);
                  asset.url = asset.path.replace(".md", ".json");
                  asset.type = "json";
                  parser.index(asset);
                  continue;
                }
                let win = await parser.processHtml(md.html);
                let doc = win.document;
                if (asset.path == "navbar.md") {
                  const content = this.utils.dom.parseUl(win, doc.querySelector("ul"));
                  asset.content = JSON.stringify(content, null, 2);
                  asset.url = "navbar.json";
                  asset.type = "json";
                  parser.index(asset);
                  continue;
                }
                const dirs = await this.loadDirsConfig(asset);
                this.kitrcfly = utils2.o.merge({}, this.kitrc, ...dirs, md.frontmatter);
                const title = cfg("title") || cfg("og.title") || asset.filename.replace(".md", "");
                cfg.set("title", title);
                await this.encryptFile(doc);
                const html2 = await this.buildHTML(doc.body.innerHTML, md);
                win = html2.window;
                doc = win.document;
                asset.type = "note";
                asset.content = html2.html;
                asset.title = doc.title;
                asset.tags = md.tags;
                asset.text = await parser.getTextFromElement(doc, doc.getElementById("content"));
              } catch (e) {
                asset.type = "error";
                asset.err = e.message || e;
              }
              parser.index(asset);
            }
          };
          await run(files);
          if (!options2.dry)
            await this.dumpFiles();
          if (!options2.dry)
            await this.dbSave();
          if (options2.inspect)
            console.log("cache", parser.cache);
          const summary = parser.print();
          await (this.postExport || (() => {
          }))({
            files,
            preExport
          });
          this.isProcessing = false;
          return { cache: parser.cache, summary };
        });
        __publicField(this, "dbSave", async () => {
          const { db, parser, utils: utils2 } = this;
          await db.load();
          const saveNS = async (ns) => {
            const col = `${ns}s`;
            const index = parser.cache[ns];
            const items = Object.keys(index);
            items.forEach((item) => {
              item = utils2.o.clone(index[item], "content");
              db.set(col, item.hash, item);
            });
            if (col == "notes") {
              const kitFiles = await this.kit.lsFiles("html");
              const dbHashes = db.get(col);
              const kitHashes = await Promise.all(kitFiles.map(async (f) => utils2.c.getHash(f)));
              const diff = Object.keys(dbHashes).filter((x) => !kitHashes.includes(x));
              diff.map((key) => {
                db.unset(col, key);
              });
            }
          };
          await saveNS("note");
          await saveNS("image");
          await saveNS("pdf");
          await db.save();
        });
        __publicField(this, "dumpFiles", async () => {
          const { cache } = this.parser;
          return await Promise.all([
            this.kit.dumpNotes(cache.json),
            this.kit.dumpNotes(cache.note),
            this.kit.dumpAssets(cache.image, "base64"),
            this.kit.dumpAssets(cache.pdf)
          ]);
        });
        __publicField(this, "buildHTML", async (bodyText, md = {}) => {
          const { utils: utils2 } = this;
          const head = header({ cfg: this.cfg });
          const tags = md.tags;
          const frontmatter = utils2.o.clone(md.frontmatter, "password");
          const body$1 = utils2.s.beautify(body({ tags, frontmatter, body: bodyText }));
          const html$12 = utils2.s.beautify(html({ head, body: body$1 }));
          const win = await this.parser.getWindowFromString(html$12);
          return { html: html$12, body: body$1, window: win };
        });
        __publicField(this, "encryptFile", async (dom) => {
          const pwd = this.cfg("password");
          if (!pwd)
            return;
          const encrypted = await this.utils.c.encrypt(dom.body.innerHTML, pwd);
          dom.body.innerHTML = `_crypted_` + encrypted;
        });
        __publicField(this, "fileToAsset", async (file) => {
          var _a;
          const filename = file.split("/").pop() || "";
          const ext2 = ((_a = filename.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "";
          let url = "";
          let type = "";
          if (ext2 == "md") {
            url = file.replace(".md", `.html`);
            type = "md";
          }
          if ("jpg,jpeg,gif,png,pdf".split(",").includes(ext2)) {
            url = file;
            type = ext2 == "pdf" ? "pdf" : "image";
          }
          const hash = await this.utils.c.getHash(url);
          return { path: file, filename, ext: ext2, hash, url, type };
        });
        __publicField(this, "setKitrc", (kitrc2) => {
          var _a, _b;
          kitrc2 = kitrc2 || {};
          if (!Object.keys(kitrc2).length)
            throw new Error("inavalid kitrc data");
          __privateGet(this, _log2).call(this, "set:kitrc");
          this.kitrc = kitrc2;
          this.kitrcfly = {};
          const kitBase = ((_a = kitrc2.vault) == null ? void 0 : _a.kit_folder) || this.env.kit;
          this.kit.setBase(kitBase);
          this.db.setBase(kitBase);
          this.version = ((_b = kitrc2.pk) == null ? void 0 : _b.version) || "latest";
        });
        __publicField(this, "getKitrc", (cwd, ext2 = "md") => {
          const file = `${cwd || this.env.cwd}/kitrc.${ext2}`;
          if (!utils$2.fs.existsSync(file))
            return false;
          const content = utils$2.fs.readFileSync(file, "utf8");
          return ext2 == "md" ? utils$2.md.parseFrontmatter(content).frontmatter : JSON.parse(content);
        });
        __publicField(this, "reloadKitrc", () => {
          const kitrc2 = this.getKitrc();
          this.setKitrc(kitrc2);
        });
        __publicField(this, "guessEnv", () => {
          var _a;
          let cwd, type = "", vault, kit, kitrc2, isObsidian = false;
          try {
            cwd = app == null ? void 0 : app.vault.adapter.basePath;
            type = "vault";
            isObsidian = true;
          } catch (e) {
            cwd = process.cwd();
            if (utils$2.fs.existsSync(`${cwd}/.obsidian`) || utils$2.fs.existsSync(`${cwd}/kitrc.md`)) {
              type = "vault";
            }
          }
          try {
            if (type == "vault") {
              vault = cwd;
              kitrc2 = this.getKitrc(cwd);
              kit = ((_a = kitrc2.vault) == null ? void 0 : _a.kit_folder) || `${cwd}/kit`;
            } else {
              if (utils$2.fs.existsSync(`${cwd}/kitrc.json`)) {
                type = "kit";
                kitrc2 = this.getKitrc(cwd, "json");
                kit = cwd;
              } else {
                vault = cwd;
                type = "vault";
              }
            }
            this.env = { cwd, type, vault, kit, isObsidian };
            if (vault)
              this.vault.setBase(vault);
            if (kitrc2)
              this.setKitrc(kitrc2);
          } catch (e) {
            this.error = this.betterError(e);
            __privateGet(this, _log2).call(this, "error", this.error);
          }
        });
        __publicField(this, "betterError", (e) => {
          let err;
          if (e.name == "YAMLException")
            err = `Invalid Yaml in kitrc.md file. Fix & restart !

${e.message}`;
          else
            err = e;
          return err;
        });
        this.utils = utils$2;
        this.vault = new Folder(this, "vault");
        this.kit = new Folder(this, "kit");
        this.parser = new Parser(this);
        this.db = new DB("kitdb");
        if (options2.verbose)
          this.verbose = true;
        this.guessEnv();
        this.cfg = (key, fallback) => utils$2.o.get(this.kitrcfly, key) || utils$2.o.get(this.kitrc, key) || fallback;
        this.cfg.set = (key, value) => utils$2.o.put(this.kitrcfly, key, value);
      }
      async createKitrc(data = {}) {
        var _a, _b, _c, _d;
        if (this.env.type == "kit")
          throw new Error(`cannot init a "kit" folder`);
        if (await ((_a = this.vault) == null ? void 0 : _a.fileExist("kitrc.md")))
          throw new Error("kitrc.md already exist");
        data.vault = data.vault || {};
        data.vault.kit_folder = data.vault.kit_folder || ((_c = (_b = this.kitrc) == null ? void 0 : _b.vault) == null ? void 0 : _c.kit_folder) || `${this.env.vault}/kit`;
        data.site = data.site || {};
        data.site.name = data.site.name || this.utils.s.capitalize((_d = this.env.vault.split("/").pop()) == null ? void 0 : _d.replace(/-/g, " "));
        data.site.id = data.site.id || "";
        const content = kitrc(data);
        return this.vault.write("kitrc.md", content);
      }
    };
    _log2 = new WeakMap();
    module2.exports = PKLib2;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/obs.ts
var import_obsidian = require("obsidian");
var Obs = class {
  constructor(pkplugin) {
    this.switchMode = async (mode) => {
      const leaf = this.pkplugin.app.workspace.activeLeaf;
      if (!leaf)
        return;
      const viewState = leaf.getViewState();
      const needSwitch = viewState.state.mode != mode;
      if (needSwitch) {
        viewState.state.mode = mode;
        await leaf.setViewState(viewState);
        await this.utils.g.timeout(200);
      }
      return needSwitch;
    };
    this.getAllNotes = () => {
      console.log("getall");
    };
    this.pkplugin = pkplugin;
    this.utils = pkplugin.pklib.utils;
  }
  async write(path, content) {
    const { vault } = this.pkplugin.app;
    const tfile = vault.getAbstractFileByPath(path);
    if (tfile instanceof import_obsidian.TFile)
      vault.delete(tfile);
    if (tfile instanceof import_obsidian.TFolder)
      return false;
    await vault.create(path, content);
  }
  async openFile(file, {
    mode,
    focus = true,
    newPane,
    direction = "vertical" /* default */
  } = {}) {
    const leaf = newPane ? window.app.workspace.splitActiveLeaf(direction) : window.app.workspace.getUnpinnedLeaf();
    if (mode) {
      const viewState = leaf.getViewState();
      viewState.state.mode = mode;
      await leaf.setViewState(viewState, { focus });
    }
    await leaf.openFile(file);
    return leaf;
  }
  getFile(path) {
    if (path instanceof import_obsidian.TFile)
      return path;
    const tfile = this.pkplugin.app.vault.getAbstractFileByPath(path);
    if (tfile instanceof import_obsidian.TFile)
      return tfile;
    return false;
  }
  getFrontmatter(path) {
    var _a;
    const file = this.getFile(path);
    const fm = file ? {
      ...(_a = this.pkplugin.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter
    } : {};
    delete fm.position;
    return fm;
  }
  getTags(path) {
    const file = this.getFile(path);
    if (!file)
      return [];
    const metafile = this.pkplugin.app.metadataCache.getFileCache(file);
    const tags = metafile ? this.utils.a.unique((0, import_obsidian.getAllTags)(metafile)) : [];
    tags.forEach((tag, index) => {
      tags[index] = tag.replace("#", "");
    });
    return tags;
  }
  updateFrontmatter(contents, field, value) {
    const f = contents.match(/^---\r?\n(.*?)\n---\r?\n(.*)$/s), v = `${field}: ${value}`, x = new RegExp(`^${field}:.*$`, "m"), [s, e] = f ? [`${f[1]}
`, f[2]] : ["", contents];
    return f && f[1].match(x) ? contents.replace(x, v) : `---
${s}${v}
---
${e}`;
  }
};
var obs_default = Obs;

// src/setup.ts
var import_obsidian2 = require("obsidian");
var SetupModal = class extends import_obsidian2.Modal {
  constructor(pkplugin, callback) {
    super(app);
    this.pkplugin = pkplugin;
    this.callback = callback;
  }
  onSubmit() {
    this.callback(this.data);
  }
  onOpen() {
    var _a;
    const { contentEl, pkplugin } = this;
    const { pklib } = pkplugin;
    const data = this.data = {
      vault: { kit_folder: pklib.env.vault + "/kit" },
      site: { id: "", name: "" }
    };
    this.data.site.name = pklib.utils.s.capitalize((_a = pklib.env.vault.split("/").pop()) == null ? void 0 : _a.replace(/-/g, " "));
    contentEl.createEl("h1", { text: "Publish Kit Setup" });
    new import_obsidian2.Setting(contentEl).setName("Export Folder").setDesc("absolute path - ex: /Users/batman/mywebsite").addText((text) => {
      return text.setValue(data.vault.kit_folder).onChange((value) => {
        data.vault.kit_folder = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Site ID").setDesc("ex: rec_xxxxxxx").addText((text) => {
      return text.setValue(data.site.id).onChange((value) => {
        data.site.id = value;
      });
    });
    new import_obsidian2.Setting(contentEl).setName("Site Name").addText((text) => {
      return text.setValue(data.site.name).onChange((value) => {
        data.site.name = value;
      });
    });
    new import_obsidian2.Setting(contentEl).addButton((btn) => btn.setButtonText("Submit").setCta().onClick(() => {
      this.close();
      this.onSubmit();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/launcher.ts
var import_obsidian3 = require("obsidian");

// src/commands.ts
var Commands = [
  {
    id: "exportCurrentNote",
    name: "\u{1F4C4}  Export active note",
    desc: ""
  },
  {
    id: "exportAllNotes",
    name: "\u{1F4C1}  Export vault",
    desc: ""
  }
];

// src/launcher.ts
var Launcher = class extends import_obsidian3.SuggestModal {
  constructor(pkplugin) {
    super(app);
    this.pkplugin = pkplugin;
    this.utils = pkplugin.pklib.utils;
  }
  getSuggestions(query) {
    return Commands.filter((item) => item.name.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.name });
  }
  onChooseSuggestion(item, evt) {
    this.pkplugin.runCommand(item.id);
  }
};

// src/report.ts
var import_obsidian4 = require("obsidian");
var ReportModal = class extends import_obsidian4.Modal {
  constructor(pkplugin, callback) {
    super(app);
    this.pkplugin = pkplugin;
    this.callback = callback || (() => {
    });
  }
  onSubmit() {
    this.callback(this.data);
  }
  async onOpen() {
    const { contentEl, pkplugin } = this;
    const { pklib } = pkplugin;
    const cache = pklib.parser.cache;
    const data = this.data = Object.values(cache.note);
    const summary = pklib.parser.print();
    console.log("preview cache", cache);
    contentEl.createEl("h1", { text: "Export preview" });
    new import_obsidian4.Setting(contentEl).setName(`About to export ${data.length} notes in "${pklib.kitrc.vault.kit_folder}"`);
    data.forEach((asset) => {
      const row = new import_obsidian4.Setting(contentEl);
      row.setName(asset.path);
    });
    new import_obsidian4.Setting(contentEl).addButton((btn) => btn.setButtonText("Export").setCta().onClick(async () => {
      await pklib.dumpFiles();
      await pklib.dbSave();
      pkplugin.notice(summary);
      this.close();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var import_pklib = __toESM(require_pklib());
var _log;
var PKPlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    __privateAdd(this, _log, (...args) => {
      this.verbose && console.log(`publishkit \u2794`, ...args);
    });
    this.notice = (str, time = 4e3) => {
      new import_obsidian5.Notice(str, time);
    };
    this.init = () => {
      const { pklib } = this;
      window.pklib = pklib;
      if (pklib.error)
        return this.notice(pklib.error, 1e4);
      if (!pklib.kitrc)
        return this.initSetup();
      if (!pklib.cfg("vault.kit_folder")) {
        const msg = '\u{1F4A5} missing "vault.kit_folder" setting in kitrc.md';
        return this.notice(msg);
      }
      this.statusbar = this.addStatusBarItem();
      this.bindObsidian();
      this.initCommands();
      this.app.metadataCache.on("changed", async (file) => {
        try {
          if (file.path == "kitrc.md") {
            pklib.reloadKitrc();
          }
        } catch (e) {
          this.notice(pklib.betterError(e));
        }
      });
      this.app.workspace.on("file-open", (file) => {
        if (pklib.isProcessing)
          return;
        this.runCommand("displayStatus", file);
      });
      __privateGet(this, _log).call(this, "inited");
    };
    this.displayStatus = async (file) => {
      if (!file || this.pklib.isProcessing)
        return;
      const path = file.path.replace(".md", ".html");
      const exist = await this.pklib.kit.fileExist(path);
      const text = "\u{1F7E2}";
      this.statusbar.empty();
      exist && this.statusbar.createEl("span", { text });
    };
    this.initCommands = () => {
      Commands.forEach((c) => {
        this.addCommand({
          id: c.id,
          name: c.name,
          callback: () => {
            this.runCommand(c.id);
          }
        });
      });
    };
    this.initSetup = () => {
      return new SetupModal(this, async (data) => {
        await this.pklib.createKitrc(data);
        const file = this.obs.getFile("kitrc.md");
        file && this.obs.openFile(file, { newPane: true });
      }).open();
    };
    this.runCommand = async (key, ...args) => {
      if (!this.pklib.kitrc)
        return this.initSetup();
      this[key](...args);
    };
    this.startLauncher = () => {
      new Launcher(this).open();
    };
    this.startReport = () => {
      new ReportModal(this).open();
    };
    this.exportCurrentNote = async (options) => {
      const file = app.workspace.getActiveFile();
      if (!file)
        return this.notice("no active note to export !");
      options = options || { follow: false };
      const result = await this.pklib.exportFile(file.path, options);
      this.notice(result.summary);
      console.log(result.summary);
    };
    this.exportAllNotes = async () => {
      const files = await this.pklib.vault.lsFiles();
      const result = await this.pklib.exportFile(files, { dry: true });
      this.startReport();
    };
    this.bindObsidian = () => {
      const { pklib, obs } = this;
      const getHTML = async () => {
        const leaf = this.app.workspace.activeLeaf;
        if (!leaf)
          throw new Error("no active leaf");
        const html = leaf.view.modes.preview.renderer.sections.reduce((p, c) => p + c.el.innerHTML, "");
        return html;
      };
      pklib.preExport = async () => {
        const needSwitch = await this.obs.switchMode("preview");
        return { needSwitch };
      };
      pklib.postExport = async ({ files, preExport }) => {
        const { needSwitch } = preExport;
        const [firstFile] = files;
        const lastFile = files[files.length - 1];
        if (firstFile != lastFile) {
          const file = this.obs.getFile(firstFile);
          file && await this.obs.openFile(file, {
            mode: needSwitch ? "source" : "preview"
          });
        } else
          needSwitch && await this.obs.switchMode("source");
      };
      pklib.parser.setCustomParseMD(async (file) => {
        file = obs.getFile(file);
        await obs.openFile(file, { mode: "preview" });
        await pklib.utils.g.timeout(pklib.cfg("obsidian.throttle") || 500);
        const frontmatter = obs.getFrontmatter(file);
        const tags = obs.getTags(file);
        const html = await getHTML();
        return { frontmatter, html, tags };
      });
      pklib.parser.setRemovers({
        el: ".collapse-indicator,.list-bullet,.inline-title,.embedded-backlinks,.copy-code-button,.frontmatter-container,.frontmatter,.markdown-preview-pusher,.mod-header,.markdown-embed-link,.markdown-embed,.embed-title",
        class: ".list-view-ul,.table-view-table,.pdf-embed,.media-embed,.internal-embed,.has-list-bullet,.contains-task-list,.task-list-item,.task-list-item-checkbox,.is-checked,.dataview-inline-query,.image-embed,.is-loaded",
        attr: "rel,data-task,data-line,data-heading,data-href,aria-label,aria-label-position,referrerpolicy",
        emptyAttr: "class,data-callout-metadata,data-callout-fold"
      });
      pklib.parser.setTransformer(async (win, txs, pklib2) => {
        const { document: doc, $: $2 } = win;
        const body = doc.querySelector("body");
        if (!body)
          return;
        const { fileToAsset, parser, vault } = pklib2;
        const isInternal = (path) => {
          if (!path.startsWith("app://"))
            return "";
          const local = window.decodeURIComponent(path.match(/app:\/\/local([^?#]+)/)[1]);
          return local.replace(vault.base + "/", "");
        };
        txs.push([
          "a",
          async (el) => {
            const href = el.getAttribute("href") || "";
            if (!href)
              el.href = "javascript:void(0)";
            const file = app.metadataCache.getFirstLinkpathDest(href, "");
            el.removeAttribute("target");
            el.classList.remove("is-unresolved");
            el.classList.remove("internal-link");
            el.classList.remove("external-link");
            if (file) {
              el.classList.add("internal-link");
              const asset = await fileToAsset(file.path);
              el.setAttribute("href", asset.url);
              parser.index(asset);
            } else {
              if (href.startsWith("https://") || href.startsWith("//") || href.startsWith("http://"))
                el.classList.add("external-link");
              else
                el.classList.add("internal-link");
            }
            if (el.classList.contains("external-link"))
              el.setAttribute("target", "_blank");
          }
        ]);
        txs.push([
          "span",
          async (el) => {
            "alt,src".split(",").map((attr) => el.removeAttribute(attr));
          }
        ]);
        txs.push([
          "img",
          async (el) => {
            "alt,".split(",").map((attr) => el.removeAttribute(attr));
            const path = isInternal(el.getAttribute("src"));
            const asset = path && await fileToAsset(path);
            if (!asset)
              return;
            el.setAttribute("src", asset.url);
            parser.index(asset);
          }
        ]);
        txs.push([
          ".pdf-embed iframe",
          async (el) => {
            const path = isInternal(el.getAttribute("src"));
            const asset = path && await fileToAsset(path);
            if (!asset)
              return;
            el.setAttribute("src", asset.url);
            el.setAttribute("frameBorder", "no");
            el.removeAttribute("style");
            parser.index(asset);
            $2(el).parent().addClass("pdf");
          }
        ]);
        txs.push([
          "ul > span",
          async (el) => {
            el.remove();
          }
        ]);
        txs.push([
          "li > span",
          async (el) => {
            if (!$2(el).html())
              el.remove();
          }
        ]);
        txs.push([
          ".block-language-dataviewjs",
          async (el) => {
            const content = $2(`<ul>${$2(el).find("> ul").html()}</ul>`);
            $2(el).replaceWith(content);
          }
        ]);
        txs.push([
          "body > .markdown-embed-content",
          async (el) => {
            const loop = (el2, level = 0) => {
              const html = el2.innerHTML;
              if (!html)
                return false;
              level++;
              const root = $2(html);
              const childs = root.find("> .markdown-preview-sizer > div > .markdown-embed-content");
              if (childs.length)
                childs.toArray().map((el3) => loop(el3, level));
              try {
                const content = root.find("> .markdown-preview-sizer");
                const divs = content.find("> div");
                divs.each(function() {
                  const div = $2(this);
                  if (!div.find("> p")[0])
                    return;
                  div.after(div.html());
                  div.remove();
                });
                const final = content[0].innerHTML;
                if (!final)
                  return el2.remove();
                else {
                  el2.classList.remove("markdown-embed-content");
                  el2.classList.add("embed-content");
                  el2.innerHTML = final;
                }
              } catch (e) {
                console.log("err:flattening:embed", e);
              }
            };
            loop(el);
          }
        ]);
      });
    };
  }
  async onload() {
    this.verbose = true;
    this.pklib = new import_pklib.default({ verbose: true });
    this.obs = new obs_default(this);
    const iconCurrent = this.addRibbonIcon("paper-plane", "PublishKit", (evt) => {
      this.startLauncher();
    });
    if (!this.app.workspace.layoutReady)
      this.app.workspace.onLayoutReady(async () => {
        this.init();
      });
    else
      this.init();
  }
};
_log = new WeakMap();
var main_default = PKPlugin;
/*!
 * jQuery JavaScript Library v3.6.3
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2022-12-20T21:28Z
 */
/**
 * filesize
 *
 * @copyright 2022 Jason Mulligan <jason.mulligan@avoidwork.com>
 * @license BSD-3-Clause
 * @version 10.0.6
 */
